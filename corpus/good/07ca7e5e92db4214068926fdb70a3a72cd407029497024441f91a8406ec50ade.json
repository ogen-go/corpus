{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/eBay/NautilusTelemetry"
		},
		"file": {
			"name": "metrics_service.yaml",
			"size": 0,
			"path": "Sources/NautilusTelemetry/Exporters/OTLP-JSON/Metrics/metrics_service.yaml",
			"byteSize": 46153,
			"content": "openapi: 3.0.1\ninfo:\n  title: opentelemetry/proto/collector/metrics/v1/metrics_service.proto\n  version: version not set\nservers:\n- url: /\npaths:\n  /v1/metrics:\n    post:\n      tags:\n      - MetricsService\n      summary: |-\n        For performance reasons, it is recommended to keep this RPC\n        alive for the entire life of the application.\n      operationId: MetricsService_Export\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/v1ExportMetricsServiceRequest'\n        required: true\n      responses:\n        '200':\n          description: A successful response.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/v1ExportMetricsServiceResponse'\n        '429':\n          description: Too Many Requests\n        default:\n          description: An unexpected error response.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/runtimeError'\n      x-codegen-request-body-name: body\ncomponents:\n  schemas:\n    ExponentialHistogramDataPointBuckets:\n      type: object\n      properties:\n        offset:\n          type: integer\n          description: |-\n            Offset is the bucket index of the first entry in the bucket_counts array.\n\n            Note: This uses a varint encoding as a simple form of compression.\n          format: int32\n        bucket_counts:\n          type: array\n          description: |-\n            Count is an array of counts, where count[i] carries the count\n            of the bucket at index (offset+i).  count[i] is the count of\n            values greater than or equal to base^(offset+i) and less than\n            base^(offset+i+1).\n\n            Note: By contrast, the explicit HistogramDataPoint uses\n            fixed64.  This field is expected to have many buckets,\n            especially zeros, so uint64 has been selected to ensure\n            varint encoding.\n          items:\n            type: string\n            format: uint64\n      description: |-\n        Buckets are a set of bucket counts, encoded in a contiguous array\n        of counts.\n    SummaryDataPointValueAtQuantile:\n      type: object\n      properties:\n        quantile:\n          type: number\n          description: |-\n            The quantile of a distribution. Must be in the interval\n            [0.0, 1.0].\n          format: double\n        value:\n          type: number\n          description: |-\n            The value at the given quantile of a distribution.\n\n            Quantile values must NOT be negative.\n          format: double\n      description: |-\n        Represents the value at a given quantile of a distribution.\n\n        To record Min and Max values following conventions are used:\n        - The 1.0 quantile is equivalent to the maximum value observed.\n        - The 0.0 quantile is equivalent to the minimum value observed.\n\n        See the following issue for more context:\n        https://github.com/open-telemetry/opentelemetry-proto/issues/125\n    protobufAny:\n      type: object\n      properties:\n        type_url:\n          type: string\n        value:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n    runtimeError:\n      type: object\n      properties:\n        error:\n          type: string\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n        details:\n          type: array\n          items:\n            $ref: '#/components/schemas/protobufAny'\n    v1AggregationTemporality:\n      type: string\n      description: |-\n        AggregationTemporality defines how a metric aggregator reports aggregated\n        values. It describes how those values relate to the time interval over\n        which they are aggregated.\n\n         - AGGREGATION_TEMPORALITY_UNSPECIFIED: UNSPECIFIED is the default AggregationTemporality, it MUST not be used.\n         - AGGREGATION_TEMPORALITY_DELTA: DELTA is an AggregationTemporality for a metric aggregator which reports\n        changes since last report time. Successive metrics contain aggregation of\n        values from continuous and non-overlapping intervals.\n\n        The values for a DELTA metric are based only on the time interval\n        associated with one measurement cycle. There is no dependency on\n        previous measurements like is the case for CUMULATIVE metrics.\n\n        For example, consider a system measuring the number of requests that\n        it receives and reports the sum of these requests every second as a\n        DELTA metric:\n\n          1. The system starts receiving at time=t_0.\n          2. A request is received, the system measures 1 request.\n          3. A request is received, the system measures 1 request.\n          4. A request is received, the system measures 1 request.\n          5. The 1 second collection cycle ends. A metric is exported for the\n             number of requests received over the interval of time t_0 to\n             t_0+1 with a value of 3.\n          6. A request is received, the system measures 1 request.\n          7. A request is received, the system measures 1 request.\n          8. The 1 second collection cycle ends. A metric is exported for the\n             number of requests received over the interval of time t_0+1 to\n             t_0+2 with a value of 2.\n         - AGGREGATION_TEMPORALITY_CUMULATIVE: CUMULATIVE is an AggregationTemporality for a metric aggregator which\n        reports changes since a fixed start time. This means that current values\n        of a CUMULATIVE metric depend on all previous measurements since the\n        start time. Because of this, the sender is required to retain this state\n        in some form. If this state is lost or invalidated, the CUMULATIVE metric\n        values MUST be reset and a new fixed start time following the last\n        reported measurement time sent MUST be used.\n\n        For example, consider a system measuring the number of requests that\n        it receives and reports the sum of these requests every second as a\n        CUMULATIVE metric:\n\n          1. The system starts receiving at time=t_0.\n          2. A request is received, the system measures 1 request.\n          3. A request is received, the system measures 1 request.\n          4. A request is received, the system measures 1 request.\n          5. The 1 second collection cycle ends. A metric is exported for the\n             number of requests received over the interval of time t_0 to\n             t_0+1 with a value of 3.\n          6. A request is received, the system measures 1 request.\n          7. A request is received, the system measures 1 request.\n          8. The 1 second collection cycle ends. A metric is exported for the\n             number of requests received over the interval of time t_0 to\n             t_0+2 with a value of 5.\n          9. The system experiences a fault and loses state.\n          10. The system recovers and resumes receiving at time=t_1.\n          11. A request is received, the system measures 1 request.\n          12. The 1 second collection cycle ends. A metric is exported for the\n             number of requests received over the interval of time t_1 to\n             t_0+1 with a value of 1.\n\n        Note: Even though, when reporting changes since last report time, using\n        CUMULATIVE is valid, it is not recommended. This may cause problems for\n        systems that do not use start_time to determine when the aggregation\n        value was reset (e.g. Prometheus).\n      default: AGGREGATION_TEMPORALITY_UNSPECIFIED\n      enum:\n      - AGGREGATION_TEMPORALITY_UNSPECIFIED\n      - AGGREGATION_TEMPORALITY_DELTA\n      - AGGREGATION_TEMPORALITY_CUMULATIVE\n    v1AnyValue:\n      type: object\n      properties:\n        string_value:\n          type: string\n        bool_value:\n          type: boolean\n        int_value:\n          type: string\n          format: int64\n        double_value:\n          type: number\n          format: double\n        array_value:\n          $ref: '#/components/schemas/v1ArrayValue'\n        kvlist_value:\n          $ref: '#/components/schemas/v1KeyValueList'\n        bytes_value:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n      description: |-\n        AnyValue is used to represent any type of attribute value. AnyValue may contain a\n        primitive value such as a string or integer or it may contain an arbitrary nested\n        object containing arrays, key-value lists and primitives.\n    v1ArrayValue:\n      type: object\n      properties:\n        values:\n          type: array\n          description: Array of values. The array may be empty (contain 0 elements).\n          items:\n            $ref: '#/components/schemas/v1AnyValue'\n      description: |-\n        ArrayValue is a list of AnyValue messages. We need ArrayValue as a message\n        since oneof in AnyValue does not allow repeated fields.\n    v1Exemplar:\n      type: object\n      properties:\n        filtered_attributes:\n          title: |-\n            The set of key/value pairs that were filtered out by the aggregator, but\n            recorded alongside the original measurement. Only key/value pairs that were\n            filtered out by the aggregator should be included\n          type: array\n          items:\n            $ref: '#/components/schemas/v1KeyValue'\n        filtered_labels:\n          type: array\n          description: |-\n            Labels is deprecated and will be removed soon.\n            1. Old senders and receivers that are not aware of this change will\n            continue using the `filtered_labels` field.\n            2. New senders, which are aware of this change MUST send only\n            `filtered_attributes`.\n            3. New receivers, which are aware of this change MUST convert this into\n            `filtered_labels` by simply converting all int64 values into float.\n\n            This field will be removed in ~3 months, on July 1, 2021.\n          items:\n            $ref: '#/components/schemas/v1StringKeyValue'\n        time_unix_nano:\n          title: time_unix_nano is the exact time when this exemplar was recorded\n          type: string\n          description: |-\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        as_double:\n          type: number\n          format: double\n        as_int:\n          type: string\n          format: int64\n        span_id:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: |-\n            (Optional) Span ID of the exemplar trace.\n            span_id may be missing if the measurement is not recorded inside a trace\n            or if the trace is not sampled.\n          format: byte\n        trace_id:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: |-\n            (Optional) Trace ID of the exemplar trace.\n            trace_id may be missing if the measurement is not recorded inside a trace\n            or if the trace is not sampled.\n          format: byte\n      description: |-\n        A representation of an exemplar, which is a sample input measurement.\n        Exemplars also hold information about the environment when the measurement\n        was recorded, for example the span and trace ID of the active span when the\n        exemplar was recorded.\n    v1ExponentialHistogram:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1ExponentialHistogramDataPoint'\n        aggregation_temporality:\n          $ref: '#/components/schemas/v1AggregationTemporality'\n      description: |-\n        ExponentialHistogram represents the type of a metric that is calculated by aggregating\n        as a ExponentialHistogram of all reported double measurements over a time interval.\n    v1ExponentialHistogramDataPoint:\n      type: object\n      properties:\n        attributes:\n          type: array\n          description: |-\n            The set of key/value pairs that uniquely identify the timeseries from\n            where this point belongs. The list may be empty (may contain 0 elements).\n          items:\n            $ref: '#/components/schemas/v1KeyValue'\n        start_time_unix_nano:\n          type: string\n          description: |-\n            StartTimeUnixNano is optional but strongly encouraged, see the\n            the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        time_unix_nano:\n          type: string\n          description: |-\n            TimeUnixNano is required, see the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        count:\n          type: string\n          description: |-\n            count is the number of values in the population. Must be\n            non-negative. This value must be equal to the sum of the \"bucket_counts\"\n            values in the positive and negative Buckets plus the \"zero_count\" field.\n          format: uint64\n        sum:\n          type: number\n          description: |-\n            sum of the values in the population. If count is zero then this field\n            must be zero.\n\n            Note: Sum should only be filled out when measuring non-negative discrete\n            events, and is assumed to be monotonic over the values of these events.\n            Negative events *can* be recorded, but sum should not be filled out when\n            doing so.  This is specifically to enforce compatibility w/ OpenMetrics,\n            see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram\n          format: double\n        scale:\n          title: |-\n            scale describes the resolution of the histogram.  Boundaries are\n            located at powers of the base, where:\n          type: integer\n          description: |-\n            base = (2^(2^-scale))\n\n            The histogram bucket identified by `index`, a signed integer,\n            contains values that are greater than or equal to (base^index) and\n            less than (base^(index+1)).\n\n            The positive and negative ranges of the histogram are expressed\n            separately.  Negative values are mapped by their absolute value\n            into the negative range using the same scale as the positive range.\n\n            scale is not restricted by the protocol, as the permissible\n            values depend on the range of the data.\n          format: int32\n        zero_count:\n          type: string\n          description: |-\n            zero_count is the count of values that are either exactly zero or\n            within the region considered zero by the instrumentation at the\n            tolerated degree of precision.  This bucket stores values that\n            cannot be expressed using the standard exponential formula as\n            well as values that have been rounded to zero.\n\n            Implementations MAY consider the zero bucket to have probability\n            mass equal to (zero_count / count).\n          format: uint64\n        positive:\n          $ref: '#/components/schemas/ExponentialHistogramDataPointBuckets'\n        negative:\n          $ref: '#/components/schemas/ExponentialHistogramDataPointBuckets'\n        flags:\n          type: integer\n          description: |-\n            Flags that apply to this specific data point.  See DataPointFlags\n            for the available flags and their meaning.\n          format: int64\n        exemplars:\n          title: |-\n            (Optional) List of exemplars collected from\n            measurements that were used to form the data point\n          type: array\n          items:\n            $ref: '#/components/schemas/v1Exemplar'\n      description: |-\n        ExponentialHistogramDataPoint is a single data point in a timeseries that describes the\n        time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains\n        summary statistics for a population of values, it may optionally contain the\n        distribution of those values across a set of buckets.\n    v1ExportMetricsServiceRequest:\n      type: object\n      properties:\n        resource_metrics:\n          type: array\n          description: |-\n            An array of ResourceMetrics.\n            For data coming from a single resource this array will typically contain one\n            element. Intermediary nodes (such as OpenTelemetry Collector) that receive\n            data from multiple origins typically batch the data before forwarding further and\n            in that case this array will contain multiple elements.\n          items:\n            $ref: '#/components/schemas/v1ResourceMetrics'\n    v1ExportMetricsServiceResponse:\n      type: object\n    v1Gauge:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1NumberDataPoint'\n      description: |-\n        Gauge represents the type of a scalar metric that always exports the\n        \"current value\" for every data point. It should be used for an \"unknown\"\n        aggregation.\n\n        A Gauge does not support different aggregation temporalities. Given the\n        aggregation is unknown, points cannot be combined using the same\n        aggregation, regardless of aggregation temporalities. Therefore,\n        AggregationTemporality is not included. Consequently, this also means\n        \"StartTimeUnixNano\" is ignored for all data points.\n    v1Histogram:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1HistogramDataPoint'\n        aggregation_temporality:\n          $ref: '#/components/schemas/v1AggregationTemporality'\n      description: |-\n        Histogram represents the type of a metric that is calculated by aggregating\n        as a Histogram of all reported measurements over a time interval.\n    v1HistogramDataPoint:\n      type: object\n      properties:\n        attributes:\n          type: array\n          description: |-\n            The set of key/value pairs that uniquely identify the timeseries from\n            where this point belongs. The list may be empty (may contain 0 elements).\n          items:\n            $ref: '#/components/schemas/v1KeyValue'\n        labels:\n          type: array\n          description: |-\n            Labels is deprecated and will be removed soon.\n            1. Old senders and receivers that are not aware of this change will\n            continue using the `labels` field.\n            2. New senders, which are aware of this change MUST send only `attributes`.\n            3. New receivers, which are aware of this change MUST convert this into\n            `labels` by simply converting all int64 values into float.\n\n            This field will be removed in ~3 months, on July 1, 2021.\n          items:\n            $ref: '#/components/schemas/v1StringKeyValue'\n        start_time_unix_nano:\n          type: string\n          description: |-\n            StartTimeUnixNano is optional but strongly encouraged, see the\n            the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        time_unix_nano:\n          type: string\n          description: |-\n            TimeUnixNano is required, see the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        count:\n          type: string\n          description: |-\n            count is the number of values in the population. Must be non-negative. This\n            value must be equal to the sum of the \"count\" fields in buckets if a\n            histogram is provided.\n          format: uint64\n        sum:\n          type: number\n          description: |-\n            sum of the values in the population. If count is zero then this field\n            must be zero.\n\n            Note: Sum should only be filled out when measuring non-negative discrete\n            events, and is assumed to be monotonic over the values of these events.\n            Negative events *can* be recorded, but sum should not be filled out when\n            doing so.  This is specifically to enforce compatibility w/ OpenMetrics,\n            see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram\n          format: double\n        bucket_counts:\n          type: array\n          description: |-\n            bucket_counts is an optional field contains the count values of histogram\n            for each bucket.\n\n            The sum of the bucket_counts must equal the value in the count field.\n\n            The number of elements in bucket_counts array must be by one greater than\n            the number of elements in explicit_bounds array.\n          items:\n            type: string\n            format: uint64\n        explicit_bounds:\n          type: array\n          description: |-\n            explicit_bounds specifies buckets with explicitly defined bounds for values.\n\n            The boundaries for bucket at index i are:\n\n            (-infinity, explicit_bounds[i]] for i == 0\n            (explicit_bounds[i-1], explicit_bounds[i]] for 0 \u003c i \u003c size(explicit_bounds)\n            (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)\n\n            The values in the explicit_bounds array must be strictly increasing.\n\n            Histogram buckets are inclusive of their upper boundary, except the last\n            bucket where the boundary is at infinity. This format is intentionally\n            compatible with the OpenMetrics histogram definition.\n          items:\n            type: number\n            format: double\n        exemplars:\n          title: |-\n            (Optional) List of exemplars collected from\n            measurements that were used to form the data point\n          type: array\n          items:\n            $ref: '#/components/schemas/v1Exemplar'\n        flags:\n          type: integer\n          description: |-\n            Flags that apply to this specific data point.  See DataPointFlags\n            for the available flags and their meaning.\n          format: int64\n      description: |-\n        HistogramDataPoint is a single data point in a timeseries that describes the\n        time-varying values of a Histogram. A Histogram contains summary statistics\n        for a population of values, it may optionally contain the distribution of\n        those values across a set of buckets.\n\n        If the histogram contains the distribution of values, then both\n        \"explicit_bounds\" and \"bucket counts\" fields must be defined.\n        If the histogram does not contain the distribution of values, then both\n        \"explicit_bounds\" and \"bucket_counts\" must be omitted and only \"count\" and\n        \"sum\" are known.\n    v1InstrumentationLibrary:\n      type: object\n      properties:\n        name:\n          type: string\n          description: An empty instrumentation library name means the name is unknown.\n        version:\n          type: string\n      description: |-\n        InstrumentationLibrary is a message representing the instrumentation library information\n        such as the fully qualified name and version.\n    v1InstrumentationLibraryMetrics:\n      type: object\n      properties:\n        instrumentation_library:\n          $ref: '#/components/schemas/v1InstrumentationLibrary'\n        metrics:\n          type: array\n          description: A list of metrics that originate from an instrumentation library.\n          items:\n            $ref: '#/components/schemas/v1Metric'\n        schema_url:\n          type: string\n          description: This schema_url applies to all metrics in the \"metrics\" field.\n      description: A collection of Metrics produced by an InstrumentationLibrary.\n    v1IntDataPoint:\n      type: object\n      properties:\n        labels:\n          type: array\n          description: The set of labels that uniquely identify this timeseries.\n          items:\n            $ref: '#/components/schemas/v1StringKeyValue'\n        start_time_unix_nano:\n          type: string\n          description: |-\n            StartTimeUnixNano is optional but strongly encouraged, see the\n            the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        time_unix_nano:\n          type: string\n          description: |-\n            TimeUnixNano is required, see the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        value:\n          type: string\n          description: value itself.\n          format: int64\n        exemplars:\n          title: |-\n            (Optional) List of exemplars collected from\n            measurements that were used to form the data point\n          type: array\n          items:\n            $ref: '#/components/schemas/v1IntExemplar'\n      description: IntDataPoint is deprecated. Use integer value in NumberDataPoint.\n    v1IntExemplar:\n      title: IntExemplar is deprecated. Use Exemplar with as_int for value\n      type: object\n      properties:\n        filtered_labels:\n          title: |-\n            The set of labels that were filtered out by the aggregator, but recorded\n            alongside the original measurement. Only labels that were filtered out\n            by the aggregator should be included\n          type: array\n          items:\n            $ref: '#/components/schemas/v1StringKeyValue'\n        time_unix_nano:\n          title: time_unix_nano is the exact time when this exemplar was recorded\n          type: string\n          description: |-\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        value:\n          type: string\n          description: Numerical int value of the measurement that was recorded.\n          format: int64\n        span_id:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: |-\n            (Optional) Span ID of the exemplar trace.\n            span_id may be missing if the measurement is not recorded inside a trace\n            or if the trace is not sampled.\n          format: byte\n        trace_id:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: |-\n            (Optional) Trace ID of the exemplar trace.\n            trace_id may be missing if the measurement is not recorded inside a trace\n            or if the trace is not sampled.\n          format: byte\n    v1IntGauge:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1IntDataPoint'\n      description: IntGauge is deprecated.  Use Gauge with an integer value in NumberDataPoint.\n    v1IntHistogram:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1IntHistogramDataPoint'\n        aggregation_temporality:\n          $ref: '#/components/schemas/v1AggregationTemporality'\n      description: |-\n        IntHistogram is deprecated, replaced by Histogram points using double-\n        valued exemplars.\n    v1IntHistogramDataPoint:\n      type: object\n      properties:\n        labels:\n          type: array\n          description: The set of labels that uniquely identify this timeseries.\n          items:\n            $ref: '#/components/schemas/v1StringKeyValue'\n        start_time_unix_nano:\n          type: string\n          description: |-\n            StartTimeUnixNano is optional but strongly encouraged, see the\n            the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        time_unix_nano:\n          type: string\n          description: |-\n            TimeUnixNano is required, see the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        count:\n          type: string\n          description: |-\n            count is the number of values in the population. Must be non-negative. This\n            value must be equal to the sum of the \"count\" fields in buckets if a\n            histogram is provided.\n          format: uint64\n        sum:\n          type: string\n          description: |-\n            sum of the values in the population. If count is zero then this field\n            must be zero. This value must be equal to the sum of the \"sum\" fields in\n            buckets if a histogram is provided.\n          format: int64\n        bucket_counts:\n          type: array\n          description: |-\n            bucket_counts is an optional field contains the count values of histogram\n            for each bucket.\n\n            The sum of the bucket_counts must equal the value in the count field.\n\n            The number of elements in bucket_counts array must be by one greater than\n            the number of elements in explicit_bounds array.\n          items:\n            type: string\n            format: uint64\n        explicit_bounds:\n          type: array\n          description: |-\n            explicit_bounds specifies buckets with explicitly defined bounds for values.\n\n            The boundaries for bucket at index i are:\n\n            (-infinity, explicit_bounds[i]] for i == 0\n            (explicit_bounds[i-1], explicit_bounds[i]] for 0 \u003c i \u003c size(explicit_bounds)\n            (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)\n\n            The values in the explicit_bounds array must be strictly increasing.\n\n            Histogram buckets are inclusive of their upper boundary, except the last\n            bucket where the boundary is at infinity. This format is intentionally\n            compatible with the OpenMetrics histogram definition.\n          items:\n            type: number\n            format: double\n        exemplars:\n          title: |-\n            (Optional) List of exemplars collected from\n            measurements that were used to form the data point\n          type: array\n          items:\n            $ref: '#/components/schemas/v1IntExemplar'\n      description: IntHistogramDataPoint is deprecated; use HistogramDataPoint.\n    v1IntSum:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1IntDataPoint'\n        aggregation_temporality:\n          $ref: '#/components/schemas/v1AggregationTemporality'\n        is_monotonic:\n          type: boolean\n          description: If \"true\" means that the sum is monotonic.\n      description: IntSum is deprecated.  Use Sum with an integer value in NumberDataPoint.\n    v1KeyValue:\n      type: object\n      properties:\n        key:\n          type: string\n        value:\n          $ref: '#/components/schemas/v1AnyValue'\n      description: |-\n        KeyValue is a key-value pair that is used to store Span attributes, Link\n        attributes, etc.\n    v1KeyValueList:\n      type: object\n      properties:\n        values:\n          type: array\n          description: |-\n            A collection of key/value pairs of key-value pairs. The list may be empty (may\n            contain 0 elements).\n          items:\n            $ref: '#/components/schemas/v1KeyValue'\n      description: |-\n        KeyValueList is a list of KeyValue messages. We need KeyValueList as a message\n        since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need\n        a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to\n        avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches\n        are semantically equivalent.\n    v1Metric:\n      title: |-\n        Defines a Metric which has one or more timeseries.  The following is a\n        brief summary of the Metric data model.  For more details, see:\n      type: object\n      properties:\n        name:\n          type: string\n          description: name of the metric, including its DNS name prefix. It must\n            be unique.\n        description:\n          type: string\n          description: description of the metric, which can be used in documentation.\n        unit:\n          type: string\n          description: |-\n            unit in which the metric value is reported. Follows the format\n            described by http://unitsofmeasure.org/ucum.html.\n        int_gauge:\n          $ref: '#/components/schemas/v1IntGauge'\n        gauge:\n          $ref: '#/components/schemas/v1Gauge'\n        int_sum:\n          $ref: '#/components/schemas/v1IntSum'\n        sum:\n          $ref: '#/components/schemas/v1Sum'\n        int_histogram:\n          $ref: '#/components/schemas/v1IntHistogram'\n        histogram:\n          $ref: '#/components/schemas/v1Histogram'\n        exponential_histogram:\n          $ref: '#/components/schemas/v1ExponentialHistogram'\n        summary:\n          $ref: '#/components/schemas/v1Summary'\n      description: |-\n        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/datamodel.md\n\n\n        The data model and relation between entities is shown in the\n        diagram below. Here, \"DataPoint\" is the term used to refer to any\n        one of the specific data point value types, and \"points\" is the term used\n        to refer to any one of the lists of points contained in the Metric.\n\n        - Metric is composed of a metadata and data.\n        - Metadata part contains a name, description, unit.\n        - Data is one of the possible types (Sum, Gauge, Histogram, Summary).\n        - DataPoint contains timestamps, attributes, and one of the possible value type\n          fields.\n\n            Metric\n         +------------+\n         |name        |\n         |description |\n         |unit        |     +------------------------------------+\n         |data        |---\u003e |Gauge, Sum, Histogram, Summary, ... |\n         +------------+     +------------------------------------+\n\n           Data [One of Gauge, Sum, Histogram, Summary, ...]\n         +-----------+\n         |...        |  // Metadata about the Data.\n         |points     |--+\n         +-----------+  |\n                        |      +---------------------------+\n                        |      |DataPoint 1                |\n                        v      |+------+------+   +------+ |\n                     +-----+   ||label |label |...|label | |\n                     |  1  |--\u003e||value1|value2|...|valueN| |\n                     +-----+   |+------+------+   +------+ |\n                     |  .  |   |+-----+                    |\n                     |  .  |   ||value|                    |\n                     |  .  |   |+-----+                    |\n                     |  .  |   +---------------------------+\n                     |  .  |                   .\n                     |  .  |                   .\n                     |  .  |                   .\n                     |  .  |   +---------------------------+\n                     |  .  |   |DataPoint M                |\n                     +-----+   |+------+------+   +------+ |\n                     |  M  |--\u003e||label |label |...|label | |\n                     +-----+   ||value1|value2|...|valueN| |\n                               |+------+------+   +------+ |\n                               |+-----+                    |\n                               ||value|                    |\n                               |+-----+                    |\n                               +---------------------------+\n\n        Each distinct type of DataPoint represents the output of a specific\n        aggregation function, the result of applying the DataPoint's\n        associated function of to one or more measurements.\n\n        All DataPoint types have three common fields:\n        - Attributes includes key-value pairs associated with the data point\n        - TimeUnixNano is required, set to the end time of the aggregation\n        - StartTimeUnixNano is optional, but strongly encouraged for DataPoints\n          having an AggregationTemporality field, as discussed below.\n\n        Both TimeUnixNano and StartTimeUnixNano values are expressed as\n        UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.\n\n        # TimeUnixNano\n\n        This field is required, having consistent interpretation across\n        DataPoint types.  TimeUnixNano is the moment corresponding to when\n        the data point's aggregate value was captured.\n\n        Data points with the 0 value for TimeUnixNano SHOULD be rejected\n        by consumers.\n\n        # StartTimeUnixNano\n\n        StartTimeUnixNano in general allows detecting when a sequence of\n        observations is unbroken.  This field indicates to consumers the\n        start time for points with cumulative and delta\n        AggregationTemporality, and it should be included whenever possible\n        to support correct rate calculation.  Although it may be omitted\n        when the start time is truly unknown, setting StartTimeUnixNano is\n        strongly encouraged.\n    v1NumberDataPoint:\n      type: object\n      properties:\n        attributes:\n          type: array\n          description: |-\n            The set of key/value pairs that uniquely identify the timeseries from\n            where this point belongs. The list may be empty (may contain 0 elements).\n          items:\n            $ref: '#/components/schemas/v1KeyValue'\n        labels:\n          type: array\n          description: |-\n            Labels is deprecated and will be removed soon.\n            1. Old senders and receivers that are not aware of this change will\n            continue using the `labels` field.\n            2. New senders, which are aware of this change MUST send only `attributes`.\n            3. New receivers, which are aware of this change MUST convert this into\n            `labels` by simply converting all int64 values into float.\n\n            This field will be removed in ~3 months, on July 1, 2021.\n          items:\n            $ref: '#/components/schemas/v1StringKeyValue'\n        start_time_unix_nano:\n          type: string\n          description: |-\n            StartTimeUnixNano is optional but strongly encouraged, see the\n            the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        time_unix_nano:\n          type: string\n          description: |-\n            TimeUnixNano is required, see the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        as_double:\n          type: number\n          format: double\n        as_int:\n          type: string\n          format: int64\n        exemplars:\n          title: |-\n            (Optional) List of exemplars collected from\n            measurements that were used to form the data point\n          type: array\n          items:\n            $ref: '#/components/schemas/v1Exemplar'\n        flags:\n          type: integer\n          description: |-\n            Flags that apply to this specific data point.  See DataPointFlags\n            for the available flags and their meaning.\n          format: int64\n      description: |-\n        NumberDataPoint is a single data point in a timeseries that describes the\n        time-varying scalar value of a metric.\n    v1Resource:\n      type: object\n      properties:\n        attributes:\n          type: array\n          description: Set of labels that describe the resource.\n          items:\n            $ref: '#/components/schemas/v1KeyValue'\n        dropped_attributes_count:\n          type: integer\n          description: |-\n            dropped_attributes_count is the number of dropped attributes. If the value is 0, then\n            no attributes were dropped.\n          format: int64\n      description: Resource information.\n    v1ResourceMetrics:\n      type: object\n      properties:\n        resource:\n          $ref: '#/components/schemas/v1Resource'\n        instrumentation_library_metrics:\n          type: array\n          description: A list of metrics that originate from a resource.\n          items:\n            $ref: '#/components/schemas/v1InstrumentationLibraryMetrics'\n        schema_url:\n          type: string\n          description: |-\n            This schema_url applies to the data in the \"resource\" field. It does not apply\n            to the data in the \"instrumentation_library_metrics\" field which have their own\n            schema_url field.\n      description: A collection of InstrumentationLibraryMetrics from a Resource.\n    v1StringKeyValue:\n      type: object\n      properties:\n        key:\n          type: string\n        value:\n          type: string\n      description: |-\n        StringKeyValue is a pair of key/value strings. This is the simpler (and faster) version\n        of KeyValue that only supports string values.\n    v1Sum:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1NumberDataPoint'\n        aggregation_temporality:\n          $ref: '#/components/schemas/v1AggregationTemporality'\n        is_monotonic:\n          type: boolean\n          description: If \"true\" means that the sum is monotonic.\n      description: |-\n        Sum represents the type of a scalar metric that is calculated as a sum of all\n        reported measurements over a time interval.\n    v1Summary:\n      type: object\n      properties:\n        data_points:\n          type: array\n          items:\n            $ref: '#/components/schemas/v1SummaryDataPoint'\n      description: |-\n        Summary metric data are used to convey quantile summaries,\n        a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)\n        and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)\n        data type. These data points cannot always be merged in a meaningful way.\n        While they can be useful in some applications, histogram data points are\n        recommended for new applications.\n    v1SummaryDataPoint:\n      type: object\n      properties:\n        attributes:\n          type: array\n          description: |-\n            The set of key/value pairs that uniquely identify the timeseries from\n            where this point belongs. The list may be empty (may contain 0 elements).\n          items:\n            $ref: '#/components/schemas/v1KeyValue'\n        labels:\n          type: array\n          description: |-\n            Labels is deprecated and will be removed soon.\n            1. Old senders and receivers that are not aware of this change will\n            continue using the `labels` field.\n            2. New senders, which are aware of this change MUST send only `attributes`.\n            3. New receivers, which are aware of this change MUST convert this into\n            `labels` by simply converting all int64 values into float.\n\n            This field will be removed in ~3 months, on July 1, 2021.\n          items:\n            $ref: '#/components/schemas/v1StringKeyValue'\n        start_time_unix_nano:\n          type: string\n          description: |-\n            StartTimeUnixNano is optional but strongly encouraged, see the\n            the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        time_unix_nano:\n          type: string\n          description: |-\n            TimeUnixNano is required, see the detailed comments above Metric.\n\n            Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January\n            1970.\n          format: uint64\n        count:\n          type: string\n          description: count is the number of values in the population. Must be non-negative.\n          format: uint64\n        sum:\n          type: number\n          description: |-\n            sum of the values in the population. If count is zero then this field\n            must be zero.\n\n            Note: Sum should only be filled out when measuring non-negative discrete\n            events, and is assumed to be monotonic over the values of these events.\n            Negative events *can* be recorded, but sum should not be filled out when\n            doing so.  This is specifically to enforce compatibility w/ OpenMetrics,\n            see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#summary\n          format: double\n        quantile_values:\n          type: array\n          description: |-\n            (Optional) list of values at different quantiles of the distribution calculated\n            from the current snapshot. The quantiles must be strictly increasing.\n          items:\n            $ref: '#/components/schemas/SummaryDataPointValueAtQuantile'\n        flags:\n          type: integer\n          description: |-\n            Flags that apply to this specific data point.  See DataPointFlags\n            for the available flags and their meaning.\n          format: int64\n      description: |-\n        SummaryDataPoint is a single data point in a timeseries that describes the\n        time-varying values of a Summary metric.\n",
			"canonicalURL": "/github.com/eBay/NautilusTelemetry@57ba0a217286b32de6758b44c5603afd31240116/-/blob/Sources/NautilusTelemetry/Exporters/OTLP-JSON/Metrics/metrics_service.yaml",
			"externalURLs": [
				{
					"url": "https://github.com/eBay/NautilusTelemetry/blob/57ba0a217286b32de6758b44c5603afd31240116/Sources/NautilusTelemetry/Exporters/OTLP-JSON/Metrics/metrics_service.yaml",
					"serviceKind": "GITHUB"
				}
			]
		}
	}
}