{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/nftstorage/nft.storage"
		},
		"file": {
			"name": "schema.yml",
			"size": 0,
			"path": "packages/website/public/schema.yml",
			"byteSize": 24844,
			"content": "openapi: 3.0.0\ninfo:\n  title: NFT Storage API\n  version: '1.0'\n\nservers:\n  - url: https://api.nft.storage\n  - url: http://127.0.0.1:8787\n\ntags:\n  - name: NFT Storage\npaths:\n  /store:\n    post:\n      tags:\n        - NFT Storage\n      summary: Store an ERC-1155 compatible NFT\n      description: |\n        Store an [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155)-compatible NFT as \n        a collection of content-addressed objects connected by IPFS CID links.\n\n        The POST request accepts `multipart/form-data` content restricted to a body size of 100MB (see \"Size limitations\" below for more information). The request must contain a form field named `meta`.\n\n        The `meta` field must contain a JSON string that conforms to the [ERC-1155 metadata schema](https://eips.ethereum.org/EIPS/eip-1155#metadata).\n\n        Any field(s) inside the `meta` object can be substituted with an ipfs URL to a file(s), by providing a form data field with a name matching a (`.` delimited) property path and value containing the file content (in binary string or plain text depending on file format).\n\n        The name of the form data field containing the file content should be the \"path\" of the JSON field, using `.` to traverse nested\n        objects.\n\n        For example, with a `meta` object of the form:\n\n          ```json\n          {\n            \"name\": \"Hello\",\n            \"image\": undefined,\n            \"properties\": {\n              \"videoClip\": undefined\n            }\n          }\n          ```\n\n        You must include form fields named `image` and `properties.videoClip` in your request body, with the content of the image and video files as the form field values.\n\n        All form fields other than `meta` must contain binary file data, and the field name will be used as a '.' delimited property path for the `meta` object, as described above. If the form field name matches a `meta` property with a non-falsy value, the request will be rejected with an error.\n\n        ### Mime Type Recommendations\n\n        The ERC-1155 metadata standard specifies that the `image` metadata field should reference a file with a content type of `image/*`.\n        An earlier version of this API enforced this as a requirement, but this proved to be incompatible with some existing systems and the\n        requirement was relaxed, although you may see a warning when using the official JavaScript client.\n\n        We highly recommend that you only use content with an `image/*` content type for your `image` field, and include other content types in the\n        `properties` field as additional references.\n\n        ### Size limitations\n\n        The store endpoint is restricted to a total request body size of 100MB, which includes the metadata and all attached files. To store larger files, you\n        can use the /upload endpoint with chunked CAR files (see \"/upload\").\n\n        ### Rate limits\n\n        This API imposes rate limits to ensure quality of service. You may receive a 429 \"Too many requests\" error if you make more than 30 requests with the same API token within a 10 second window. Upon receiving a response with a 429 status, clients should retry the failed request after a small delay. To avoid 429 responses, you may wish to implement client-side request throttling to stay within the limits (note: the JS client automatically does this).\n\n      operationId: store\n      requestBody:\n        required: true\n        content:\n          multipart/form-data:\n            schema:\n              type: object\n              properties:\n                meta:\n                  type: string\n              additionalProperties:\n                type: string\n                format: binary\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                $ref: '#/components/schemas/UploadResponse'\n        '400':\n          $ref: '#/components/responses/badRequest'\n        '401':\n          $ref: '#/components/responses/unauthorized'\n        '403':\n          $ref: '#/components/responses/forbidden'\n        '500':\n          $ref: '#/components/responses/internalServerError'\n\n  /upload:\n    post:\n      tags:\n        - NFT Storage\n      summary: Store a file\n      description: |\n        Store a file with nft.storage.\n        You can upload either a single file or multiple files in a directory.\n        Each request to /upload is restricted to a body size of 100MB, though this does not mean you cannot upload larger files (see \"Size limitations\" below).\n\n        ### Single file\n        Send the POST request with `Blob`/`File` data as the request body.\n\n        ### Multiple files\n        Send the POST request as `FormData` with the header `Content-Type: multipart/form-data` set. Each part should have a `Content-Disposition` header to specify \"name\" (which must be \"file\") and \"filename\". e.g.\n\n        ```\n        ------WebKitFormBoundary5peilISl2YOOweQy\n        Content-Disposition: form-data; name=\"file\"; filename=\"image.png\"\n        Content-Type: image/png\n\n        \u003cdata\u003e\n        ------WebKitFormBoundary5peilISl2YOOweQy--\n        ```\n\n        ### Content Addressed Archive (CAR) files\n        You can also upload a CAR file, by setting the request body as a single CAR Blob/File object and providing the request header `Content-Type: application/car`\n        Providing a CAR file allows you to pre-compute the root CID for 1 or more files, ensures that NFT.Storage will store and provide your assets with the same CID.\n\n        ### Size limitations\n        Each request to the upload endpoint is limited to a total request body size of 100MB.\n        However, you can upload files larger than 100MB by packing them into a CAR file and splitting the CAR\n        into chunks of less than 100MB. This strategy is used by the JavaScript client library to support uploads of large files.\n\n        The simplest method of splitting CAR files is with the [carbites cli tool](https://github.com/nftstorage/carbites):\n\n        ```\n        npm i -g carbites-cli\n\n        # Split a big CAR into many smaller CARs\n        carbites split big.car --size 100MB --strategy treewalk\n        ```\n\n        Note that you MUST use the `treewalk` strategy, so that all the chunked CARs have the same root CID.\n        Once all the CAR chunks have been uploaded, the CARs will be combined, made available via IPFS,\n        and queued for storage on Filecoin.\n\n        For more about working with CARs, see https://docs.web3.storage/how-tos/work-with-car-files\n\n        ### Rate limits\n\n        This API imposes rate limits to ensure quality of service. You may receive a 429 \"Too many requests\" error if you make more than 30 requests with the same API token within a ten second window. Upon receiving a response with a 429 status, clients should retry the failed request after a small delay. To avoid 429 responses, you may wish to implement client-side request throttling to stay within the limits (note: the JS client automatically does this).\n\n      operationId: upload\n      parameters:\n        - in: header\n          name: x-agent-did\n          description: DID that issued / signed UCAN authorization token (required if UCAN token is used)\n          schema:\n            type: string\n            format: DID\n            required: false\n      requestBody:\n        required: true\n        content:\n          image/*:\n            schema:\n              type: string\n              format: binary\n          application/car:\n            schema:\n              type: string\n              format: binary\n          multipart/form-data:\n            schema:\n              type: object\n              properties:\n                file:\n                  type: array\n                  items:\n                    type: string\n                    format: binary\n          '*/*':\n            schema:\n              type: string\n              format: binary\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                $ref: '#/components/schemas/UploadResponse'\n        '400':\n          $ref: '#/components/responses/badRequest'\n        '401':\n          $ref: '#/components/responses/unauthorized'\n        '403':\n          $ref: '#/components/responses/forbidden'\n        '500':\n          $ref: '#/components/responses/internalServerError'\n  /:\n    get:\n      tags:\n        - NFT Storage\n      summary: List all stored files\n      operationId: list\n      parameters:\n        - $ref: '#/components/parameters/before'\n        - $ref: '#/components/parameters/limit'\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                $ref: '#/components/schemas/ListResponse'\n        '401':\n          $ref: '#/components/responses/unauthorized'\n        '403':\n          $ref: '#/components/responses/forbidden'\n        '500':\n          $ref: '#/components/responses/internalServerError'\n  /{cid}:\n    get:\n      tags:\n        - NFT Storage\n      summary: Get information for the stored file CID\n      description: Includes the IPFS pinning state and the Filecoin deal state.\n      operationId: status\n      parameters:\n        - name: cid\n          in: path\n          description: CID for the NFT\n          required: true\n          schema:\n            $ref: '#/components/schemas/CID'\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                $ref: '#/components/schemas/GetResponse'\n        '401':\n          $ref: '#/components/responses/unauthorized'\n        '403':\n          $ref: '#/components/responses/forbidden'\n        '500':\n          $ref: '#/components/responses/internalServerError'\n    delete:\n      tags:\n        - NFT Storage\n      summary: Stop storing the content with the passed CID\n      description: |\n        Stop storing the content with the passed CID on nft.storage.\n        - Unpin the item from the underlying IPFS pinning service.\n        - Cease renewals for expired Filecoin deals involving the CID.  \n\n        ⚠️ This does not remove the content from the network.\n\n        - Does not terminate any established Filecoin deal.\n        - Does not remove the content from other IPFS nodes in the network that already cached or pinned the CID.  \n\n        Note: the content will remain available if another user has stored the CID with nft.storage.\n      operationId: delete\n      parameters:\n        - name: cid\n          in: path\n          description: CID for the NFT\n          required: true\n          schema:\n            $ref: '#/components/schemas/CID'\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                $ref: '#/components/schemas/DeleteResponse'\n        '401':\n          $ref: '#/components/responses/unauthorized'\n        '403':\n          $ref: '#/components/responses/forbidden'\n        '500':\n          $ref: '#/components/responses/internalServerError'\n  /check/{cid}:\n    get:\n      tags:\n        - NFT Storage\n      summary: Check if a CID of an NFT is being stored by nft.storage.\n      description: Includes the IPFS pinning state and the Filecoin deal state.\n      operationId: check\n      security: []\n      parameters:\n        - name: cid\n          in: path\n          description: CID for the NFT\n          required: true\n          schema:\n            $ref: '#/components/schemas/CID'\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                $ref: '#/components/schemas/CheckResponse'\n        '404':\n          $ref: '#/components/responses/notFound'\n        '500':\n          $ref: '#/components/responses/internalServerError'\n  /did:\n    get:\n      tags:\n        - NFT Storage\n      summary: Get nft.storage DID\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                type: object\n                properties:\n                  ok:\n                    type: boolean\n                    default: true\n                  value:\n                    type: string\n                    example: did:key:z6MkgBRFJi7Ew2mzN7JtYN7nkq8M8qTHhLbsTEvV5j4ajWZS\n                    description: NFT Storage DID.\n  /user/did:\n    post:\n      tags:\n        - NFT Storage\n      summary: Register a DID for a user.\n      requestBody:\n        required: true\n        content:\n          'application/json':\n            schema:\n              type: object\n              properties:\n                did:\n                  type: string\n                  example: did:key:z6MkgBRFJi7Ew2mzN7JtYN7nkq8M8qTHhLbsTEvV5j4ajWZS\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                type: object\n                properties:\n                  ok:\n                    type: boolean\n                    default: true\n                  value:\n                    type: string\n                    example: did:key:z6MkgBRFJi7Ew2mzN7JtYN7nkq8M8qTHhLbsTEvV5j4ajWZS\n                    description: NFT Storage DID.\n        '400':\n          $ref: '#/components/responses/badRequest'\n        '500':\n          $ref: '#/components/responses/internalServerError'\n  /ucan/token:\n    post:\n      tags:\n        - NFT Storage\n      summary: Get a root UCAN.\n      description: |\n        This endpoint returns a root UCAN for nft.storage.\n        The UCAN will be valid for **two weeks** and has full capabilities. The JWT payload will looking similar to this:\n          \n        ```json\n        {\n          \"att\": [\n            {\n              \"with\": \"storage://did:key:z6MkheUPoHhYRS5LoHbbttpaTkkxvFFFUV5VPSziwTJmbb7D\",\n              \"can\": \"upload/*\"\n            }\n          ],\n          \"exp\": 1646668606,\n          \"iss\": \"did:key:z6MkheUPoHhYRS5LoHbbttpaTkkxvFFFUV5VPSziwTJmbb7D\",\n          \"prf\": []\n        }\n        ```\n\n        A valid UCAN can be used for authorization in this endpoint.\n\n      responses:\n        '200':\n          description: OK\n          content:\n            'application/json':\n              schema:\n                type: object\n                properties:\n                  ok:\n                    type: boolean\n                    default: true\n                  value:\n                    type: string\n                    example: eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCIsInVjdiI6IjAuOC4wIn0.eyJhdHQiOlt7IndpdGgiOiJzdG9yYWdlOi8vZGlkOmtleTp6Nk1raGVVUG9IaFlSUzVMb0hiYnR0cGFUa2t4dkZGRlVWNVZQU3ppd1RKbWJiN0QiLCJjYW4iOiJ1cGxvYWQvKiJ9XSwiZXhwIjoxNjQ2NjY4NjA2LCJpc3MiOiJkaWQ6a2V5Ono2TWtoZVVQb0hoWVJTNUxvSGJidHRwYVRra3h2RkZGVVY1VlBTeml3VEptYmI3RCIsInByZiI6W251bGxdfQ.JSJ01PY3d6a-vkN6clTvVi2AeZQorvRpyBYwYYMNEtZp6TXW0AhsUCP1ltL7hJjr0iWAp-B6dpOHsJS6tR1jCg\n                    description: Root UCAN.\n        '400':\n          $ref: '#/components/responses/didNotFoundError'\n        '500':\n          $ref: '#/components/responses/internalServerError'\ncomponents:\n  schemas:\n    NFT:\n      type: object\n      properties:\n        cid:\n          $ref: '#/components/schemas/CID'\n        size:\n          description: Size in bytes of the NFT data.\n          type: number\n          default: 132614\n        created:\n          $ref: '#/components/schemas/Date'\n        type:\n          type: string\n          example: image/jpeg\n          description: MIME type of the uploaded file or 'directory' when uploading multiple files.\n        scope:\n          description: Name of the JWT token used to create this NFT.\n          type: string\n          default: default\n        pin:\n          $ref: '#/components/schemas/Pin'\n        files:\n          $ref: '#/components/schemas/Files'\n        deals:\n          type: array\n          items:\n            $ref: '#/components/schemas/Deal'\n    Links:\n      type: object\n      properties:\n        ipfs:\n          type: string\n          example: ipfs://bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u\n        http:\n          type: string\n          example: http://bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u.ipfs.dweb.link\n        file:\n          type: array\n          items:\n            type: object\n            properties:\n              ipfs:\n                type: string\n                example: ipfs://bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u/image.jpg\n              http:\n                type: string\n                example: http://bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u.ipfs.dweb.link/image.jpg\n    Files:\n      description: Files in the directory (only if this NFT is a directory).\n      type: array\n      items:\n        type: object\n        properties:\n          name:\n            type: string\n            example: logo.jpg\n          type:\n            type: string\n            example: image/jpeg\n    Deal:\n      type: object\n      properties:\n        batchRootCid:\n          type: string\n          example: bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u\n        lastChange:\n          type: string\n          example: '2021-03-18T11:46:50.000Z'\n          description: 'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: YYYY-MM-DDTHH:MM:SSZ.'\n        miner:\n          description: Miner ID\n          type: string\n          example: f05678\n        network:\n          description: Filecoin network for this Deal\n          type: string\n          enum:\n            - nerpanet\n            - mainnet\n        pieceCid:\n          description: Piece CID string\n          type: string\n          example: bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u\n        status:\n          description: Deal status\n          type: string\n          enum:\n            - queued\n            - proposing\n            - accepted\n            - failed\n            - active\n            - published\n            - terminated\n        statusText:\n          type: string\n          example: miner rejected my data\n          description: Deal status description.\n        chainDealID:\n          type: number\n          example: 138\n          description: Identifier for the deal stored on chain.\n        dealActivation:\n          type: string\n          example: '2021-03-18T11:46:50.000Z'\n          description: 'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: YYYY-MM-DDTHH:MM:SSZ.'\n        dealExpiration:\n          type: string\n          example: '2021-03-18T11:46:50.000Z'\n          description: 'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: YYYY-MM-DDTHH:MM:SSZ.'\n      required:\n        - status\n        - lastChange\n    Date:\n      type: string\n      format: date-time\n      example: '2021-03-12T17:03:07.787Z'\n      description: 'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: YYYY-MM-DDTHH:MM:SSZ.'\n    CID:\n      type: string\n      example: bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u\n      description: Self-describing content-addressed identifiers for distributed systems. Check [spec](https://github.com/multiformats/cid) for more info.\n    PinStatus:\n      type: string\n      enum:\n        - queued\n        - pinning\n        - pinned\n        - failed\n    Pin:\n      type: object\n      properties:\n        cid:\n          $ref: '#/components/schemas/CID'\n        name:\n          type: string\n          example: pin name\n        meta:\n          type: object\n        status:\n          $ref: '#/components/schemas/PinStatus'\n        created:\n          $ref: '#/components/schemas/Date'\n        size:\n          type: number\n          example: 132614\n    UploadResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: true\n        value:\n          $ref: '#/components/schemas/NFT'\n    ListResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: true\n        value:\n          type: array\n          items:\n            $ref: '#/components/schemas/NFT'\n    GetResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: true\n        value:\n          type: object\n          $ref: '#/components/schemas/NFT'\n    CheckResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: true\n        value:\n          type: object\n          properties:\n            cid:\n              $ref: '#/components/schemas/CID'\n            pin:\n              $ref: '#/components/schemas/Pin'\n            deals:\n              type: array\n              items:\n                $ref: '#/components/schemas/Deal'\n    DeleteResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n    ErrorResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: false\n        error:\n          type: object\n          properties:\n            name:\n              type: string\n            message:\n              type: string\n    UnauthorizedErrorResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: false\n        error:\n          type: object\n          properties:\n            name:\n              type: string\n              default: HTTP Error\n            message:\n              type: string\n              default: Unauthorized\n    ForbiddenErrorResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: false\n        error:\n          type: object\n          properties:\n            name:\n              type: string\n              default: HTTP Error\n            message:\n              type: string\n              enum: [Token is not valid, Session expired]\n    DidNotFoundErrorResponse:\n      type: object\n      properties:\n        ok:\n          type: boolean\n          default: false\n        error:\n          type: object\n          properties:\n            name:\n              type: string\n              default: DIDNotFound\n            message:\n              type: string\n              default: User does not have a DID registered.\n  securitySchemes:\n    bearerAuth:\n      description: |\n        The NFT Storage API uses *Bearer Tokens* to authenticate requests. You can view and manage your tokens in the [NFT Storage Dashboard](https://nft.storage).   \n\n        Your tokens carry many privileges, so be sure to keep them secure! Do not share your *secret tokens* in publicly accessible areas such as GitHub, client-side code, and so forth.   \n\n        **Bearer authentication** (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens. The name “Bearer authentication” can be understood as “give access to the bearer of this token.” The bearer token is a cryptic string, usually generated by the server in response to a login request. The client must send this token in the Authorization header when making requests to protected resources:\n\n        ```js\n        Authorization: Bearer \u003ctoken\u003e\n        ```\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n  responses:\n    unauthorized:\n      description: Unauthorized\n      content:\n        'application/json':\n          schema:\n            $ref: '#/components/schemas/UnauthorizedErrorResponse'\n    forbidden:\n      description: Forbidden\n      content:\n        'application/json':\n          schema:\n            $ref: '#/components/schemas/ForbiddenErrorResponse'\n    notFound:\n      description: Not Found\n      content:\n        'application/json':\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n    internalServerError:\n      description: Internal Server Error\n      content:\n        'application/json':\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n    badRequest:\n      description: Bad Request\n      content:\n        'application/json':\n          schema:\n            $ref: '#/components/schemas/ErrorResponse'\n    didNotFoundError:\n      description: Bad Request\n      content:\n        'application/json':\n          schema:\n            $ref: '#/components/schemas/DidNotFoundErrorResponse'\n  parameters:\n    before:\n      description: Return results created before provided timestamp\n      name: before\n      in: query\n      required: false\n      schema:\n        type: string\n        format: date-time # RFC 3339, section 5.6\n      example: '2020-07-27T17:32:28Z'\n    limit:\n      description: Max records to return\n      name: limit\n      in: query\n      required: false\n      schema:\n        type: integer\n        format: int32\n        minimum: 1\n        maximum: 1000\n        default: 10\nsecurity:\n  - bearerAuth: []\n",
			"canonicalURL": "/github.com/nftstorage/nft.storage@8407848e4db11608eb8e77c95f40f535ae7dcf1c/-/blob/packages/website/public/schema.yml",
			"externalURLs": [
				{
					"url": "https://github.com/nftstorage/nft.storage/blob/8407848e4db11608eb8e77c95f40f535ae7dcf1c/packages/website/public/schema.yml",
					"serviceKind": "GITHUB"
				}
			]
		}
	},
	"Error": "unmarshal: yaml: unmarshal errors:\n  yaml: line 1: cannot unmarshal !!bool `false` into []string"
}