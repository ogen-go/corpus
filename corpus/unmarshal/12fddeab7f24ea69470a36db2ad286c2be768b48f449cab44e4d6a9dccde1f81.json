{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/osmosis-labs/docs"
		},
		"file": {
			"name": "IBCGO.yaml",
			"size": 0,
			"path": "static/api/IBCGO.yaml",
			"byteSize": 640425,
			"content": "openapi: 3.0.1\ninfo:\n  title: IBC-GO - gRPC Gateway docs\n  description: A REST interface for state queries\n  version: 1.0.0\nservers:\n- url: /\npaths:\n  /ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address:\n    get:\n      tags:\n      - Query\n      summary: EscrowAddress returns the escrow address for a particular port and\n        channel id.\n      operationId: EscrowAddress\n      parameters:\n      - name: channel_id\n        in: path\n        description: unique channel identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: unique port identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  escrow_address:\n                    title: the escrow account address\n                    type: string\n                description: QueryEscrowAddressResponse is the response type of the\n                  EscrowAddress RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/transfer/v1/denom_hashes/{trace}:\n    get:\n      tags:\n      - Query\n      summary: DenomHash queries a denomination hash information.\n      operationId: DenomHash\n      parameters:\n      - name: trace\n        in: path\n        description: The denomination trace ([port_id]/[channel_id])+/[denom]\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  hash:\n                    type: string\n                    description: hash (in hex format) of the denomination trace information.\n                description: |-\n                  QueryDenomHashResponse is the response type for the Query/DenomHash RPC\n                  method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/transfer/v1/denom_traces:\n    get:\n      tags:\n      - Query\n      summary: DenomTraces queries all denomination traces.\n      operationId: DenomTraces\n      parameters:\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  denom_traces:\n                    type: array\n                    description: denom_traces returns all denominations trace information.\n                    items:\n                      type: object\n                      properties:\n                        path:\n                          type: string\n                          description: |-\n                            path defines the chain of port/channel identifiers used for tracing the\n                            source of the fungible token.\n                        base_denom:\n                          type: string\n                          description: base denomination of the relayed fungible token.\n                      description: |-\n                        DenomTrace contains the base denomination for ICS20 fungible tokens and the\n                        source tracing information path.\n                  pagination:\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: pagination defines the pagination in the response.\n                description: |-\n                  QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\n                  method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/transfer/v1/denom_traces/{hash}:\n    get:\n      tags:\n      - Query\n      summary: DenomTrace queries a denomination trace information.\n      operationId: DenomTrace\n      parameters:\n      - name: hash\n        in: path\n        description: hash (in hex format) or denom (full denom with ibc prefix) of\n          the denomination trace information.\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  denom_trace:\n                    type: object\n                    properties:\n                      path:\n                        type: string\n                        description: |-\n                          path defines the chain of port/channel identifiers used for tracing the\n                          source of the fungible token.\n                      base_denom:\n                        type: string\n                        description: base denomination of the relayed fungible token.\n                    description: |-\n                      DenomTrace contains the base denomination for ICS20 fungible tokens and the\n                      source tracing information path.\n                description: |-\n                  QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\n                  method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/transfer/v1/params:\n    get:\n      tags:\n      - Query\n      summary: Params queries all parameters of the ibc-transfer module.\n      operationId: TransferParams\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  params:\n                    type: object\n                    properties:\n                      send_enabled:\n                        type: boolean\n                        description: |-\n                          send_enabled enables or disables all cross-chain token transfers from this\n                          chain.\n                        format: boolean\n                      receive_enabled:\n                        type: boolean\n                        description: |-\n                          receive_enabled enables or disables all cross-chain token transfers to this\n                          chain.\n                        format: boolean\n                    description: params defines the parameters of the module.\n                description: QueryParamsResponse is the response type for the Query/Params\n                  RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/interchain_accounts/controller/v1/owners/{owner}/connections/{connection_id}:\n    get:\n      tags:\n      - Query\n      summary: InterchainAccount returns the interchain account address for a given\n        owner address on a given connection\n      operationId: InterchainAccount\n      parameters:\n      - name: owner\n        in: path\n        required: true\n        schema:\n          type: string\n      - name: connection_id\n        in: path\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  address:\n                    type: string\n                description: QueryInterchainAccountResponse the response type for\n                  the Query/InterchainAccount RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/interchain_accounts/controller/v1/params:\n    get:\n      tags:\n      - Query\n      summary: Params queries all parameters of the ICA controller submodule.\n      operationId: InterchainAccountsControllerParams\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  params:\n                    type: object\n                    properties:\n                      controller_enabled:\n                        type: boolean\n                        description: controller_enabled enables or disables the controller\n                          submodule.\n                        format: boolean\n                    description: params defines the parameters of the module.\n                description: QueryParamsResponse is the response type for the Query/Params\n                  RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/interchain_accounts/host/v1/params:\n    get:\n      tags:\n      - Query\n      summary: Params queries all parameters of the ICA host submodule.\n      operationId: InterchainAccountsHostParams\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  params:\n                    type: object\n                    properties:\n                      host_enabled:\n                        type: boolean\n                        description: host_enabled enables or disables the host submodule.\n                        format: boolean\n                      allow_messages:\n                        type: array\n                        description: allow_messages defines a list of sdk message\n                          typeURLs allowed to be executed on a host chain.\n                        items:\n                          type: string\n                    description: params defines the parameters of the module.\n                description: QueryParamsResponse is the response type for the Query/Params\n                  RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          format: byte\n  /ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/fee_enabled:\n    get:\n      tags:\n      - Query\n      summary: FeeEnabledChannel returns true if the provided port and channel identifiers\n        belong to a fee enabled channel\n      operationId: FeeEnabledChannel\n      parameters:\n      - name: channel_id\n        in: path\n        description: unique channel identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: unique port identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryFeeEnabledChannelResponse defines the response type for\n                  the FeeEnabledChannel rpc\n                type: object\n                properties:\n                  fee_enabled:\n                    title: boolean flag representing the fee enabled channel status\n                    type: boolean\n                    format: boolean\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/channels/{channel_id}/ports/{port_id}/incentivized_packets:\n    get:\n      tags:\n      - Query\n      summary: Gets all incentivized packets for a specific channel\n      operationId: IncentivizedPacketsForChannel\n      parameters:\n      - name: channel_id\n        in: path\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        required: true\n        schema:\n          type: string\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      - name: query_height\n        in: query\n        description: Height to query at.\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryIncentivizedPacketsResponse defines the response type\n                  for the incentivized packets RPC\n                type: object\n                properties:\n                  incentivized_packets:\n                    title: Map of all incentivized_packets\n                    type: array\n                    items:\n                      title: IdentifiedPacketFees contains a list of type PacketFee\n                        and associated PacketId\n                      type: object\n                      properties:\n                        packet_id:\n                          title: unique packet identifier comprised of the channel\n                            ID, port ID and sequence\n                          type: object\n                          properties:\n                            port_id:\n                              title: channel port identifier\n                              type: string\n                            channel_id:\n                              title: channel unique identifier\n                              type: string\n                            sequence:\n                              title: packet sequence\n                              type: string\n                              format: uint64\n                        packet_fees:\n                          title: list of packet fees\n                          type: array\n                          items:\n                            title: PacketFee contains ICS29 relayer fees, refund address\n                              and optional list of permitted relayers\n                            type: object\n                            properties:\n                              fee:\n                                title: fee encapsulates the recv, ack and timeout\n                                  fees associated with an IBC packet\n                                type: object\n                                properties:\n                                  recv_fee:\n                                    title: the packet receive fee\n                                    type: array\n                                    items:\n                                      type: object\n                                      properties:\n                                        denom:\n                                          type: string\n                                        amount:\n                                          type: string\n                                      description: |-\n                                        Coin defines a token with a denomination and an amount.\n\n                                        NOTE: The amount field is an Int which implements the custom method\n                                        signatures required by gogoproto.\n                                  ack_fee:\n                                    title: the packet acknowledgement fee\n                                    type: array\n                                    items:\n                                      type: object\n                                      properties:\n                                        denom:\n                                          type: string\n                                        amount:\n                                          type: string\n                                      description: |-\n                                        Coin defines a token with a denomination and an amount.\n\n                                        NOTE: The amount field is an Int which implements the custom method\n                                        signatures required by gogoproto.\n                                  timeout_fee:\n                                    title: the packet timeout fee\n                                    type: array\n                                    items:\n                                      type: object\n                                      properties:\n                                        denom:\n                                          type: string\n                                        amount:\n                                          type: string\n                                      description: |-\n                                        Coin defines a token with a denomination and an amount.\n\n                                        NOTE: The amount field is an Int which implements the custom method\n                                        signatures required by gogoproto.\n                              refund_address:\n                                title: the refund address for unspent fees\n                                type: string\n                              relayers:\n                                title: optional list of relayers permitted to receive\n                                  fees\n                                type: array\n                                items:\n                                  type: string\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/counterparty_payee:\n    get:\n      tags:\n      - Query\n      summary: CounterpartyPayee returns the registered counterparty payee for forward\n        relaying\n      operationId: CounterpartyPayee\n      parameters:\n      - name: channel_id\n        in: path\n        description: unique channel identifier\n        required: true\n        schema:\n          type: string\n      - name: relayer\n        in: path\n        description: the relayer address to which the counterparty is registered\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryCounterpartyPayeeResponse defines the response type for\n                  the CounterpartyPayee rpc\n                type: object\n                properties:\n                  counterparty_payee:\n                    title: the counterparty payee address used to compensate forward\n                      relaying\n                    type: string\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/channels/{channel_id}/relayers/{relayer}/payee:\n    get:\n      tags:\n      - Query\n      summary: Payee returns the registered payee address for a specific channel given\n        the relayer address\n      operationId: Payee\n      parameters:\n      - name: channel_id\n        in: path\n        description: unique channel identifier\n        required: true\n        schema:\n          type: string\n      - name: relayer\n        in: path\n        description: the relayer address to which the distribution address is registered\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryPayeeResponse defines the response type for the Payee\n                  rpc\n                type: object\n                properties:\n                  payee_address:\n                    title: the payee address to which packet fees are paid out\n                    type: string\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/incentivized_packet:\n    get:\n      tags:\n      - Query\n      summary: IncentivizedPacket returns all packet fees for a packet given its identifier\n      operationId: IncentivizedPacket\n      parameters:\n      - name: packet_id.channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.port_id\n        in: path\n        description: channel port identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.sequence\n        in: path\n        description: packet sequence\n        required: true\n        schema:\n          type: string\n          format: uint64\n      - name: query_height\n        in: query\n        description: block height at which to query.\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryIncentivizedPacketsResponse defines the response type\n                  for the IncentivizedPacket rpc\n                type: object\n                properties:\n                  incentivized_packet:\n                    title: IdentifiedPacketFees contains a list of type PacketFee\n                      and associated PacketId\n                    type: object\n                    properties:\n                      packet_id:\n                        title: unique packet identifier comprised of the channel ID,\n                          port ID and sequence\n                        type: object\n                        properties:\n                          port_id:\n                            title: channel port identifier\n                            type: string\n                          channel_id:\n                            title: channel unique identifier\n                            type: string\n                          sequence:\n                            title: packet sequence\n                            type: string\n                            format: uint64\n                      packet_fees:\n                        title: list of packet fees\n                        type: array\n                        items:\n                          title: PacketFee contains ICS29 relayer fees, refund address\n                            and optional list of permitted relayers\n                          type: object\n                          properties:\n                            fee:\n                              title: fee encapsulates the recv, ack and timeout fees\n                                associated with an IBC packet\n                              type: object\n                              properties:\n                                recv_fee:\n                                  title: the packet receive fee\n                                  type: array\n                                  items:\n                                    type: object\n                                    properties:\n                                      denom:\n                                        type: string\n                                      amount:\n                                        type: string\n                                    description: |-\n                                      Coin defines a token with a denomination and an amount.\n\n                                      NOTE: The amount field is an Int which implements the custom method\n                                      signatures required by gogoproto.\n                                ack_fee:\n                                  title: the packet acknowledgement fee\n                                  type: array\n                                  items:\n                                    type: object\n                                    properties:\n                                      denom:\n                                        type: string\n                                      amount:\n                                        type: string\n                                    description: |-\n                                      Coin defines a token with a denomination and an amount.\n\n                                      NOTE: The amount field is an Int which implements the custom method\n                                      signatures required by gogoproto.\n                                timeout_fee:\n                                  title: the packet timeout fee\n                                  type: array\n                                  items:\n                                    type: object\n                                    properties:\n                                      denom:\n                                        type: string\n                                      amount:\n                                        type: string\n                                    description: |-\n                                      Coin defines a token with a denomination and an amount.\n\n                                      NOTE: The amount field is an Int which implements the custom method\n                                      signatures required by gogoproto.\n                            refund_address:\n                              title: the refund address for unspent fees\n                              type: string\n                            relayers:\n                              title: optional list of relayers permitted to receive\n                                fees\n                              type: array\n                              items:\n                                type: string\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_ack_fees:\n    get:\n      tags:\n      - Query\n      summary: TotalAckFees returns the total acknowledgement fees for a packet given\n        its identifier\n      operationId: TotalAckFees\n      parameters:\n      - name: packet_id.channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.port_id\n        in: path\n        description: channel port identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.sequence\n        in: path\n        description: packet sequence\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryTotalAckFeesResponse defines the response type for the\n                  TotalAckFees rpc\n                type: object\n                properties:\n                  ack_fees:\n                    title: the total packet acknowledgement fees\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        denom:\n                          type: string\n                        amount:\n                          type: string\n                      description: |-\n                        Coin defines a token with a denomination and an amount.\n\n                        NOTE: The amount field is an Int which implements the custom method\n                        signatures required by gogoproto.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_recv_fees:\n    get:\n      tags:\n      - Query\n      summary: TotalRecvFees returns the total receive fees for a packet given its\n        identifier\n      operationId: TotalRecvFees\n      parameters:\n      - name: packet_id.channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.port_id\n        in: path\n        description: channel port identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.sequence\n        in: path\n        description: packet sequence\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryTotalRecvFeesResponse defines the response type for the\n                  TotalRecvFees rpc\n                type: object\n                properties:\n                  recv_fees:\n                    title: the total packet receive fees\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        denom:\n                          type: string\n                        amount:\n                          type: string\n                      description: |-\n                        Coin defines a token with a denomination and an amount.\n\n                        NOTE: The amount field is an Int which implements the custom method\n                        signatures required by gogoproto.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/channels/{packet_id.channel_id}/ports/{packet_id.port_id}/sequences/{packet_id.sequence}/total_timeout_fees:\n    get:\n      tags:\n      - Query\n      summary: TotalTimeoutFees returns the total timeout fees for a packet given\n        its identifier\n      operationId: TotalTimeoutFees\n      parameters:\n      - name: packet_id.channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.port_id\n        in: path\n        description: channel port identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_id.sequence\n        in: path\n        description: packet sequence\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryTotalTimeoutFeesResponse defines the response type for\n                  the TotalTimeoutFees rpc\n                type: object\n                properties:\n                  timeout_fees:\n                    title: the total packet timeout fees\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        denom:\n                          type: string\n                        amount:\n                          type: string\n                      description: |-\n                        Coin defines a token with a denomination and an amount.\n\n                        NOTE: The amount field is an Int which implements the custom method\n                        signatures required by gogoproto.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/fee_enabled:\n    get:\n      tags:\n      - Query\n      summary: FeeEnabledChannels returns a list of all fee enabled channels\n      operationId: FeeEnabledChannels\n      parameters:\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      - name: query_height\n        in: query\n        description: block height at which to query.\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryFeeEnabledChannelsResponse defines the response type for\n                  the FeeEnabledChannels rpc\n                type: object\n                properties:\n                  fee_enabled_channels:\n                    title: list of fee enabled channels\n                    type: array\n                    items:\n                      title: FeeEnabledChannel contains the PortID \u0026 ChannelID for\n                        a fee enabled channel\n                      type: object\n                      properties:\n                        port_id:\n                          title: unique port identifier\n                          type: string\n                        channel_id:\n                          title: unique channel identifier\n                          type: string\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/apps/fee/v1/incentivized_packets:\n    get:\n      tags:\n      - Query\n      summary: IncentivizedPackets returns all incentivized packets and their associated\n        fees\n      operationId: IncentivizedPackets\n      parameters:\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      - name: query_height\n        in: query\n        description: block height at which to query.\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: QueryIncentivizedPacketsResponse defines the response type\n                  for the IncentivizedPackets rpc\n                type: object\n                properties:\n                  incentivized_packets:\n                    title: list of identified fees for incentivized packets\n                    type: array\n                    items:\n                      title: IdentifiedPacketFees contains a list of type PacketFee\n                        and associated PacketId\n                      type: object\n                      properties:\n                        packet_id:\n                          title: unique packet identifier comprised of the channel\n                            ID, port ID and sequence\n                          type: object\n                          properties:\n                            port_id:\n                              title: channel port identifier\n                              type: string\n                            channel_id:\n                              title: channel unique identifier\n                              type: string\n                            sequence:\n                              title: packet sequence\n                              type: string\n                              format: uint64\n                        packet_fees:\n                          title: list of packet fees\n                          type: array\n                          items:\n                            title: PacketFee contains ICS29 relayer fees, refund address\n                              and optional list of permitted relayers\n                            type: object\n                            properties:\n                              fee:\n                                title: fee encapsulates the recv, ack and timeout\n                                  fees associated with an IBC packet\n                                type: object\n                                properties:\n                                  recv_fee:\n                                    title: the packet receive fee\n                                    type: array\n                                    items:\n                                      type: object\n                                      properties:\n                                        denom:\n                                          type: string\n                                        amount:\n                                          type: string\n                                      description: |-\n                                        Coin defines a token with a denomination and an amount.\n\n                                        NOTE: The amount field is an Int which implements the custom method\n                                        signatures required by gogoproto.\n                                  ack_fee:\n                                    title: the packet acknowledgement fee\n                                    type: array\n                                    items:\n                                      type: object\n                                      properties:\n                                        denom:\n                                          type: string\n                                        amount:\n                                          type: string\n                                      description: |-\n                                        Coin defines a token with a denomination and an amount.\n\n                                        NOTE: The amount field is an Int which implements the custom method\n                                        signatures required by gogoproto.\n                                  timeout_fee:\n                                    title: the packet timeout fee\n                                    type: array\n                                    items:\n                                      type: object\n                                      properties:\n                                        denom:\n                                          type: string\n                                        amount:\n                                          type: string\n                                      description: |-\n                                        Coin defines a token with a denomination and an amount.\n\n                                        NOTE: The amount field is an Int which implements the custom method\n                                        signatures required by gogoproto.\n                              refund_address:\n                                title: the refund address for unspent fees\n                                type: string\n                              relayers:\n                                title: optional list of relayers permitted to receive\n                                  fees\n                                type: array\n                                items:\n                                  type: string\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/client/v1/params:\n    get:\n      tags:\n      - Query\n      summary: ClientParams queries all parameters of the ibc client.\n      operationId: ClientParams\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  params:\n                    type: object\n                    properties:\n                      allowed_clients:\n                        type: array\n                        description: allowed_clients defines the list of allowed client\n                          state types.\n                        items:\n                          type: string\n                    description: params defines the parameters of the module.\n                description: |-\n                  QueryClientParamsResponse is the response type for the Query/ClientParams RPC\n                  method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/client_states:\n    get:\n      tags:\n      - Query\n      summary: ClientStates queries all the IBC light clients of a chain.\n      operationId: ClientStates\n      parameters:\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  client_states:\n                    type: array\n                    description: list of stored ClientStates of the chain.\n                    items:\n                      type: object\n                      properties:\n                        client_id:\n                          title: client identifier\n                          type: string\n                        client_state:\n                          title: client state\n                          type: object\n                          properties:\n                            type_url:\n                              type: string\n                              description: |-\n                                A URL/resource name that uniquely identifies the type of the serialized\n                                protocol buffer message. This string must contain at least\n                                one \"/\" character. The last segment of the URL's path must represent\n                                the fully qualified name of the type (as in\n                                `path/google.protobuf.Duration`). The name should be in a canonical form\n                                (e.g., leading \".\" is not accepted).\n\n                                In practice, teams usually precompile into the binary all types that they\n                                expect it to use in the context of Any. However, for URLs which use the\n                                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                                server that maps type URLs to message definitions as follows:\n\n                                * If no scheme is provided, `https` is assumed.\n                                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                                  value in binary format, or produce an error.\n                                * Applications are allowed to cache lookup results based on the\n                                  URL, or have them precompiled into a binary to avoid any\n                                  lookup. Therefore, binary compatibility needs to be preserved\n                                  on changes to types. (Use versioned type names to manage\n                                  breaking changes.)\n\n                                Note: this functionality is not currently available in the official\n                                protobuf release, and it is not used for type URLs beginning with\n                                type.googleapis.com.\n\n                                Schemes other than `http`, `https` (or the empty scheme) might be\n                                used with implementation specific semantics.\n                            value:\n                              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                              type: string\n                              description: Must be a valid serialized protocol buffer\n                                of the above specified type.\n                              format: byte\n                          description: |-\n                            `Any` contains an arbitrary serialized protocol buffer message along with a\n                            URL that describes the type of the serialized message.\n\n                            Protobuf library provides support to pack/unpack Any values in the form\n                            of utility functions or additional generated methods of the Any type.\n\n                            Example 1: Pack and unpack a message in C++.\n\n                                Foo foo = ...;\n                                Any any;\n                                any.PackFrom(foo);\n                                ...\n                                if (any.UnpackTo(\u0026foo)) {\n                                  ...\n                                }\n\n                            Example 2: Pack and unpack a message in Java.\n\n                                Foo foo = ...;\n                                Any any = Any.pack(foo);\n                                ...\n                                if (any.is(Foo.class)) {\n                                  foo = any.unpack(Foo.class);\n                                }\n\n                             Example 3: Pack and unpack a message in Python.\n\n                                foo = Foo(...)\n                                any = Any()\n                                any.Pack(foo)\n                                ...\n                                if any.Is(Foo.DESCRIPTOR):\n                                  any.Unpack(foo)\n                                  ...\n\n                             Example 4: Pack and unpack a message in Go\n\n                                 foo := \u0026pb.Foo{...}\n                                 any, err := ptypes.MarshalAny(foo)\n                                 ...\n                                 foo := \u0026pb.Foo{}\n                                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                                   ...\n                                 }\n\n                            The pack methods provided by protobuf library will by default use\n                            'type.googleapis.com/full.type.name' as the type URL and the unpack\n                            methods only use the fully qualified type name after the last '/'\n                            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                            name \"y.z\".\n\n\n                            JSON\n                            ====\n                            The JSON representation of an `Any` value uses the regular\n                            representation of the deserialized, embedded message, with an\n                            additional field `@type` which contains the type URL. Example:\n\n                                package google.profile;\n                                message Person {\n                                  string first_name = 1;\n                                  string last_name = 2;\n                                }\n\n                                {\n                                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                                  \"firstName\": \u003cstring\u003e,\n                                  \"lastName\": \u003cstring\u003e\n                                }\n\n                            If the embedded message type is well-known and has a custom JSON\n                            representation, that representation will be embedded adding a field\n                            `value` which holds the custom JSON in addition to the `@type`\n                            field. Example (for message [google.protobuf.Duration][]):\n\n                                {\n                                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                                  \"value\": \"1.212s\"\n                                }\n                      description: |-\n                        IdentifiedClientState defines a client state with an additional client\n                        identifier field.\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n                description: |-\n                  QueryClientStatesResponse is the response type for the Query/ClientStates RPC\n                  method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/client_states/{client_id}:\n    get:\n      tags:\n      - Query\n      summary: ClientState queries an IBC light client.\n      operationId: ClientState\n      parameters:\n      - name: client_id\n        in: path\n        description: client state unique identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  client_state:\n                    title: client state associated with the request identifier\n                    type: object\n                    properties:\n                      type_url:\n                        type: string\n                        description: |-\n                          A URL/resource name that uniquely identifies the type of the serialized\n                          protocol buffer message. This string must contain at least\n                          one \"/\" character. The last segment of the URL's path must represent\n                          the fully qualified name of the type (as in\n                          `path/google.protobuf.Duration`). The name should be in a canonical form\n                          (e.g., leading \".\" is not accepted).\n\n                          In practice, teams usually precompile into the binary all types that they\n                          expect it to use in the context of Any. However, for URLs which use the\n                          scheme `http`, `https`, or no scheme, one can optionally set up a type\n                          server that maps type URLs to message definitions as follows:\n\n                          * If no scheme is provided, `https` is assumed.\n                          * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                            value in binary format, or produce an error.\n                          * Applications are allowed to cache lookup results based on the\n                            URL, or have them precompiled into a binary to avoid any\n                            lookup. Therefore, binary compatibility needs to be preserved\n                            on changes to types. (Use versioned type names to manage\n                            breaking changes.)\n\n                          Note: this functionality is not currently available in the official\n                          protobuf release, and it is not used for type URLs beginning with\n                          type.googleapis.com.\n\n                          Schemes other than `http`, `https` (or the empty scheme) might be\n                          used with implementation specific semantics.\n                      value:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: Must be a valid serialized protocol buffer of\n                          the above specified type.\n                        format: byte\n                    description: |-\n                      `Any` contains an arbitrary serialized protocol buffer message along with a\n                      URL that describes the type of the serialized message.\n\n                      Protobuf library provides support to pack/unpack Any values in the form\n                      of utility functions or additional generated methods of the Any type.\n\n                      Example 1: Pack and unpack a message in C++.\n\n                          Foo foo = ...;\n                          Any any;\n                          any.PackFrom(foo);\n                          ...\n                          if (any.UnpackTo(\u0026foo)) {\n                            ...\n                          }\n\n                      Example 2: Pack and unpack a message in Java.\n\n                          Foo foo = ...;\n                          Any any = Any.pack(foo);\n                          ...\n                          if (any.is(Foo.class)) {\n                            foo = any.unpack(Foo.class);\n                          }\n\n                       Example 3: Pack and unpack a message in Python.\n\n                          foo = Foo(...)\n                          any = Any()\n                          any.Pack(foo)\n                          ...\n                          if any.Is(Foo.DESCRIPTOR):\n                            any.Unpack(foo)\n                            ...\n\n                       Example 4: Pack and unpack a message in Go\n\n                           foo := \u0026pb.Foo{...}\n                           any, err := ptypes.MarshalAny(foo)\n                           ...\n                           foo := \u0026pb.Foo{}\n                           if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                             ...\n                           }\n\n                      The pack methods provided by protobuf library will by default use\n                      'type.googleapis.com/full.type.name' as the type URL and the unpack\n                      methods only use the fully qualified type name after the last '/'\n                      in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                      name \"y.z\".\n\n\n                      JSON\n                      ====\n                      The JSON representation of an `Any` value uses the regular\n                      representation of the deserialized, embedded message, with an\n                      additional field `@type` which contains the type URL. Example:\n\n                          package google.profile;\n                          message Person {\n                            string first_name = 1;\n                            string last_name = 2;\n                          }\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.profile.Person\",\n                            \"firstName\": \u003cstring\u003e,\n                            \"lastName\": \u003cstring\u003e\n                          }\n\n                      If the embedded message type is well-known and has a custom JSON\n                      representation, that representation will be embedded adding a field\n                      `value` which holds the custom JSON in addition to the `@type`\n                      field. Example (for message [google.protobuf.Duration][]):\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                            \"value\": \"1.212s\"\n                          }\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n                description: |-\n                  QueryClientStateResponse is the response type for the Query/ClientState RPC\n                  method. Besides the client state, it includes a proof and the height from\n                  which the proof was retrieved.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/client_status/{client_id}:\n    get:\n      tags:\n      - Query\n      summary: Status queries the status of an IBC client.\n      operationId: ClientStatus\n      parameters:\n      - name: client_id\n        in: path\n        description: client unique identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                description: |-\n                  QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\n                  method. It returns the current status of the IBC client.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/consensus_states/{client_id}:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ConsensusStates queries all the consensus state associated with a given\n        client.\n      operationId: ConsensusStates\n      parameters:\n      - name: client_id\n        in: path\n        description: client identifier\n        required: true\n        schema:\n          type: string\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryConsensusStatesResponse is the response type for the\n                  Query/ConsensusStates RPC method\n                type: object\n                properties:\n                  consensus_states:\n                    title: consensus states associated with the identifier\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        height:\n                          title: consensus state height\n                          type: object\n                          properties:\n                            revision_number:\n                              title: the revision that the client is currently on\n                              type: string\n                              format: uint64\n                            revision_height:\n                              title: the height within the given revision\n                              type: string\n                              format: uint64\n                          description: |-\n                            Normally the RevisionHeight is incremented at each height while keeping\n                            RevisionNumber the same. However some consensus algorithms may choose to\n                            reset the height in certain conditions e.g. hard forks, state-machine\n                            breaking changes In these cases, the RevisionNumber is incremented so that\n                            height continues to be monitonically increasing even as the RevisionHeight\n                            gets reset\n                        consensus_state:\n                          title: consensus state\n                          type: object\n                          properties:\n                            type_url:\n                              type: string\n                              description: |-\n                                A URL/resource name that uniquely identifies the type of the serialized\n                                protocol buffer message. This string must contain at least\n                                one \"/\" character. The last segment of the URL's path must represent\n                                the fully qualified name of the type (as in\n                                `path/google.protobuf.Duration`). The name should be in a canonical form\n                                (e.g., leading \".\" is not accepted).\n\n                                In practice, teams usually precompile into the binary all types that they\n                                expect it to use in the context of Any. However, for URLs which use the\n                                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                                server that maps type URLs to message definitions as follows:\n\n                                * If no scheme is provided, `https` is assumed.\n                                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                                  value in binary format, or produce an error.\n                                * Applications are allowed to cache lookup results based on the\n                                  URL, or have them precompiled into a binary to avoid any\n                                  lookup. Therefore, binary compatibility needs to be preserved\n                                  on changes to types. (Use versioned type names to manage\n                                  breaking changes.)\n\n                                Note: this functionality is not currently available in the official\n                                protobuf release, and it is not used for type URLs beginning with\n                                type.googleapis.com.\n\n                                Schemes other than `http`, `https` (or the empty scheme) might be\n                                used with implementation specific semantics.\n                            value:\n                              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                              type: string\n                              description: Must be a valid serialized protocol buffer\n                                of the above specified type.\n                              format: byte\n                          description: |-\n                            `Any` contains an arbitrary serialized protocol buffer message along with a\n                            URL that describes the type of the serialized message.\n\n                            Protobuf library provides support to pack/unpack Any values in the form\n                            of utility functions or additional generated methods of the Any type.\n\n                            Example 1: Pack and unpack a message in C++.\n\n                                Foo foo = ...;\n                                Any any;\n                                any.PackFrom(foo);\n                                ...\n                                if (any.UnpackTo(\u0026foo)) {\n                                  ...\n                                }\n\n                            Example 2: Pack and unpack a message in Java.\n\n                                Foo foo = ...;\n                                Any any = Any.pack(foo);\n                                ...\n                                if (any.is(Foo.class)) {\n                                  foo = any.unpack(Foo.class);\n                                }\n\n                             Example 3: Pack and unpack a message in Python.\n\n                                foo = Foo(...)\n                                any = Any()\n                                any.Pack(foo)\n                                ...\n                                if any.Is(Foo.DESCRIPTOR):\n                                  any.Unpack(foo)\n                                  ...\n\n                             Example 4: Pack and unpack a message in Go\n\n                                 foo := \u0026pb.Foo{...}\n                                 any, err := ptypes.MarshalAny(foo)\n                                 ...\n                                 foo := \u0026pb.Foo{}\n                                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                                   ...\n                                 }\n\n                            The pack methods provided by protobuf library will by default use\n                            'type.googleapis.com/full.type.name' as the type URL and the unpack\n                            methods only use the fully qualified type name after the last '/'\n                            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                            name \"y.z\".\n\n\n                            JSON\n                            ====\n                            The JSON representation of an `Any` value uses the regular\n                            representation of the deserialized, embedded message, with an\n                            additional field `@type` which contains the type URL. Example:\n\n                                package google.profile;\n                                message Person {\n                                  string first_name = 1;\n                                  string last_name = 2;\n                                }\n\n                                {\n                                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                                  \"firstName\": \u003cstring\u003e,\n                                  \"lastName\": \u003cstring\u003e\n                                }\n\n                            If the embedded message type is well-known and has a custom JSON\n                            representation, that representation will be embedded adding a field\n                            `value` which holds the custom JSON in addition to the `@type`\n                            field. Example (for message [google.protobuf.Duration][]):\n\n                                {\n                                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                                  \"value\": \"1.212s\"\n                                }\n                      description: |-\n                        ConsensusStateWithHeight defines a consensus state with an additional height\n                        field.\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/consensus_states/{client_id}/heights:\n    get:\n      tags:\n      - Query\n      summary: ConsensusStateHeights queries the height of every consensus states\n        associated with a given client.\n      operationId: ConsensusStateHeights\n      parameters:\n      - name: client_id\n        in: path\n        description: client identifier\n        required: true\n        schema:\n          type: string\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryConsensusStateHeightsResponse is the response type for the\n                  Query/ConsensusStateHeights RPC method\n                type: object\n                properties:\n                  consensus_state_heights:\n                    title: consensus state heights\n                    type: array\n                    items:\n                      title: |-\n                        Height is a monotonically increasing data type\n                        that can be compared against another Height for the purposes of updating and\n                        freezing clients\n                      type: object\n                      properties:\n                        revision_number:\n                          title: the revision that the client is currently on\n                          type: string\n                          format: uint64\n                        revision_height:\n                          title: the height within the given revision\n                          type: string\n                          format: uint64\n                      description: |-\n                        Normally the RevisionHeight is incremented at each height while keeping\n                        RevisionNumber the same. However some consensus algorithms may choose to\n                        reset the height in certain conditions e.g. hard forks, state-machine\n                        breaking changes In these cases, the RevisionNumber is incremented so that\n                        height continues to be monitonically increasing even as the RevisionHeight\n                        gets reset\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ConsensusState queries a consensus state associated with a client state at\n        a given height.\n      operationId: ConsensusState\n      parameters:\n      - name: client_id\n        in: path\n        description: client identifier\n        required: true\n        schema:\n          type: string\n      - name: revision_number\n        in: path\n        description: consensus state revision number\n        required: true\n        schema:\n          type: string\n          format: uint64\n      - name: revision_height\n        in: path\n        description: consensus state revision height\n        required: true\n        schema:\n          type: string\n          format: uint64\n      - name: latest_height\n        in: query\n        description: |-\n          latest_height overrrides the height field and queries the latest stored\n          ConsensusState.\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryConsensusStateResponse is the response type for the Query/ConsensusState\n                  RPC method\n                type: object\n                properties:\n                  consensus_state:\n                    title: consensus state associated with the client identifier at\n                      the given height\n                    type: object\n                    properties:\n                      type_url:\n                        type: string\n                        description: |-\n                          A URL/resource name that uniquely identifies the type of the serialized\n                          protocol buffer message. This string must contain at least\n                          one \"/\" character. The last segment of the URL's path must represent\n                          the fully qualified name of the type (as in\n                          `path/google.protobuf.Duration`). The name should be in a canonical form\n                          (e.g., leading \".\" is not accepted).\n\n                          In practice, teams usually precompile into the binary all types that they\n                          expect it to use in the context of Any. However, for URLs which use the\n                          scheme `http`, `https`, or no scheme, one can optionally set up a type\n                          server that maps type URLs to message definitions as follows:\n\n                          * If no scheme is provided, `https` is assumed.\n                          * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                            value in binary format, or produce an error.\n                          * Applications are allowed to cache lookup results based on the\n                            URL, or have them precompiled into a binary to avoid any\n                            lookup. Therefore, binary compatibility needs to be preserved\n                            on changes to types. (Use versioned type names to manage\n                            breaking changes.)\n\n                          Note: this functionality is not currently available in the official\n                          protobuf release, and it is not used for type URLs beginning with\n                          type.googleapis.com.\n\n                          Schemes other than `http`, `https` (or the empty scheme) might be\n                          used with implementation specific semantics.\n                      value:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: Must be a valid serialized protocol buffer of\n                          the above specified type.\n                        format: byte\n                    description: |-\n                      `Any` contains an arbitrary serialized protocol buffer message along with a\n                      URL that describes the type of the serialized message.\n\n                      Protobuf library provides support to pack/unpack Any values in the form\n                      of utility functions or additional generated methods of the Any type.\n\n                      Example 1: Pack and unpack a message in C++.\n\n                          Foo foo = ...;\n                          Any any;\n                          any.PackFrom(foo);\n                          ...\n                          if (any.UnpackTo(\u0026foo)) {\n                            ...\n                          }\n\n                      Example 2: Pack and unpack a message in Java.\n\n                          Foo foo = ...;\n                          Any any = Any.pack(foo);\n                          ...\n                          if (any.is(Foo.class)) {\n                            foo = any.unpack(Foo.class);\n                          }\n\n                       Example 3: Pack and unpack a message in Python.\n\n                          foo = Foo(...)\n                          any = Any()\n                          any.Pack(foo)\n                          ...\n                          if any.Is(Foo.DESCRIPTOR):\n                            any.Unpack(foo)\n                            ...\n\n                       Example 4: Pack and unpack a message in Go\n\n                           foo := \u0026pb.Foo{...}\n                           any, err := ptypes.MarshalAny(foo)\n                           ...\n                           foo := \u0026pb.Foo{}\n                           if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                             ...\n                           }\n\n                      The pack methods provided by protobuf library will by default use\n                      'type.googleapis.com/full.type.name' as the type URL and the unpack\n                      methods only use the fully qualified type name after the last '/'\n                      in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                      name \"y.z\".\n\n\n                      JSON\n                      ====\n                      The JSON representation of an `Any` value uses the regular\n                      representation of the deserialized, embedded message, with an\n                      additional field `@type` which contains the type URL. Example:\n\n                          package google.profile;\n                          message Person {\n                            string first_name = 1;\n                            string last_name = 2;\n                          }\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.profile.Person\",\n                            \"firstName\": \u003cstring\u003e,\n                            \"lastName\": \u003cstring\u003e\n                          }\n\n                      If the embedded message type is well-known and has a custom JSON\n                      representation, that representation will be embedded adding a field\n                      `value` which holds the custom JSON in addition to the `@type`\n                      field. Example (for message [google.protobuf.Duration][]):\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                            \"value\": \"1.212s\"\n                          }\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: |-\n                      Height is a monotonically increasing data type\n                      that can be compared against another Height for the purposes of updating and\n                      freezing clients\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/upgraded_client_states:\n    get:\n      tags:\n      - Query\n      summary: UpgradedClientState queries an Upgraded IBC light client.\n      operationId: UpgradedClientState\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  upgraded_client_state:\n                    title: client state associated with the request identifier\n                    type: object\n                    properties:\n                      type_url:\n                        type: string\n                        description: |-\n                          A URL/resource name that uniquely identifies the type of the serialized\n                          protocol buffer message. This string must contain at least\n                          one \"/\" character. The last segment of the URL's path must represent\n                          the fully qualified name of the type (as in\n                          `path/google.protobuf.Duration`). The name should be in a canonical form\n                          (e.g., leading \".\" is not accepted).\n\n                          In practice, teams usually precompile into the binary all types that they\n                          expect it to use in the context of Any. However, for URLs which use the\n                          scheme `http`, `https`, or no scheme, one can optionally set up a type\n                          server that maps type URLs to message definitions as follows:\n\n                          * If no scheme is provided, `https` is assumed.\n                          * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                            value in binary format, or produce an error.\n                          * Applications are allowed to cache lookup results based on the\n                            URL, or have them precompiled into a binary to avoid any\n                            lookup. Therefore, binary compatibility needs to be preserved\n                            on changes to types. (Use versioned type names to manage\n                            breaking changes.)\n\n                          Note: this functionality is not currently available in the official\n                          protobuf release, and it is not used for type URLs beginning with\n                          type.googleapis.com.\n\n                          Schemes other than `http`, `https` (or the empty scheme) might be\n                          used with implementation specific semantics.\n                      value:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: Must be a valid serialized protocol buffer of\n                          the above specified type.\n                        format: byte\n                    description: |-\n                      `Any` contains an arbitrary serialized protocol buffer message along with a\n                      URL that describes the type of the serialized message.\n\n                      Protobuf library provides support to pack/unpack Any values in the form\n                      of utility functions or additional generated methods of the Any type.\n\n                      Example 1: Pack and unpack a message in C++.\n\n                          Foo foo = ...;\n                          Any any;\n                          any.PackFrom(foo);\n                          ...\n                          if (any.UnpackTo(\u0026foo)) {\n                            ...\n                          }\n\n                      Example 2: Pack and unpack a message in Java.\n\n                          Foo foo = ...;\n                          Any any = Any.pack(foo);\n                          ...\n                          if (any.is(Foo.class)) {\n                            foo = any.unpack(Foo.class);\n                          }\n\n                       Example 3: Pack and unpack a message in Python.\n\n                          foo = Foo(...)\n                          any = Any()\n                          any.Pack(foo)\n                          ...\n                          if any.Is(Foo.DESCRIPTOR):\n                            any.Unpack(foo)\n                            ...\n\n                       Example 4: Pack and unpack a message in Go\n\n                           foo := \u0026pb.Foo{...}\n                           any, err := ptypes.MarshalAny(foo)\n                           ...\n                           foo := \u0026pb.Foo{}\n                           if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                             ...\n                           }\n\n                      The pack methods provided by protobuf library will by default use\n                      'type.googleapis.com/full.type.name' as the type URL and the unpack\n                      methods only use the fully qualified type name after the last '/'\n                      in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                      name \"y.z\".\n\n\n                      JSON\n                      ====\n                      The JSON representation of an `Any` value uses the regular\n                      representation of the deserialized, embedded message, with an\n                      additional field `@type` which contains the type URL. Example:\n\n                          package google.profile;\n                          message Person {\n                            string first_name = 1;\n                            string last_name = 2;\n                          }\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.profile.Person\",\n                            \"firstName\": \u003cstring\u003e,\n                            \"lastName\": \u003cstring\u003e\n                          }\n\n                      If the embedded message type is well-known and has a custom JSON\n                      representation, that representation will be embedded adding a field\n                      `value` which holds the custom JSON in addition to the `@type`\n                      field. Example (for message [google.protobuf.Duration][]):\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                            \"value\": \"1.212s\"\n                          }\n                description: |-\n                  QueryUpgradedClientStateResponse is the response type for the\n                  Query/UpgradedClientState RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/client/v1/upgraded_consensus_states:\n    get:\n      tags:\n      - Query\n      summary: UpgradedConsensusState queries an Upgraded IBC consensus state.\n      operationId: UpgradedConsensusState\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  upgraded_consensus_state:\n                    title: Consensus state associated with the request identifier\n                    type: object\n                    properties:\n                      type_url:\n                        type: string\n                        description: |-\n                          A URL/resource name that uniquely identifies the type of the serialized\n                          protocol buffer message. This string must contain at least\n                          one \"/\" character. The last segment of the URL's path must represent\n                          the fully qualified name of the type (as in\n                          `path/google.protobuf.Duration`). The name should be in a canonical form\n                          (e.g., leading \".\" is not accepted).\n\n                          In practice, teams usually precompile into the binary all types that they\n                          expect it to use in the context of Any. However, for URLs which use the\n                          scheme `http`, `https`, or no scheme, one can optionally set up a type\n                          server that maps type URLs to message definitions as follows:\n\n                          * If no scheme is provided, `https` is assumed.\n                          * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                            value in binary format, or produce an error.\n                          * Applications are allowed to cache lookup results based on the\n                            URL, or have them precompiled into a binary to avoid any\n                            lookup. Therefore, binary compatibility needs to be preserved\n                            on changes to types. (Use versioned type names to manage\n                            breaking changes.)\n\n                          Note: this functionality is not currently available in the official\n                          protobuf release, and it is not used for type URLs beginning with\n                          type.googleapis.com.\n\n                          Schemes other than `http`, `https` (or the empty scheme) might be\n                          used with implementation specific semantics.\n                      value:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: Must be a valid serialized protocol buffer of\n                          the above specified type.\n                        format: byte\n                    description: |-\n                      `Any` contains an arbitrary serialized protocol buffer message along with a\n                      URL that describes the type of the serialized message.\n\n                      Protobuf library provides support to pack/unpack Any values in the form\n                      of utility functions or additional generated methods of the Any type.\n\n                      Example 1: Pack and unpack a message in C++.\n\n                          Foo foo = ...;\n                          Any any;\n                          any.PackFrom(foo);\n                          ...\n                          if (any.UnpackTo(\u0026foo)) {\n                            ...\n                          }\n\n                      Example 2: Pack and unpack a message in Java.\n\n                          Foo foo = ...;\n                          Any any = Any.pack(foo);\n                          ...\n                          if (any.is(Foo.class)) {\n                            foo = any.unpack(Foo.class);\n                          }\n\n                       Example 3: Pack and unpack a message in Python.\n\n                          foo = Foo(...)\n                          any = Any()\n                          any.Pack(foo)\n                          ...\n                          if any.Is(Foo.DESCRIPTOR):\n                            any.Unpack(foo)\n                            ...\n\n                       Example 4: Pack and unpack a message in Go\n\n                           foo := \u0026pb.Foo{...}\n                           any, err := ptypes.MarshalAny(foo)\n                           ...\n                           foo := \u0026pb.Foo{}\n                           if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                             ...\n                           }\n\n                      The pack methods provided by protobuf library will by default use\n                      'type.googleapis.com/full.type.name' as the type URL and the unpack\n                      methods only use the fully qualified type name after the last '/'\n                      in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                      name \"y.z\".\n\n\n                      JSON\n                      ====\n                      The JSON representation of an `Any` value uses the regular\n                      representation of the deserialized, embedded message, with an\n                      additional field `@type` which contains the type URL. Example:\n\n                          package google.profile;\n                          message Person {\n                            string first_name = 1;\n                            string last_name = 2;\n                          }\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.profile.Person\",\n                            \"firstName\": \u003cstring\u003e,\n                            \"lastName\": \u003cstring\u003e\n                          }\n\n                      If the embedded message type is well-known and has a custom JSON\n                      representation, that representation will be embedded adding a field\n                      `value` which holds the custom JSON in addition to the `@type`\n                      field. Example (for message [google.protobuf.Duration][]):\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                            \"value\": \"1.212s\"\n                          }\n                description: |-\n                  QueryUpgradedConsensusStateResponse is the response type for the\n                  Query/UpgradedConsensusState RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/connection/v1/client_connections/{client_id}:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ClientConnections queries the connection paths associated with a client\n        state.\n      operationId: ClientConnections\n      parameters:\n      - name: client_id\n        in: path\n        description: client identifier associated with a connection\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryClientConnectionsResponse is the response type for the\n                  Query/ClientConnections RPC method\n                type: object\n                properties:\n                  connection_paths:\n                    type: array\n                    description: slice of all the connection paths associated with\n                      a client.\n                    items:\n                      type: string\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was generated\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/connection/v1/connections:\n    get:\n      tags:\n      - Query\n      summary: Connections queries all the IBC connections of a chain.\n      operationId: Connections\n      parameters:\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  connections:\n                    type: array\n                    description: list of stored connections of the chain.\n                    items:\n                      type: object\n                      properties:\n                        id:\n                          type: string\n                          description: connection identifier.\n                        client_id:\n                          type: string\n                          description: client associated with this connection.\n                        versions:\n                          title: |-\n                            IBC version which can be utilised to determine encodings or protocols for\n                            channels or packets utilising this connection\n                          type: array\n                          items:\n                            type: object\n                            properties:\n                              identifier:\n                                title: unique version identifier\n                                type: string\n                              features:\n                                title: list of features compatible with the specified\n                                  identifier\n                                type: array\n                                items:\n                                  type: string\n                            description: |-\n                              Version defines the versioning scheme used to negotiate the IBC verison in\n                              the connection handshake.\n                        state:\n                          type: string\n                          description: current state of the connection end.\n                          default: STATE_UNINITIALIZED_UNSPECIFIED\n                          enum:\n                          - STATE_UNINITIALIZED_UNSPECIFIED\n                          - STATE_INIT\n                          - STATE_TRYOPEN\n                          - STATE_OPEN\n                        counterparty:\n                          type: object\n                          properties:\n                            client_id:\n                              type: string\n                              description: |-\n                                identifies the client on the counterparty chain associated with a given\n                                connection.\n                            connection_id:\n                              type: string\n                              description: |-\n                                identifies the connection end on the counterparty chain associated with a\n                                given connection.\n                            prefix:\n                              title: |-\n                                MerklePrefix is merkle path prefixed to the key.\n                                The constructed key from the Path and the key will be append(Path.KeyPath,\n                                append(Path.KeyPrefix, key...))\n                              type: object\n                              properties:\n                                key_prefix:\n                                  pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                                  type: string\n                                  format: byte\n                              description: commitment merkle prefix of the counterparty\n                                chain.\n                          description: counterparty chain associated with this connection.\n                        delay_period:\n                          type: string\n                          description: delay period associated with this connection.\n                          format: uint64\n                      description: |-\n                        IdentifiedConnection defines a connection with additional connection\n                        identifier field.\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n                  height:\n                    title: query block height\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n                description: |-\n                  QueryConnectionsResponse is the response type for the Query/Connections RPC\n                  method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/connection/v1/connections/{connection_id}:\n    get:\n      tags:\n      - Query\n      summary: Connection queries an IBC connection end.\n      operationId: Connection\n      parameters:\n      - name: connection_id\n        in: path\n        description: connection unique identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  connection:\n                    title: connection associated with the request identifier\n                    type: object\n                    properties:\n                      client_id:\n                        type: string\n                        description: client associated with this connection.\n                      versions:\n                        type: array\n                        description: |-\n                          IBC version which can be utilised to determine encodings or protocols for\n                          channels or packets utilising this connection.\n                        items:\n                          type: object\n                          properties:\n                            identifier:\n                              title: unique version identifier\n                              type: string\n                            features:\n                              title: list of features compatible with the specified\n                                identifier\n                              type: array\n                              items:\n                                type: string\n                          description: |-\n                            Version defines the versioning scheme used to negotiate the IBC verison in\n                            the connection handshake.\n                      state:\n                        type: string\n                        description: current state of the connection end.\n                        default: STATE_UNINITIALIZED_UNSPECIFIED\n                        enum:\n                        - STATE_UNINITIALIZED_UNSPECIFIED\n                        - STATE_INIT\n                        - STATE_TRYOPEN\n                        - STATE_OPEN\n                      counterparty:\n                        type: object\n                        properties:\n                          client_id:\n                            type: string\n                            description: |-\n                              identifies the client on the counterparty chain associated with a given\n                              connection.\n                          connection_id:\n                            type: string\n                            description: |-\n                              identifies the connection end on the counterparty chain associated with a\n                              given connection.\n                          prefix:\n                            title: |-\n                              MerklePrefix is merkle path prefixed to the key.\n                              The constructed key from the Path and the key will be append(Path.KeyPath,\n                              append(Path.KeyPrefix, key...))\n                            type: object\n                            properties:\n                              key_prefix:\n                                pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                                type: string\n                                format: byte\n                            description: commitment merkle prefix of the counterparty\n                              chain.\n                        description: counterparty chain associated with this connection.\n                      delay_period:\n                        type: string\n                        description: |-\n                          delay period that must pass before a consensus state can be used for\n                          packet-verification NOTE: delay period logic is only implemented by some\n                          clients.\n                        format: uint64\n                    description: |-\n                      ConnectionEnd defines a stateful object on a chain connected to another\n                      separate one.\n                      NOTE: there must only be 2 defined ConnectionEnds to establish\n                      a connection between two chains.\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n                description: |-\n                  QueryConnectionResponse is the response type for the Query/Connection RPC\n                  method. Besides the connection end, it includes a proof and the height from\n                  which the proof was retrieved.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/connection/v1/connections/{connection_id}/client_state:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ConnectionClientState queries the client state associated with the\n        connection.\n      operationId: ConnectionClientState\n      parameters:\n      - name: connection_id\n        in: path\n        description: connection identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryConnectionClientStateResponse is the response type for the\n                  Query/ConnectionClientState RPC method\n                type: object\n                properties:\n                  identified_client_state:\n                    title: client state associated with the channel\n                    type: object\n                    properties:\n                      client_id:\n                        title: client identifier\n                        type: string\n                      client_state:\n                        title: client state\n                        type: object\n                        properties:\n                          type_url:\n                            type: string\n                            description: |-\n                              A URL/resource name that uniquely identifies the type of the serialized\n                              protocol buffer message. This string must contain at least\n                              one \"/\" character. The last segment of the URL's path must represent\n                              the fully qualified name of the type (as in\n                              `path/google.protobuf.Duration`). The name should be in a canonical form\n                              (e.g., leading \".\" is not accepted).\n\n                              In practice, teams usually precompile into the binary all types that they\n                              expect it to use in the context of Any. However, for URLs which use the\n                              scheme `http`, `https`, or no scheme, one can optionally set up a type\n                              server that maps type URLs to message definitions as follows:\n\n                              * If no scheme is provided, `https` is assumed.\n                              * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                                value in binary format, or produce an error.\n                              * Applications are allowed to cache lookup results based on the\n                                URL, or have them precompiled into a binary to avoid any\n                                lookup. Therefore, binary compatibility needs to be preserved\n                                on changes to types. (Use versioned type names to manage\n                                breaking changes.)\n\n                              Note: this functionality is not currently available in the official\n                              protobuf release, and it is not used for type URLs beginning with\n                              type.googleapis.com.\n\n                              Schemes other than `http`, `https` (or the empty scheme) might be\n                              used with implementation specific semantics.\n                          value:\n                            pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                            type: string\n                            description: Must be a valid serialized protocol buffer\n                              of the above specified type.\n                            format: byte\n                        description: |-\n                          `Any` contains an arbitrary serialized protocol buffer message along with a\n                          URL that describes the type of the serialized message.\n\n                          Protobuf library provides support to pack/unpack Any values in the form\n                          of utility functions or additional generated methods of the Any type.\n\n                          Example 1: Pack and unpack a message in C++.\n\n                              Foo foo = ...;\n                              Any any;\n                              any.PackFrom(foo);\n                              ...\n                              if (any.UnpackTo(\u0026foo)) {\n                                ...\n                              }\n\n                          Example 2: Pack and unpack a message in Java.\n\n                              Foo foo = ...;\n                              Any any = Any.pack(foo);\n                              ...\n                              if (any.is(Foo.class)) {\n                                foo = any.unpack(Foo.class);\n                              }\n\n                           Example 3: Pack and unpack a message in Python.\n\n                              foo = Foo(...)\n                              any = Any()\n                              any.Pack(foo)\n                              ...\n                              if any.Is(Foo.DESCRIPTOR):\n                                any.Unpack(foo)\n                                ...\n\n                           Example 4: Pack and unpack a message in Go\n\n                               foo := \u0026pb.Foo{...}\n                               any, err := ptypes.MarshalAny(foo)\n                               ...\n                               foo := \u0026pb.Foo{}\n                               if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                                 ...\n                               }\n\n                          The pack methods provided by protobuf library will by default use\n                          'type.googleapis.com/full.type.name' as the type URL and the unpack\n                          methods only use the fully qualified type name after the last '/'\n                          in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                          name \"y.z\".\n\n\n                          JSON\n                          ====\n                          The JSON representation of an `Any` value uses the regular\n                          representation of the deserialized, embedded message, with an\n                          additional field `@type` which contains the type URL. Example:\n\n                              package google.profile;\n                              message Person {\n                                string first_name = 1;\n                                string last_name = 2;\n                              }\n\n                              {\n                                \"@type\": \"type.googleapis.com/google.profile.Person\",\n                                \"firstName\": \u003cstring\u003e,\n                                \"lastName\": \u003cstring\u003e\n                              }\n\n                          If the embedded message type is well-known and has a custom JSON\n                          representation, that representation will be embedded adding a field\n                          `value` which holds the custom JSON in addition to the `@type`\n                          field. Example (for message [google.protobuf.Duration][]):\n\n                              {\n                                \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                                \"value\": \"1.212s\"\n                              }\n                    description: |-\n                      IdentifiedClientState defines a client state with an additional client\n                      identifier field.\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ConnectionConsensusState queries the consensus state associated with the\n        connection.\n      operationId: ConnectionConsensusState\n      parameters:\n      - name: connection_id\n        in: path\n        description: connection identifier\n        required: true\n        schema:\n          type: string\n      - name: revision_number\n        in: path\n        required: true\n        schema:\n          type: string\n          format: uint64\n      - name: revision_height\n        in: path\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryConnectionConsensusStateResponse is the response type for the\n                  Query/ConnectionConsensusState RPC method\n                type: object\n                properties:\n                  consensus_state:\n                    title: consensus state associated with the channel\n                    type: object\n                    properties:\n                      type_url:\n                        type: string\n                        description: |-\n                          A URL/resource name that uniquely identifies the type of the serialized\n                          protocol buffer message. This string must contain at least\n                          one \"/\" character. The last segment of the URL's path must represent\n                          the fully qualified name of the type (as in\n                          `path/google.protobuf.Duration`). The name should be in a canonical form\n                          (e.g., leading \".\" is not accepted).\n\n                          In practice, teams usually precompile into the binary all types that they\n                          expect it to use in the context of Any. However, for URLs which use the\n                          scheme `http`, `https`, or no scheme, one can optionally set up a type\n                          server that maps type URLs to message definitions as follows:\n\n                          * If no scheme is provided, `https` is assumed.\n                          * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                            value in binary format, or produce an error.\n                          * Applications are allowed to cache lookup results based on the\n                            URL, or have them precompiled into a binary to avoid any\n                            lookup. Therefore, binary compatibility needs to be preserved\n                            on changes to types. (Use versioned type names to manage\n                            breaking changes.)\n\n                          Note: this functionality is not currently available in the official\n                          protobuf release, and it is not used for type URLs beginning with\n                          type.googleapis.com.\n\n                          Schemes other than `http`, `https` (or the empty scheme) might be\n                          used with implementation specific semantics.\n                      value:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: Must be a valid serialized protocol buffer of\n                          the above specified type.\n                        format: byte\n                    description: |-\n                      `Any` contains an arbitrary serialized protocol buffer message along with a\n                      URL that describes the type of the serialized message.\n\n                      Protobuf library provides support to pack/unpack Any values in the form\n                      of utility functions or additional generated methods of the Any type.\n\n                      Example 1: Pack and unpack a message in C++.\n\n                          Foo foo = ...;\n                          Any any;\n                          any.PackFrom(foo);\n                          ...\n                          if (any.UnpackTo(\u0026foo)) {\n                            ...\n                          }\n\n                      Example 2: Pack and unpack a message in Java.\n\n                          Foo foo = ...;\n                          Any any = Any.pack(foo);\n                          ...\n                          if (any.is(Foo.class)) {\n                            foo = any.unpack(Foo.class);\n                          }\n\n                       Example 3: Pack and unpack a message in Python.\n\n                          foo = Foo(...)\n                          any = Any()\n                          any.Pack(foo)\n                          ...\n                          if any.Is(Foo.DESCRIPTOR):\n                            any.Unpack(foo)\n                            ...\n\n                       Example 4: Pack and unpack a message in Go\n\n                           foo := \u0026pb.Foo{...}\n                           any, err := ptypes.MarshalAny(foo)\n                           ...\n                           foo := \u0026pb.Foo{}\n                           if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                             ...\n                           }\n\n                      The pack methods provided by protobuf library will by default use\n                      'type.googleapis.com/full.type.name' as the type URL and the unpack\n                      methods only use the fully qualified type name after the last '/'\n                      in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                      name \"y.z\".\n\n\n                      JSON\n                      ====\n                      The JSON representation of an `Any` value uses the regular\n                      representation of the deserialized, embedded message, with an\n                      additional field `@type` which contains the type URL. Example:\n\n                          package google.profile;\n                          message Person {\n                            string first_name = 1;\n                            string last_name = 2;\n                          }\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.profile.Person\",\n                            \"firstName\": \u003cstring\u003e,\n                            \"lastName\": \u003cstring\u003e\n                          }\n\n                      If the embedded message type is well-known and has a custom JSON\n                      representation, that representation will be embedded adding a field\n                      `value` which holds the custom JSON in addition to the `@type`\n                      field. Example (for message [google.protobuf.Duration][]):\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                            \"value\": \"1.212s\"\n                          }\n                  client_id:\n                    title: client ID associated with the consensus state\n                    type: string\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels:\n    get:\n      tags:\n      - Query\n      summary: Channels queries all the IBC channels of a chain.\n      operationId: Channels\n      parameters:\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  channels:\n                    type: array\n                    description: list of stored channels of the chain.\n                    items:\n                      type: object\n                      properties:\n                        state:\n                          title: current state of the channel end\n                          type: string\n                          description: |-\n                            State defines if a channel is in one of the following states:\n                            CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n                             - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n                             - STATE_INIT: A channel has just started the opening handshake.\n                             - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n                             - STATE_OPEN: A channel has completed the handshake. Open channels are\n                            ready to send and receive packets.\n                             - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n                            packets.\n                          default: STATE_UNINITIALIZED_UNSPECIFIED\n                          enum:\n                          - STATE_UNINITIALIZED_UNSPECIFIED\n                          - STATE_INIT\n                          - STATE_TRYOPEN\n                          - STATE_OPEN\n                          - STATE_CLOSED\n                        ordering:\n                          title: whether the channel is ordered or unordered\n                          type: string\n                          description: |-\n                            - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n                             - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n                            which they were sent.\n                             - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n                          default: ORDER_NONE_UNSPECIFIED\n                          enum:\n                          - ORDER_NONE_UNSPECIFIED\n                          - ORDER_UNORDERED\n                          - ORDER_ORDERED\n                        counterparty:\n                          title: counterparty channel end\n                          type: object\n                          properties:\n                            port_id:\n                              type: string\n                              description: port on the counterparty chain which owns\n                                the other end of the channel.\n                            channel_id:\n                              title: channel end on the counterparty chain\n                              type: string\n                        connection_hops:\n                          title: |-\n                            list of connection identifiers, in order, along which packets sent on\n                            this channel will travel\n                          type: array\n                          items:\n                            type: string\n                        version:\n                          title: opaque channel version, which is agreed upon during\n                            the handshake\n                          type: string\n                        port_id:\n                          title: port identifier\n                          type: string\n                        channel_id:\n                          title: channel identifier\n                          type: string\n                      description: |-\n                        IdentifiedChannel defines a channel with additional port and channel\n                        identifier fields.\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n                  height:\n                    title: query block height\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n                description: QueryChannelsResponse is the response type for the Query/Channels\n                  RPC method.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}:\n    get:\n      tags:\n      - Query\n      summary: Channel queries an IBC Channel.\n      operationId: Channel\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  channel:\n                    title: channel associated with the request identifiers\n                    type: object\n                    properties:\n                      state:\n                        title: current state of the channel end\n                        type: string\n                        description: |-\n                          State defines if a channel is in one of the following states:\n                          CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n                           - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n                           - STATE_INIT: A channel has just started the opening handshake.\n                           - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n                           - STATE_OPEN: A channel has completed the handshake. Open channels are\n                          ready to send and receive packets.\n                           - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n                          packets.\n                        default: STATE_UNINITIALIZED_UNSPECIFIED\n                        enum:\n                        - STATE_UNINITIALIZED_UNSPECIFIED\n                        - STATE_INIT\n                        - STATE_TRYOPEN\n                        - STATE_OPEN\n                        - STATE_CLOSED\n                      ordering:\n                        title: whether the channel is ordered or unordered\n                        type: string\n                        description: |-\n                          - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n                           - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n                          which they were sent.\n                           - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n                        default: ORDER_NONE_UNSPECIFIED\n                        enum:\n                        - ORDER_NONE_UNSPECIFIED\n                        - ORDER_UNORDERED\n                        - ORDER_ORDERED\n                      counterparty:\n                        title: counterparty channel end\n                        type: object\n                        properties:\n                          port_id:\n                            type: string\n                            description: port on the counterparty chain which owns\n                              the other end of the channel.\n                          channel_id:\n                            title: channel end on the counterparty chain\n                            type: string\n                      connection_hops:\n                        title: |-\n                          list of connection identifiers, in order, along which packets sent on\n                          this channel will travel\n                        type: array\n                        items:\n                          type: string\n                      version:\n                        title: opaque channel version, which is agreed upon during\n                          the handshake\n                        type: string\n                    description: |-\n                      Channel defines pipeline for exactly-once packet delivery between specific\n                      modules on separate blockchains, which has at least one end capable of\n                      sending packets and one end capable of receiving packets.\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n                description: |-\n                  QueryChannelResponse is the response type for the Query/Channel RPC method.\n                  Besides the Channel end, it includes a proof and the height from which the\n                  proof was retrieved.\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ChannelClientState queries for the client state for the channel associated\n        with the provided channel identifiers.\n      operationId: ChannelClientState\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryChannelClientStateResponse is the Response type for the\n                  Query/QueryChannelClientState RPC method\n                type: object\n                properties:\n                  identified_client_state:\n                    title: client state associated with the channel\n                    type: object\n                    properties:\n                      client_id:\n                        title: client identifier\n                        type: string\n                      client_state:\n                        title: client state\n                        type: object\n                        properties:\n                          type_url:\n                            type: string\n                            description: |-\n                              A URL/resource name that uniquely identifies the type of the serialized\n                              protocol buffer message. This string must contain at least\n                              one \"/\" character. The last segment of the URL's path must represent\n                              the fully qualified name of the type (as in\n                              `path/google.protobuf.Duration`). The name should be in a canonical form\n                              (e.g., leading \".\" is not accepted).\n\n                              In practice, teams usually precompile into the binary all types that they\n                              expect it to use in the context of Any. However, for URLs which use the\n                              scheme `http`, `https`, or no scheme, one can optionally set up a type\n                              server that maps type URLs to message definitions as follows:\n\n                              * If no scheme is provided, `https` is assumed.\n                              * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                                value in binary format, or produce an error.\n                              * Applications are allowed to cache lookup results based on the\n                                URL, or have them precompiled into a binary to avoid any\n                                lookup. Therefore, binary compatibility needs to be preserved\n                                on changes to types. (Use versioned type names to manage\n                                breaking changes.)\n\n                              Note: this functionality is not currently available in the official\n                              protobuf release, and it is not used for type URLs beginning with\n                              type.googleapis.com.\n\n                              Schemes other than `http`, `https` (or the empty scheme) might be\n                              used with implementation specific semantics.\n                          value:\n                            pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                            type: string\n                            description: Must be a valid serialized protocol buffer\n                              of the above specified type.\n                            format: byte\n                        description: |-\n                          `Any` contains an arbitrary serialized protocol buffer message along with a\n                          URL that describes the type of the serialized message.\n\n                          Protobuf library provides support to pack/unpack Any values in the form\n                          of utility functions or additional generated methods of the Any type.\n\n                          Example 1: Pack and unpack a message in C++.\n\n                              Foo foo = ...;\n                              Any any;\n                              any.PackFrom(foo);\n                              ...\n                              if (any.UnpackTo(\u0026foo)) {\n                                ...\n                              }\n\n                          Example 2: Pack and unpack a message in Java.\n\n                              Foo foo = ...;\n                              Any any = Any.pack(foo);\n                              ...\n                              if (any.is(Foo.class)) {\n                                foo = any.unpack(Foo.class);\n                              }\n\n                           Example 3: Pack and unpack a message in Python.\n\n                              foo = Foo(...)\n                              any = Any()\n                              any.Pack(foo)\n                              ...\n                              if any.Is(Foo.DESCRIPTOR):\n                                any.Unpack(foo)\n                                ...\n\n                           Example 4: Pack and unpack a message in Go\n\n                               foo := \u0026pb.Foo{...}\n                               any, err := ptypes.MarshalAny(foo)\n                               ...\n                               foo := \u0026pb.Foo{}\n                               if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                                 ...\n                               }\n\n                          The pack methods provided by protobuf library will by default use\n                          'type.googleapis.com/full.type.name' as the type URL and the unpack\n                          methods only use the fully qualified type name after the last '/'\n                          in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                          name \"y.z\".\n\n\n                          JSON\n                          ====\n                          The JSON representation of an `Any` value uses the regular\n                          representation of the deserialized, embedded message, with an\n                          additional field `@type` which contains the type URL. Example:\n\n                              package google.profile;\n                              message Person {\n                                string first_name = 1;\n                                string last_name = 2;\n                              }\n\n                              {\n                                \"@type\": \"type.googleapis.com/google.profile.Person\",\n                                \"firstName\": \u003cstring\u003e,\n                                \"lastName\": \u003cstring\u003e\n                              }\n\n                          If the embedded message type is well-known and has a custom JSON\n                          representation, that representation will be embedded adding a field\n                          `value` which holds the custom JSON in addition to the `@type`\n                          field. Example (for message [google.protobuf.Duration][]):\n\n                              {\n                                \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                                \"value\": \"1.212s\"\n                              }\n                    description: |-\n                      IdentifiedClientState defines a client state with an additional client\n                      identifier field.\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ChannelConsensusState queries for the consensus state for the channel\n        associated with the provided channel identifiers.\n      operationId: ChannelConsensusState\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: revision_number\n        in: path\n        description: revision number of the consensus state\n        required: true\n        schema:\n          type: string\n          format: uint64\n      - name: revision_height\n        in: path\n        description: revision height of the consensus state\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryChannelClientStateResponse is the Response type for the\n                  Query/QueryChannelClientState RPC method\n                type: object\n                properties:\n                  consensus_state:\n                    title: consensus state associated with the channel\n                    type: object\n                    properties:\n                      type_url:\n                        type: string\n                        description: |-\n                          A URL/resource name that uniquely identifies the type of the serialized\n                          protocol buffer message. This string must contain at least\n                          one \"/\" character. The last segment of the URL's path must represent\n                          the fully qualified name of the type (as in\n                          `path/google.protobuf.Duration`). The name should be in a canonical form\n                          (e.g., leading \".\" is not accepted).\n\n                          In practice, teams usually precompile into the binary all types that they\n                          expect it to use in the context of Any. However, for URLs which use the\n                          scheme `http`, `https`, or no scheme, one can optionally set up a type\n                          server that maps type URLs to message definitions as follows:\n\n                          * If no scheme is provided, `https` is assumed.\n                          * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                            value in binary format, or produce an error.\n                          * Applications are allowed to cache lookup results based on the\n                            URL, or have them precompiled into a binary to avoid any\n                            lookup. Therefore, binary compatibility needs to be preserved\n                            on changes to types. (Use versioned type names to manage\n                            breaking changes.)\n\n                          Note: this functionality is not currently available in the official\n                          protobuf release, and it is not used for type URLs beginning with\n                          type.googleapis.com.\n\n                          Schemes other than `http`, `https` (or the empty scheme) might be\n                          used with implementation specific semantics.\n                      value:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: Must be a valid serialized protocol buffer of\n                          the above specified type.\n                        format: byte\n                    description: |-\n                      `Any` contains an arbitrary serialized protocol buffer message along with a\n                      URL that describes the type of the serialized message.\n\n                      Protobuf library provides support to pack/unpack Any values in the form\n                      of utility functions or additional generated methods of the Any type.\n\n                      Example 1: Pack and unpack a message in C++.\n\n                          Foo foo = ...;\n                          Any any;\n                          any.PackFrom(foo);\n                          ...\n                          if (any.UnpackTo(\u0026foo)) {\n                            ...\n                          }\n\n                      Example 2: Pack and unpack a message in Java.\n\n                          Foo foo = ...;\n                          Any any = Any.pack(foo);\n                          ...\n                          if (any.is(Foo.class)) {\n                            foo = any.unpack(Foo.class);\n                          }\n\n                       Example 3: Pack and unpack a message in Python.\n\n                          foo = Foo(...)\n                          any = Any()\n                          any.Pack(foo)\n                          ...\n                          if any.Is(Foo.DESCRIPTOR):\n                            any.Unpack(foo)\n                            ...\n\n                       Example 4: Pack and unpack a message in Go\n\n                           foo := \u0026pb.Foo{...}\n                           any, err := ptypes.MarshalAny(foo)\n                           ...\n                           foo := \u0026pb.Foo{}\n                           if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                             ...\n                           }\n\n                      The pack methods provided by protobuf library will by default use\n                      'type.googleapis.com/full.type.name' as the type URL and the unpack\n                      methods only use the fully qualified type name after the last '/'\n                      in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                      name \"y.z\".\n\n\n                      JSON\n                      ====\n                      The JSON representation of an `Any` value uses the regular\n                      representation of the deserialized, embedded message, with an\n                      additional field `@type` which contains the type URL. Example:\n\n                          package google.profile;\n                          message Person {\n                            string first_name = 1;\n                            string last_name = 2;\n                          }\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.profile.Person\",\n                            \"firstName\": \u003cstring\u003e,\n                            \"lastName\": \u003cstring\u003e\n                          }\n\n                      If the embedded message type is well-known and has a custom JSON\n                      representation, that representation will be embedded adding a field\n                      `value` which holds the custom JSON in addition to the `@type`\n                      field. Example (for message [google.protobuf.Duration][]):\n\n                          {\n                            \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                            \"value\": \"1.212s\"\n                          }\n                  client_id:\n                    title: client ID associated with the consensus state\n                    type: string\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence:\n    get:\n      tags:\n      - Query\n      summary: NextSequenceReceive returns the next receive sequence for a given channel.\n      operationId: NextSequenceReceive\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QuerySequenceResponse is the request type for the\n                  Query/QueryNextSequenceReceiveResponse RPC method\n                type: object\n                properties:\n                  next_sequence_receive:\n                    title: next sequence receive number\n                    type: string\n                    format: uint64\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements:\n    get:\n      tags:\n      - Query\n      summary: |-\n        PacketAcknowledgements returns all the packet acknowledgements associated\n        with a channel.\n      operationId: PacketAcknowledgements\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      - name: packet_commitment_sequences\n        in: query\n        description: list of packet sequences.\n        style: form\n        explode: true\n        schema:\n          type: array\n          items:\n            type: string\n            format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryPacketAcknowledgemetsResponse is the request type for the\n                  Query/QueryPacketAcknowledgements RPC method\n                type: object\n                properties:\n                  acknowledgements:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        port_id:\n                          type: string\n                          description: channel port identifier.\n                        channel_id:\n                          type: string\n                          description: channel unique identifier.\n                        sequence:\n                          type: string\n                          description: packet sequence.\n                          format: uint64\n                        data:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: embedded data that represents packet state.\n                          format: byte\n                      description: |-\n                        PacketState defines the generic type necessary to retrieve and store\n                        packet commitments, acknowledgements, and receipts.\n                        Caller is responsible for knowing the context necessary to interpret this\n                        state as a commitment, acknowledgement, or a receipt.\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n                  height:\n                    title: query block height\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}:\n    get:\n      tags:\n      - Query\n      summary: PacketAcknowledgement queries a stored packet acknowledgement hash.\n      operationId: PacketAcknowledgement\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: sequence\n        in: path\n        description: packet sequence\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryPacketAcknowledgementResponse defines the client query response for a\n                  packet which also includes a proof and the height from which the\n                  proof was retrieved\n                type: object\n                properties:\n                  acknowledgement:\n                    title: packet associated with the request fields\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments:\n    get:\n      tags:\n      - Query\n      summary: |-\n        PacketCommitments returns all the packet commitments hashes associated\n        with a channel.\n      operationId: PacketCommitments\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryPacketCommitmentsResponse is the request type for the\n                  Query/QueryPacketCommitments RPC method\n                type: object\n                properties:\n                  commitments:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        port_id:\n                          type: string\n                          description: channel port identifier.\n                        channel_id:\n                          type: string\n                          description: channel unique identifier.\n                        sequence:\n                          type: string\n                          description: packet sequence.\n                          format: uint64\n                        data:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: embedded data that represents packet state.\n                          format: byte\n                      description: |-\n                        PacketState defines the generic type necessary to retrieve and store\n                        packet commitments, acknowledgements, and receipts.\n                        Caller is responsible for knowing the context necessary to interpret this\n                        state as a commitment, acknowledgement, or a receipt.\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n                  height:\n                    title: query block height\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks:\n    get:\n      tags:\n      - Query\n      summary: |-\n        UnreceivedAcks returns all the unreceived IBC acknowledgements associated\n        with a channel and sequences.\n      operationId: UnreceivedAcks\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_ack_sequences\n        in: path\n        description: list of acknowledgement sequences\n        required: true\n        style: simple\n        explode: false\n        schema:\n          minItems: 1\n          type: array\n          items:\n            type: string\n            format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryUnreceivedAcksResponse is the response type for the\n                  Query/UnreceivedAcks RPC method\n                type: object\n                properties:\n                  sequences:\n                    title: list of unreceived acknowledgement sequences\n                    type: array\n                    items:\n                      type: string\n                      format: uint64\n                  height:\n                    title: query block height\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets:\n    get:\n      tags:\n      - Query\n      summary: |-\n        UnreceivedPackets returns all the unreceived IBC packets associated with a\n        channel and sequences.\n      operationId: UnreceivedPackets\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: packet_commitment_sequences\n        in: path\n        description: list of packet sequences\n        required: true\n        style: simple\n        explode: false\n        schema:\n          minItems: 1\n          type: array\n          items:\n            type: string\n            format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryUnreceivedPacketsResponse is the response type for the\n                  Query/UnreceivedPacketCommitments RPC method\n                type: object\n                properties:\n                  sequences:\n                    title: list of unreceived packet sequences\n                    type: array\n                    items:\n                      type: string\n                      format: uint64\n                  height:\n                    title: query block height\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}:\n    get:\n      tags:\n      - Query\n      summary: PacketCommitment queries a stored packet commitment hash.\n      operationId: PacketCommitment\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: sequence\n        in: path\n        description: packet sequence\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryPacketCommitmentResponse defines the client query response for a packet\n                  which also includes a proof and the height from which the proof was\n                  retrieved\n                type: object\n                properties:\n                  commitment:\n                    title: packet associated with the request fields\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}:\n    get:\n      tags:\n      - Query\n      summary: |-\n        PacketReceipt queries if a given packet sequence has been received on the\n        queried chain\n      operationId: PacketReceipt\n      parameters:\n      - name: channel_id\n        in: path\n        description: channel unique identifier\n        required: true\n        schema:\n          type: string\n      - name: port_id\n        in: path\n        description: port unique identifier\n        required: true\n        schema:\n          type: string\n      - name: sequence\n        in: path\n        description: packet sequence\n        required: true\n        schema:\n          type: string\n          format: uint64\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryPacketReceiptResponse defines the client query response for a packet\n                  receipt which also includes a proof, and the height from which the proof was\n                  retrieved\n                type: object\n                properties:\n                  received:\n                    title: success flag for if receipt exists\n                    type: boolean\n                    format: boolean\n                  proof:\n                    title: merkle proof of existence\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    format: byte\n                  proof_height:\n                    title: height at which the proof was retrieved\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\n  /ibc/core/channel/v1/connections/{connection}/channels:\n    get:\n      tags:\n      - Query\n      summary: |-\n        ConnectionChannels queries all the channels associated with a connection\n        end.\n      operationId: ConnectionChannels\n      parameters:\n      - name: connection\n        in: path\n        description: connection unique identifier\n        required: true\n        schema:\n          type: string\n      - name: pagination.key\n        in: query\n        description: |-\n          key is a value returned in PageResponse.next_key to begin\n          querying the next page most efficiently. Only one of offset or key\n          should be set.\n        schema:\n          type: string\n          format: byte\n      - name: pagination.offset\n        in: query\n        description: |-\n          offset is a numeric offset that can be used when key is unavailable.\n          It is less efficient than using key. Only one of offset or key should\n          be set.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.limit\n        in: query\n        description: |-\n          limit is the total number of results to be returned in the result page.\n          If left empty it will default to a value to be set by each app.\n        schema:\n          type: string\n          format: uint64\n      - name: pagination.count_total\n        in: query\n        description: |-\n          count_total is set to true  to indicate that the result set should include\n          a count of the total number of items available for pagination in UIs.\n          count_total is only respected when offset is used. It is ignored when key\n          is set.\n        schema:\n          type: boolean\n          format: boolean\n      - name: pagination.reverse\n        in: query\n        description: |-\n          reverse is set to true if results are to be returned in the descending order.\n\n          Since: cosmos-sdk 0.43\n        schema:\n          type: boolean\n          format: boolean\n      responses:\n        200:\n          description: A successful response.\n          content:\n            '*/*':\n              schema:\n                title: |-\n                  QueryConnectionChannelsResponse is the Response type for the\n                  Query/QueryConnectionChannels RPC method\n                type: object\n                properties:\n                  channels:\n                    type: array\n                    description: list of channels associated with a connection.\n                    items:\n                      type: object\n                      properties:\n                        state:\n                          title: current state of the channel end\n                          type: string\n                          description: |-\n                            State defines if a channel is in one of the following states:\n                            CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n                             - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n                             - STATE_INIT: A channel has just started the opening handshake.\n                             - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n                             - STATE_OPEN: A channel has completed the handshake. Open channels are\n                            ready to send and receive packets.\n                             - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n                            packets.\n                          default: STATE_UNINITIALIZED_UNSPECIFIED\n                          enum:\n                          - STATE_UNINITIALIZED_UNSPECIFIED\n                          - STATE_INIT\n                          - STATE_TRYOPEN\n                          - STATE_OPEN\n                          - STATE_CLOSED\n                        ordering:\n                          title: whether the channel is ordered or unordered\n                          type: string\n                          description: |-\n                            - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n                             - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n                            which they were sent.\n                             - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n                          default: ORDER_NONE_UNSPECIFIED\n                          enum:\n                          - ORDER_NONE_UNSPECIFIED\n                          - ORDER_UNORDERED\n                          - ORDER_ORDERED\n                        counterparty:\n                          title: counterparty channel end\n                          type: object\n                          properties:\n                            port_id:\n                              type: string\n                              description: port on the counterparty chain which owns\n                                the other end of the channel.\n                            channel_id:\n                              title: channel end on the counterparty chain\n                              type: string\n                        connection_hops:\n                          title: |-\n                            list of connection identifiers, in order, along which packets sent on\n                            this channel will travel\n                          type: array\n                          items:\n                            type: string\n                        version:\n                          title: opaque channel version, which is agreed upon during\n                            the handshake\n                          type: string\n                        port_id:\n                          title: port identifier\n                          type: string\n                        channel_id:\n                          title: channel identifier\n                          type: string\n                      description: |-\n                        IdentifiedChannel defines a channel with additional port and channel\n                        identifier fields.\n                  pagination:\n                    title: pagination response\n                    type: object\n                    properties:\n                      next_key:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        description: |-\n                          next_key is the key to be passed to PageRequest.key to\n                          query the next page most efficiently. It will be empty if\n                          there are no more results.\n                        format: byte\n                      total:\n                        title: |-\n                          total is total number of results available if PageRequest.count_total\n                          was set, its value is undefined otherwise\n                        type: string\n                        format: uint64\n                    description: |-\n                      PageResponse is to be embedded in gRPC response messages where the\n                      corresponding request message has used PageRequest.\n\n                       message SomeResponse {\n                               repeated Bar results = 1;\n                               PageResponse page = 2;\n                       }\n                  height:\n                    title: query block height\n                    type: object\n                    properties:\n                      revision_number:\n                        title: the revision that the client is currently on\n                        type: string\n                        format: uint64\n                      revision_height:\n                        title: the height within the given revision\n                        type: string\n                        format: uint64\n                    description: |-\n                      Normally the RevisionHeight is incremented at each height while keeping\n                      RevisionNumber the same. However some consensus algorithms may choose to\n                      reset the height in certain conditions e.g. hard forks, state-machine\n                      breaking changes In these cases, the RevisionNumber is incremented so that\n                      height continues to be monitonically increasing even as the RevisionHeight\n                      gets reset\n        default:\n          description: An unexpected error response\n          content:\n            '*/*':\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  code:\n                    type: integer\n                    format: int32\n                  message:\n                    type: string\n                  details:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        type_url:\n                          type: string\n                          description: |-\n                            A URL/resource name that uniquely identifies the type of the serialized\n                            protocol buffer message. This string must contain at least\n                            one \"/\" character. The last segment of the URL's path must represent\n                            the fully qualified name of the type (as in\n                            `path/google.protobuf.Duration`). The name should be in a canonical form\n                            (e.g., leading \".\" is not accepted).\n\n                            In practice, teams usually precompile into the binary all types that they\n                            expect it to use in the context of Any. However, for URLs which use the\n                            scheme `http`, `https`, or no scheme, one can optionally set up a type\n                            server that maps type URLs to message definitions as follows:\n\n                            * If no scheme is provided, `https` is assumed.\n                            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                              value in binary format, or produce an error.\n                            * Applications are allowed to cache lookup results based on the\n                              URL, or have them precompiled into a binary to avoid any\n                              lookup. Therefore, binary compatibility needs to be preserved\n                              on changes to types. (Use versioned type names to manage\n                              breaking changes.)\n\n                            Note: this functionality is not currently available in the official\n                            protobuf release, and it is not used for type URLs beginning with\n                            type.googleapis.com.\n\n                            Schemes other than `http`, `https` (or the empty scheme) might be\n                            used with implementation specific semantics.\n                        value:\n                          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                          type: string\n                          description: Must be a valid serialized protocol buffer\n                            of the above specified type.\n                          format: byte\n                      description: |-\n                        `Any` contains an arbitrary serialized protocol buffer message along with a\n                        URL that describes the type of the serialized message.\n\n                        Protobuf library provides support to pack/unpack Any values in the form\n                        of utility functions or additional generated methods of the Any type.\n\n                        Example 1: Pack and unpack a message in C++.\n\n                            Foo foo = ...;\n                            Any any;\n                            any.PackFrom(foo);\n                            ...\n                            if (any.UnpackTo(\u0026foo)) {\n                              ...\n                            }\n\n                        Example 2: Pack and unpack a message in Java.\n\n                            Foo foo = ...;\n                            Any any = Any.pack(foo);\n                            ...\n                            if (any.is(Foo.class)) {\n                              foo = any.unpack(Foo.class);\n                            }\n\n                         Example 3: Pack and unpack a message in Python.\n\n                            foo = Foo(...)\n                            any = Any()\n                            any.Pack(foo)\n                            ...\n                            if any.Is(Foo.DESCRIPTOR):\n                              any.Unpack(foo)\n                              ...\n\n                         Example 4: Pack and unpack a message in Go\n\n                             foo := \u0026pb.Foo{...}\n                             any, err := ptypes.MarshalAny(foo)\n                             ...\n                             foo := \u0026pb.Foo{}\n                             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                               ...\n                             }\n\n                        The pack methods provided by protobuf library will by default use\n                        'type.googleapis.com/full.type.name' as the type URL and the unpack\n                        methods only use the fully qualified type name after the last '/'\n                        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                        name \"y.z\".\n\n\n                        JSON\n                        ====\n                        The JSON representation of an `Any` value uses the regular\n                        representation of the deserialized, embedded message, with an\n                        additional field `@type` which contains the type URL. Example:\n\n                            package google.profile;\n                            message Person {\n                              string first_name = 1;\n                              string last_name = 2;\n                            }\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.profile.Person\",\n                              \"firstName\": \u003cstring\u003e,\n                              \"lastName\": \u003cstring\u003e\n                            }\n\n                        If the embedded message type is well-known and has a custom JSON\n                        representation, that representation will be embedded adding a field\n                        `value` which holds the custom JSON in addition to the `@type`\n                        field. Example (for message [google.protobuf.Duration][]):\n\n                            {\n                              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                              \"value\": \"1.212s\"\n                            }\ncomponents:\n  schemas:\n    cosmos.base.query.v1beta1.PageRequest:\n      title: |-\n        PageRequest is to be embedded in gRPC request messages for efficient\n        pagination. Ex:\n      type: object\n      properties:\n        key:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: |-\n            key is a value returned in PageResponse.next_key to begin\n            querying the next page most efficiently. Only one of offset or key\n            should be set.\n          format: byte\n        offset:\n          type: string\n          description: |-\n            offset is a numeric offset that can be used when key is unavailable.\n            It is less efficient than using key. Only one of offset or key should\n            be set.\n          format: uint64\n        limit:\n          type: string\n          description: |-\n            limit is the total number of results to be returned in the result page.\n            If left empty it will default to a value to be set by each app.\n          format: uint64\n        count_total:\n          type: boolean\n          description: |-\n            count_total is set to true  to indicate that the result set should include\n            a count of the total number of items available for pagination in UIs.\n            count_total is only respected when offset is used. It is ignored when key\n            is set.\n          format: boolean\n        reverse:\n          type: boolean\n          description: |-\n            reverse is set to true if results are to be returned in the descending order.\n\n            Since: cosmos-sdk 0.43\n          format: boolean\n      description: |-\n        message SomeRequest {\n                 Foo some_parameter = 1;\n                 PageRequest pagination = 2;\n         }\n    cosmos.base.query.v1beta1.PageResponse:\n      type: object\n      properties:\n        next_key:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: |-\n            next_key is the key to be passed to PageRequest.key to\n            query the next page most efficiently. It will be empty if\n            there are no more results.\n          format: byte\n        total:\n          title: |-\n            total is total number of results available if PageRequest.count_total\n            was set, its value is undefined otherwise\n          type: string\n          format: uint64\n      description: |-\n        PageResponse is to be embedded in gRPC response messages where the\n        corresponding request message has used PageRequest.\n\n         message SomeResponse {\n                 repeated Bar results = 1;\n                 PageResponse page = 2;\n         }\n    google.protobuf.Any:\n      type: object\n      properties:\n        type_url:\n          type: string\n          description: |-\n            A URL/resource name that uniquely identifies the type of the serialized\n            protocol buffer message. This string must contain at least\n            one \"/\" character. The last segment of the URL's path must represent\n            the fully qualified name of the type (as in\n            `path/google.protobuf.Duration`). The name should be in a canonical form\n            (e.g., leading \".\" is not accepted).\n\n            In practice, teams usually precompile into the binary all types that they\n            expect it to use in the context of Any. However, for URLs which use the\n            scheme `http`, `https`, or no scheme, one can optionally set up a type\n            server that maps type URLs to message definitions as follows:\n\n            * If no scheme is provided, `https` is assumed.\n            * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n              value in binary format, or produce an error.\n            * Applications are allowed to cache lookup results based on the\n              URL, or have them precompiled into a binary to avoid any\n              lookup. Therefore, binary compatibility needs to be preserved\n              on changes to types. (Use versioned type names to manage\n              breaking changes.)\n\n            Note: this functionality is not currently available in the official\n            protobuf release, and it is not used for type URLs beginning with\n            type.googleapis.com.\n\n            Schemes other than `http`, `https` (or the empty scheme) might be\n            used with implementation specific semantics.\n        value:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: Must be a valid serialized protocol buffer of the above specified\n            type.\n          format: byte\n      description: |-\n        `Any` contains an arbitrary serialized protocol buffer message along with a\n        URL that describes the type of the serialized message.\n\n        Protobuf library provides support to pack/unpack Any values in the form\n        of utility functions or additional generated methods of the Any type.\n\n        Example 1: Pack and unpack a message in C++.\n\n            Foo foo = ...;\n            Any any;\n            any.PackFrom(foo);\n            ...\n            if (any.UnpackTo(\u0026foo)) {\n              ...\n            }\n\n        Example 2: Pack and unpack a message in Java.\n\n            Foo foo = ...;\n            Any any = Any.pack(foo);\n            ...\n            if (any.is(Foo.class)) {\n              foo = any.unpack(Foo.class);\n            }\n\n         Example 3: Pack and unpack a message in Python.\n\n            foo = Foo(...)\n            any = Any()\n            any.Pack(foo)\n            ...\n            if any.Is(Foo.DESCRIPTOR):\n              any.Unpack(foo)\n              ...\n\n         Example 4: Pack and unpack a message in Go\n\n             foo := \u0026pb.Foo{...}\n             any, err := ptypes.MarshalAny(foo)\n             ...\n             foo := \u0026pb.Foo{}\n             if err := ptypes.UnmarshalAny(any, foo); err != nil {\n               ...\n             }\n\n        The pack methods provided by protobuf library will by default use\n        'type.googleapis.com/full.type.name' as the type URL and the unpack\n        methods only use the fully qualified type name after the last '/'\n        in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n        name \"y.z\".\n\n\n        JSON\n        ====\n        The JSON representation of an `Any` value uses the regular\n        representation of the deserialized, embedded message, with an\n        additional field `@type` which contains the type URL. Example:\n\n            package google.profile;\n            message Person {\n              string first_name = 1;\n              string last_name = 2;\n            }\n\n            {\n              \"@type\": \"type.googleapis.com/google.profile.Person\",\n              \"firstName\": \u003cstring\u003e,\n              \"lastName\": \u003cstring\u003e\n            }\n\n        If the embedded message type is well-known and has a custom JSON\n        representation, that representation will be embedded adding a field\n        `value` which holds the custom JSON in addition to the `@type`\n        field. Example (for message [google.protobuf.Duration][]):\n\n            {\n              \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n              \"value\": \"1.212s\"\n            }\n    grpc.gateway.runtime.Error:\n      type: object\n      properties:\n        error:\n          type: string\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n        details:\n          type: array\n          items:\n            type: object\n            properties:\n              type_url:\n                type: string\n                description: |-\n                  A URL/resource name that uniquely identifies the type of the serialized\n                  protocol buffer message. This string must contain at least\n                  one \"/\" character. The last segment of the URL's path must represent\n                  the fully qualified name of the type (as in\n                  `path/google.protobuf.Duration`). The name should be in a canonical form\n                  (e.g., leading \".\" is not accepted).\n\n                  In practice, teams usually precompile into the binary all types that they\n                  expect it to use in the context of Any. However, for URLs which use the\n                  scheme `http`, `https`, or no scheme, one can optionally set up a type\n                  server that maps type URLs to message definitions as follows:\n\n                  * If no scheme is provided, `https` is assumed.\n                  * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                    value in binary format, or produce an error.\n                  * Applications are allowed to cache lookup results based on the\n                    URL, or have them precompiled into a binary to avoid any\n                    lookup. Therefore, binary compatibility needs to be preserved\n                    on changes to types. (Use versioned type names to manage\n                    breaking changes.)\n\n                  Note: this functionality is not currently available in the official\n                  protobuf release, and it is not used for type URLs beginning with\n                  type.googleapis.com.\n\n                  Schemes other than `http`, `https` (or the empty scheme) might be\n                  used with implementation specific semantics.\n              value:\n                pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                type: string\n                description: Must be a valid serialized protocol buffer of the above\n                  specified type.\n                format: byte\n            description: |-\n              `Any` contains an arbitrary serialized protocol buffer message along with a\n              URL that describes the type of the serialized message.\n\n              Protobuf library provides support to pack/unpack Any values in the form\n              of utility functions or additional generated methods of the Any type.\n\n              Example 1: Pack and unpack a message in C++.\n\n                  Foo foo = ...;\n                  Any any;\n                  any.PackFrom(foo);\n                  ...\n                  if (any.UnpackTo(\u0026foo)) {\n                    ...\n                  }\n\n              Example 2: Pack and unpack a message in Java.\n\n                  Foo foo = ...;\n                  Any any = Any.pack(foo);\n                  ...\n                  if (any.is(Foo.class)) {\n                    foo = any.unpack(Foo.class);\n                  }\n\n               Example 3: Pack and unpack a message in Python.\n\n                  foo = Foo(...)\n                  any = Any()\n                  any.Pack(foo)\n                  ...\n                  if any.Is(Foo.DESCRIPTOR):\n                    any.Unpack(foo)\n                    ...\n\n               Example 4: Pack and unpack a message in Go\n\n                   foo := \u0026pb.Foo{...}\n                   any, err := ptypes.MarshalAny(foo)\n                   ...\n                   foo := \u0026pb.Foo{}\n                   if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                     ...\n                   }\n\n              The pack methods provided by protobuf library will by default use\n              'type.googleapis.com/full.type.name' as the type URL and the unpack\n              methods only use the fully qualified type name after the last '/'\n              in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n              name \"y.z\".\n\n\n              JSON\n              ====\n              The JSON representation of an `Any` value uses the regular\n              representation of the deserialized, embedded message, with an\n              additional field `@type` which contains the type URL. Example:\n\n                  package google.profile;\n                  message Person {\n                    string first_name = 1;\n                    string last_name = 2;\n                  }\n\n                  {\n                    \"@type\": \"type.googleapis.com/google.profile.Person\",\n                    \"firstName\": \u003cstring\u003e,\n                    \"lastName\": \u003cstring\u003e\n                  }\n\n              If the embedded message type is well-known and has a custom JSON\n              representation, that representation will be embedded adding a field\n              `value` which holds the custom JSON in addition to the `@type`\n              field. Example (for message [google.protobuf.Duration][]):\n\n                  {\n                    \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                    \"value\": \"1.212s\"\n                  }\n    ibc.applications.transfer.v1.DenomTrace:\n      type: object\n      properties:\n        path:\n          type: string\n          description: |-\n            path defines the chain of port/channel identifiers used for tracing the\n            source of the fungible token.\n        base_denom:\n          type: string\n          description: base denomination of the relayed fungible token.\n      description: |-\n        DenomTrace contains the base denomination for ICS20 fungible tokens and the\n        source tracing information path.\n    ibc.applications.transfer.v1.Params:\n      type: object\n      properties:\n        send_enabled:\n          type: boolean\n          description: |-\n            send_enabled enables or disables all cross-chain token transfers from this\n            chain.\n          format: boolean\n        receive_enabled:\n          type: boolean\n          description: |-\n            receive_enabled enables or disables all cross-chain token transfers to this\n            chain.\n          format: boolean\n      description: |-\n        Params defines the set of IBC transfer parameters.\n        NOTE: To prevent a single token from being transferred, set the\n        TransfersEnabled parameter to true and then set the bank module's SendEnabled\n        parameter for the denomination to false.\n    ibc.applications.transfer.v1.QueryDenomHashResponse:\n      type: object\n      properties:\n        hash:\n          type: string\n          description: hash (in hex format) of the denomination trace information.\n      description: |-\n        QueryDenomHashResponse is the response type for the Query/DenomHash RPC\n        method.\n    ibc.applications.transfer.v1.QueryDenomTraceResponse:\n      type: object\n      properties:\n        denom_trace:\n          type: object\n          properties:\n            path:\n              type: string\n              description: |-\n                path defines the chain of port/channel identifiers used for tracing the\n                source of the fungible token.\n            base_denom:\n              type: string\n              description: base denomination of the relayed fungible token.\n          description: |-\n            DenomTrace contains the base denomination for ICS20 fungible tokens and the\n            source tracing information path.\n      description: |-\n        QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\n        method.\n    ibc.applications.transfer.v1.QueryDenomTracesResponse:\n      type: object\n      properties:\n        denom_traces:\n          type: array\n          description: denom_traces returns all denominations trace information.\n          items:\n            type: object\n            properties:\n              path:\n                type: string\n                description: |-\n                  path defines the chain of port/channel identifiers used for tracing the\n                  source of the fungible token.\n              base_denom:\n                type: string\n                description: base denomination of the relayed fungible token.\n            description: |-\n              DenomTrace contains the base denomination for ICS20 fungible tokens and the\n              source tracing information path.\n        pagination:\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: pagination defines the pagination in the response.\n      description: |-\n        QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\n        method.\n    ibc.applications.transfer.v1.QueryEscrowAddressResponse:\n      type: object\n      properties:\n        escrow_address:\n          title: the escrow account address\n          type: string\n      description: QueryEscrowAddressResponse is the response type of the EscrowAddress\n        RPC method.\n    ibc.applications.transfer.v1.QueryParamsResponse:\n      type: object\n      properties:\n        params:\n          type: object\n          properties:\n            send_enabled:\n              type: boolean\n              description: |-\n                send_enabled enables or disables all cross-chain token transfers from this\n                chain.\n              format: boolean\n            receive_enabled:\n              type: boolean\n              description: |-\n                receive_enabled enables or disables all cross-chain token transfers to this\n                chain.\n              format: boolean\n          description: params defines the parameters of the module.\n      description: QueryParamsResponse is the response type for the Query/Params RPC\n        method.\n    ibc.applications.interchain_accounts.controller.v1.Params:\n      type: object\n      properties:\n        controller_enabled:\n          type: boolean\n          description: controller_enabled enables or disables the controller submodule.\n          format: boolean\n      description: |-\n        Params defines the set of on-chain interchain accounts parameters.\n        The following parameters may be used to disable the controller submodule.\n    ibc.applications.interchain_accounts.controller.v1.QueryInterchainAccountResponse:\n      type: object\n      properties:\n        address:\n          type: string\n      description: QueryInterchainAccountResponse the response type for the Query/InterchainAccount\n        RPC method.\n    ibc.applications.interchain_accounts.controller.v1.QueryParamsResponse:\n      type: object\n      properties:\n        params:\n          type: object\n          properties:\n            controller_enabled:\n              type: boolean\n              description: controller_enabled enables or disables the controller submodule.\n              format: boolean\n          description: params defines the parameters of the module.\n      description: QueryParamsResponse is the response type for the Query/Params RPC\n        method.\n    ibc.applications.interchain_accounts.host.v1.Params:\n      type: object\n      properties:\n        host_enabled:\n          type: boolean\n          description: host_enabled enables or disables the host submodule.\n          format: boolean\n        allow_messages:\n          type: array\n          description: allow_messages defines a list of sdk message typeURLs allowed\n            to be executed on a host chain.\n          items:\n            type: string\n      description: |-\n        Params defines the set of on-chain interchain accounts parameters.\n        The following parameters may be used to disable the host submodule.\n    ibc.applications.interchain_accounts.host.v1.QueryParamsResponse:\n      type: object\n      properties:\n        params:\n          type: object\n          properties:\n            host_enabled:\n              type: boolean\n              description: host_enabled enables or disables the host submodule.\n              format: boolean\n            allow_messages:\n              type: array\n              description: allow_messages defines a list of sdk message typeURLs allowed\n                to be executed on a host chain.\n              items:\n                type: string\n          description: params defines the parameters of the module.\n      description: QueryParamsResponse is the response type for the Query/Params RPC\n        method.\n    cosmos.base.v1beta1.Coin:\n      type: object\n      properties:\n        denom:\n          type: string\n        amount:\n          type: string\n      description: |-\n        Coin defines a token with a denomination and an amount.\n\n        NOTE: The amount field is an Int which implements the custom method\n        signatures required by gogoproto.\n    ibc.applications.fee.v1.Fee:\n      title: Fee defines the ICS29 receive, acknowledgement and timeout fees\n      type: object\n      properties:\n        recv_fee:\n          title: the packet receive fee\n          type: array\n          items:\n            type: object\n            properties:\n              denom:\n                type: string\n              amount:\n                type: string\n            description: |-\n              Coin defines a token with a denomination and an amount.\n\n              NOTE: The amount field is an Int which implements the custom method\n              signatures required by gogoproto.\n        ack_fee:\n          title: the packet acknowledgement fee\n          type: array\n          items:\n            type: object\n            properties:\n              denom:\n                type: string\n              amount:\n                type: string\n            description: |-\n              Coin defines a token with a denomination and an amount.\n\n              NOTE: The amount field is an Int which implements the custom method\n              signatures required by gogoproto.\n        timeout_fee:\n          title: the packet timeout fee\n          type: array\n          items:\n            type: object\n            properties:\n              denom:\n                type: string\n              amount:\n                type: string\n            description: |-\n              Coin defines a token with a denomination and an amount.\n\n              NOTE: The amount field is an Int which implements the custom method\n              signatures required by gogoproto.\n    ibc.applications.fee.v1.FeeEnabledChannel:\n      title: FeeEnabledChannel contains the PortID \u0026 ChannelID for a fee enabled channel\n      type: object\n      properties:\n        port_id:\n          title: unique port identifier\n          type: string\n        channel_id:\n          title: unique channel identifier\n          type: string\n    ibc.applications.fee.v1.IdentifiedPacketFees:\n      title: IdentifiedPacketFees contains a list of type PacketFee and associated\n        PacketId\n      type: object\n      properties:\n        packet_id:\n          title: unique packet identifier comprised of the channel ID, port ID and\n            sequence\n          type: object\n          properties:\n            port_id:\n              title: channel port identifier\n              type: string\n            channel_id:\n              title: channel unique identifier\n              type: string\n            sequence:\n              title: packet sequence\n              type: string\n              format: uint64\n        packet_fees:\n          title: list of packet fees\n          type: array\n          items:\n            title: PacketFee contains ICS29 relayer fees, refund address and optional\n              list of permitted relayers\n            type: object\n            properties:\n              fee:\n                title: fee encapsulates the recv, ack and timeout fees associated\n                  with an IBC packet\n                type: object\n                properties:\n                  recv_fee:\n                    title: the packet receive fee\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        denom:\n                          type: string\n                        amount:\n                          type: string\n                      description: |-\n                        Coin defines a token with a denomination and an amount.\n\n                        NOTE: The amount field is an Int which implements the custom method\n                        signatures required by gogoproto.\n                  ack_fee:\n                    title: the packet acknowledgement fee\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        denom:\n                          type: string\n                        amount:\n                          type: string\n                      description: |-\n                        Coin defines a token with a denomination and an amount.\n\n                        NOTE: The amount field is an Int which implements the custom method\n                        signatures required by gogoproto.\n                  timeout_fee:\n                    title: the packet timeout fee\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        denom:\n                          type: string\n                        amount:\n                          type: string\n                      description: |-\n                        Coin defines a token with a denomination and an amount.\n\n                        NOTE: The amount field is an Int which implements the custom method\n                        signatures required by gogoproto.\n              refund_address:\n                title: the refund address for unspent fees\n                type: string\n              relayers:\n                title: optional list of relayers permitted to receive fees\n                type: array\n                items:\n                  type: string\n    ibc.applications.fee.v1.PacketFee:\n      title: PacketFee contains ICS29 relayer fees, refund address and optional list\n        of permitted relayers\n      type: object\n      properties:\n        fee:\n          title: fee encapsulates the recv, ack and timeout fees associated with an\n            IBC packet\n          type: object\n          properties:\n            recv_fee:\n              title: the packet receive fee\n              type: array\n              items:\n                type: object\n                properties:\n                  denom:\n                    type: string\n                  amount:\n                    type: string\n                description: |-\n                  Coin defines a token with a denomination and an amount.\n\n                  NOTE: The amount field is an Int which implements the custom method\n                  signatures required by gogoproto.\n            ack_fee:\n              title: the packet acknowledgement fee\n              type: array\n              items:\n                type: object\n                properties:\n                  denom:\n                    type: string\n                  amount:\n                    type: string\n                description: |-\n                  Coin defines a token with a denomination and an amount.\n\n                  NOTE: The amount field is an Int which implements the custom method\n                  signatures required by gogoproto.\n            timeout_fee:\n              title: the packet timeout fee\n              type: array\n              items:\n                type: object\n                properties:\n                  denom:\n                    type: string\n                  amount:\n                    type: string\n                description: |-\n                  Coin defines a token with a denomination and an amount.\n\n                  NOTE: The amount field is an Int which implements the custom method\n                  signatures required by gogoproto.\n        refund_address:\n          title: the refund address for unspent fees\n          type: string\n        relayers:\n          title: optional list of relayers permitted to receive fees\n          type: array\n          items:\n            type: string\n    ibc.applications.fee.v1.QueryCounterpartyPayeeResponse:\n      title: QueryCounterpartyPayeeResponse defines the response type for the CounterpartyPayee\n        rpc\n      type: object\n      properties:\n        counterparty_payee:\n          title: the counterparty payee address used to compensate forward relaying\n          type: string\n    ibc.applications.fee.v1.QueryFeeEnabledChannelResponse:\n      title: QueryFeeEnabledChannelResponse defines the response type for the FeeEnabledChannel\n        rpc\n      type: object\n      properties:\n        fee_enabled:\n          title: boolean flag representing the fee enabled channel status\n          type: boolean\n          format: boolean\n    ibc.applications.fee.v1.QueryFeeEnabledChannelsResponse:\n      title: QueryFeeEnabledChannelsResponse defines the response type for the FeeEnabledChannels\n        rpc\n      type: object\n      properties:\n        fee_enabled_channels:\n          title: list of fee enabled channels\n          type: array\n          items:\n            title: FeeEnabledChannel contains the PortID \u0026 ChannelID for a fee enabled\n              channel\n            type: object\n            properties:\n              port_id:\n                title: unique port identifier\n                type: string\n              channel_id:\n                title: unique channel identifier\n                type: string\n    ibc.applications.fee.v1.QueryIncentivizedPacketResponse:\n      title: QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPacket\n        rpc\n      type: object\n      properties:\n        incentivized_packet:\n          title: IdentifiedPacketFees contains a list of type PacketFee and associated\n            PacketId\n          type: object\n          properties:\n            packet_id:\n              title: unique packet identifier comprised of the channel ID, port ID\n                and sequence\n              type: object\n              properties:\n                port_id:\n                  title: channel port identifier\n                  type: string\n                channel_id:\n                  title: channel unique identifier\n                  type: string\n                sequence:\n                  title: packet sequence\n                  type: string\n                  format: uint64\n            packet_fees:\n              title: list of packet fees\n              type: array\n              items:\n                title: PacketFee contains ICS29 relayer fees, refund address and optional\n                  list of permitted relayers\n                type: object\n                properties:\n                  fee:\n                    title: fee encapsulates the recv, ack and timeout fees associated\n                      with an IBC packet\n                    type: object\n                    properties:\n                      recv_fee:\n                        title: the packet receive fee\n                        type: array\n                        items:\n                          type: object\n                          properties:\n                            denom:\n                              type: string\n                            amount:\n                              type: string\n                          description: |-\n                            Coin defines a token with a denomination and an amount.\n\n                            NOTE: The amount field is an Int which implements the custom method\n                            signatures required by gogoproto.\n                      ack_fee:\n                        title: the packet acknowledgement fee\n                        type: array\n                        items:\n                          type: object\n                          properties:\n                            denom:\n                              type: string\n                            amount:\n                              type: string\n                          description: |-\n                            Coin defines a token with a denomination and an amount.\n\n                            NOTE: The amount field is an Int which implements the custom method\n                            signatures required by gogoproto.\n                      timeout_fee:\n                        title: the packet timeout fee\n                        type: array\n                        items:\n                          type: object\n                          properties:\n                            denom:\n                              type: string\n                            amount:\n                              type: string\n                          description: |-\n                            Coin defines a token with a denomination and an amount.\n\n                            NOTE: The amount field is an Int which implements the custom method\n                            signatures required by gogoproto.\n                  refund_address:\n                    title: the refund address for unspent fees\n                    type: string\n                  relayers:\n                    title: optional list of relayers permitted to receive fees\n                    type: array\n                    items:\n                      type: string\n    ibc.applications.fee.v1.QueryIncentivizedPacketsForChannelResponse:\n      title: QueryIncentivizedPacketsResponse defines the response type for the incentivized\n        packets RPC\n      type: object\n      properties:\n        incentivized_packets:\n          title: Map of all incentivized_packets\n          type: array\n          items:\n            title: IdentifiedPacketFees contains a list of type PacketFee and associated\n              PacketId\n            type: object\n            properties:\n              packet_id:\n                title: unique packet identifier comprised of the channel ID, port\n                  ID and sequence\n                type: object\n                properties:\n                  port_id:\n                    title: channel port identifier\n                    type: string\n                  channel_id:\n                    title: channel unique identifier\n                    type: string\n                  sequence:\n                    title: packet sequence\n                    type: string\n                    format: uint64\n              packet_fees:\n                title: list of packet fees\n                type: array\n                items:\n                  title: PacketFee contains ICS29 relayer fees, refund address and\n                    optional list of permitted relayers\n                  type: object\n                  properties:\n                    fee:\n                      title: fee encapsulates the recv, ack and timeout fees associated\n                        with an IBC packet\n                      type: object\n                      properties:\n                        recv_fee:\n                          title: the packet receive fee\n                          type: array\n                          items:\n                            type: object\n                            properties:\n                              denom:\n                                type: string\n                              amount:\n                                type: string\n                            description: |-\n                              Coin defines a token with a denomination and an amount.\n\n                              NOTE: The amount field is an Int which implements the custom method\n                              signatures required by gogoproto.\n                        ack_fee:\n                          title: the packet acknowledgement fee\n                          type: array\n                          items:\n                            type: object\n                            properties:\n                              denom:\n                                type: string\n                              amount:\n                                type: string\n                            description: |-\n                              Coin defines a token with a denomination and an amount.\n\n                              NOTE: The amount field is an Int which implements the custom method\n                              signatures required by gogoproto.\n                        timeout_fee:\n                          title: the packet timeout fee\n                          type: array\n                          items:\n                            type: object\n                            properties:\n                              denom:\n                                type: string\n                              amount:\n                                type: string\n                            description: |-\n                              Coin defines a token with a denomination and an amount.\n\n                              NOTE: The amount field is an Int which implements the custom method\n                              signatures required by gogoproto.\n                    refund_address:\n                      title: the refund address for unspent fees\n                      type: string\n                    relayers:\n                      title: optional list of relayers permitted to receive fees\n                      type: array\n                      items:\n                        type: string\n    ibc.applications.fee.v1.QueryIncentivizedPacketsResponse:\n      title: QueryIncentivizedPacketsResponse defines the response type for the IncentivizedPackets\n        rpc\n      type: object\n      properties:\n        incentivized_packets:\n          title: list of identified fees for incentivized packets\n          type: array\n          items:\n            title: IdentifiedPacketFees contains a list of type PacketFee and associated\n              PacketId\n            type: object\n            properties:\n              packet_id:\n                title: unique packet identifier comprised of the channel ID, port\n                  ID and sequence\n                type: object\n                properties:\n                  port_id:\n                    title: channel port identifier\n                    type: string\n                  channel_id:\n                    title: channel unique identifier\n                    type: string\n                  sequence:\n                    title: packet sequence\n                    type: string\n                    format: uint64\n              packet_fees:\n                title: list of packet fees\n                type: array\n                items:\n                  title: PacketFee contains ICS29 relayer fees, refund address and\n                    optional list of permitted relayers\n                  type: object\n                  properties:\n                    fee:\n                      title: fee encapsulates the recv, ack and timeout fees associated\n                        with an IBC packet\n                      type: object\n                      properties:\n                        recv_fee:\n                          title: the packet receive fee\n                          type: array\n                          items:\n                            type: object\n                            properties:\n                              denom:\n                                type: string\n                              amount:\n                                type: string\n                            description: |-\n                              Coin defines a token with a denomination and an amount.\n\n                              NOTE: The amount field is an Int which implements the custom method\n                              signatures required by gogoproto.\n                        ack_fee:\n                          title: the packet acknowledgement fee\n                          type: array\n                          items:\n                            type: object\n                            properties:\n                              denom:\n                                type: string\n                              amount:\n                                type: string\n                            description: |-\n                              Coin defines a token with a denomination and an amount.\n\n                              NOTE: The amount field is an Int which implements the custom method\n                              signatures required by gogoproto.\n                        timeout_fee:\n                          title: the packet timeout fee\n                          type: array\n                          items:\n                            type: object\n                            properties:\n                              denom:\n                                type: string\n                              amount:\n                                type: string\n                            description: |-\n                              Coin defines a token with a denomination and an amount.\n\n                              NOTE: The amount field is an Int which implements the custom method\n                              signatures required by gogoproto.\n                    refund_address:\n                      title: the refund address for unspent fees\n                      type: string\n                    relayers:\n                      title: optional list of relayers permitted to receive fees\n                      type: array\n                      items:\n                        type: string\n    ibc.applications.fee.v1.QueryPayeeResponse:\n      title: QueryPayeeResponse defines the response type for the Payee rpc\n      type: object\n      properties:\n        payee_address:\n          title: the payee address to which packet fees are paid out\n          type: string\n    ibc.applications.fee.v1.QueryTotalAckFeesResponse:\n      title: QueryTotalAckFeesResponse defines the response type for the TotalAckFees\n        rpc\n      type: object\n      properties:\n        ack_fees:\n          title: the total packet acknowledgement fees\n          type: array\n          items:\n            type: object\n            properties:\n              denom:\n                type: string\n              amount:\n                type: string\n            description: |-\n              Coin defines a token with a denomination and an amount.\n\n              NOTE: The amount field is an Int which implements the custom method\n              signatures required by gogoproto.\n    ibc.applications.fee.v1.QueryTotalRecvFeesResponse:\n      title: QueryTotalRecvFeesResponse defines the response type for the TotalRecvFees\n        rpc\n      type: object\n      properties:\n        recv_fees:\n          title: the total packet receive fees\n          type: array\n          items:\n            type: object\n            properties:\n              denom:\n                type: string\n              amount:\n                type: string\n            description: |-\n              Coin defines a token with a denomination and an amount.\n\n              NOTE: The amount field is an Int which implements the custom method\n              signatures required by gogoproto.\n    ibc.applications.fee.v1.QueryTotalTimeoutFeesResponse:\n      title: QueryTotalTimeoutFeesResponse defines the response type for the TotalTimeoutFees\n        rpc\n      type: object\n      properties:\n        timeout_fees:\n          title: the total packet timeout fees\n          type: array\n          items:\n            type: object\n            properties:\n              denom:\n                type: string\n              amount:\n                type: string\n            description: |-\n              Coin defines a token with a denomination and an amount.\n\n              NOTE: The amount field is an Int which implements the custom method\n              signatures required by gogoproto.\n    ibc.core.channel.v1.PacketId:\n      title: |-\n        PacketId is an identifer for a unique Packet\n        Source chains refer to packets by source port/channel\n        Destination chains refer to packets by destination port/channel\n      type: object\n      properties:\n        port_id:\n          title: channel port identifier\n          type: string\n        channel_id:\n          title: channel unique identifier\n          type: string\n        sequence:\n          title: packet sequence\n          type: string\n          format: uint64\n    ibc.core.client.v1.ConsensusStateWithHeight:\n      type: object\n      properties:\n        height:\n          title: consensus state height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n        consensus_state:\n          title: consensus state\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n      description: |-\n        ConsensusStateWithHeight defines a consensus state with an additional height\n        field.\n    ibc.core.client.v1.Height:\n      title: |-\n        Height is a monotonically increasing data type\n        that can be compared against another Height for the purposes of updating and\n        freezing clients\n      type: object\n      properties:\n        revision_number:\n          title: the revision that the client is currently on\n          type: string\n          format: uint64\n        revision_height:\n          title: the height within the given revision\n          type: string\n          format: uint64\n      description: |-\n        Normally the RevisionHeight is incremented at each height while keeping\n        RevisionNumber the same. However some consensus algorithms may choose to\n        reset the height in certain conditions e.g. hard forks, state-machine\n        breaking changes In these cases, the RevisionNumber is incremented so that\n        height continues to be monitonically increasing even as the RevisionHeight\n        gets reset\n    ibc.core.client.v1.IdentifiedClientState:\n      type: object\n      properties:\n        client_id:\n          title: client identifier\n          type: string\n        client_state:\n          title: client state\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n      description: |-\n        IdentifiedClientState defines a client state with an additional client\n        identifier field.\n    ibc.core.client.v1.Params:\n      type: object\n      properties:\n        allowed_clients:\n          type: array\n          description: allowed_clients defines the list of allowed client state types.\n          items:\n            type: string\n      description: Params defines the set of IBC light client parameters.\n    ibc.core.client.v1.QueryClientParamsResponse:\n      type: object\n      properties:\n        params:\n          type: object\n          properties:\n            allowed_clients:\n              type: array\n              description: allowed_clients defines the list of allowed client state\n                types.\n              items:\n                type: string\n          description: params defines the parameters of the module.\n      description: |-\n        QueryClientParamsResponse is the response type for the Query/ClientParams RPC\n        method.\n    ibc.core.client.v1.QueryClientStateResponse:\n      type: object\n      properties:\n        client_state:\n          title: client state associated with the request identifier\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n      description: |-\n        QueryClientStateResponse is the response type for the Query/ClientState RPC\n        method. Besides the client state, it includes a proof and the height from\n        which the proof was retrieved.\n    ibc.core.client.v1.QueryClientStatesResponse:\n      type: object\n      properties:\n        client_states:\n          type: array\n          description: list of stored ClientStates of the chain.\n          items:\n            type: object\n            properties:\n              client_id:\n                title: client identifier\n                type: string\n              client_state:\n                title: client state\n                type: object\n                properties:\n                  type_url:\n                    type: string\n                    description: |-\n                      A URL/resource name that uniquely identifies the type of the serialized\n                      protocol buffer message. This string must contain at least\n                      one \"/\" character. The last segment of the URL's path must represent\n                      the fully qualified name of the type (as in\n                      `path/google.protobuf.Duration`). The name should be in a canonical form\n                      (e.g., leading \".\" is not accepted).\n\n                      In practice, teams usually precompile into the binary all types that they\n                      expect it to use in the context of Any. However, for URLs which use the\n                      scheme `http`, `https`, or no scheme, one can optionally set up a type\n                      server that maps type URLs to message definitions as follows:\n\n                      * If no scheme is provided, `https` is assumed.\n                      * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                        value in binary format, or produce an error.\n                      * Applications are allowed to cache lookup results based on the\n                        URL, or have them precompiled into a binary to avoid any\n                        lookup. Therefore, binary compatibility needs to be preserved\n                        on changes to types. (Use versioned type names to manage\n                        breaking changes.)\n\n                      Note: this functionality is not currently available in the official\n                      protobuf release, and it is not used for type URLs beginning with\n                      type.googleapis.com.\n\n                      Schemes other than `http`, `https` (or the empty scheme) might be\n                      used with implementation specific semantics.\n                  value:\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    description: Must be a valid serialized protocol buffer of the\n                      above specified type.\n                    format: byte\n                description: |-\n                  `Any` contains an arbitrary serialized protocol buffer message along with a\n                  URL that describes the type of the serialized message.\n\n                  Protobuf library provides support to pack/unpack Any values in the form\n                  of utility functions or additional generated methods of the Any type.\n\n                  Example 1: Pack and unpack a message in C++.\n\n                      Foo foo = ...;\n                      Any any;\n                      any.PackFrom(foo);\n                      ...\n                      if (any.UnpackTo(\u0026foo)) {\n                        ...\n                      }\n\n                  Example 2: Pack and unpack a message in Java.\n\n                      Foo foo = ...;\n                      Any any = Any.pack(foo);\n                      ...\n                      if (any.is(Foo.class)) {\n                        foo = any.unpack(Foo.class);\n                      }\n\n                   Example 3: Pack and unpack a message in Python.\n\n                      foo = Foo(...)\n                      any = Any()\n                      any.Pack(foo)\n                      ...\n                      if any.Is(Foo.DESCRIPTOR):\n                        any.Unpack(foo)\n                        ...\n\n                   Example 4: Pack and unpack a message in Go\n\n                       foo := \u0026pb.Foo{...}\n                       any, err := ptypes.MarshalAny(foo)\n                       ...\n                       foo := \u0026pb.Foo{}\n                       if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                         ...\n                       }\n\n                  The pack methods provided by protobuf library will by default use\n                  'type.googleapis.com/full.type.name' as the type URL and the unpack\n                  methods only use the fully qualified type name after the last '/'\n                  in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                  name \"y.z\".\n\n\n                  JSON\n                  ====\n                  The JSON representation of an `Any` value uses the regular\n                  representation of the deserialized, embedded message, with an\n                  additional field `@type` which contains the type URL. Example:\n\n                      package google.profile;\n                      message Person {\n                        string first_name = 1;\n                        string last_name = 2;\n                      }\n\n                      {\n                        \"@type\": \"type.googleapis.com/google.profile.Person\",\n                        \"firstName\": \u003cstring\u003e,\n                        \"lastName\": \u003cstring\u003e\n                      }\n\n                  If the embedded message type is well-known and has a custom JSON\n                  representation, that representation will be embedded adding a field\n                  `value` which holds the custom JSON in addition to the `@type`\n                  field. Example (for message [google.protobuf.Duration][]):\n\n                      {\n                        \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                        \"value\": \"1.212s\"\n                      }\n            description: |-\n              IdentifiedClientState defines a client state with an additional client\n              identifier field.\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n      description: |-\n        QueryClientStatesResponse is the response type for the Query/ClientStates RPC\n        method.\n    ibc.core.client.v1.QueryClientStatusResponse:\n      type: object\n      properties:\n        status:\n          type: string\n      description: |-\n        QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\n        method. It returns the current status of the IBC client.\n    ibc.core.client.v1.QueryConsensusStateHeightsResponse:\n      title: |-\n        QueryConsensusStateHeightsResponse is the response type for the\n        Query/ConsensusStateHeights RPC method\n      type: object\n      properties:\n        consensus_state_heights:\n          title: consensus state heights\n          type: array\n          items:\n            title: |-\n              Height is a monotonically increasing data type\n              that can be compared against another Height for the purposes of updating and\n              freezing clients\n            type: object\n            properties:\n              revision_number:\n                title: the revision that the client is currently on\n                type: string\n                format: uint64\n              revision_height:\n                title: the height within the given revision\n                type: string\n                format: uint64\n            description: |-\n              Normally the RevisionHeight is incremented at each height while keeping\n              RevisionNumber the same. However some consensus algorithms may choose to\n              reset the height in certain conditions e.g. hard forks, state-machine\n              breaking changes In these cases, the RevisionNumber is incremented so that\n              height continues to be monitonically increasing even as the RevisionHeight\n              gets reset\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n    ibc.core.client.v1.QueryConsensusStateResponse:\n      title: |-\n        QueryConsensusStateResponse is the response type for the Query/ConsensusState\n        RPC method\n      type: object\n      properties:\n        consensus_state:\n          title: consensus state associated with the client identifier at the given\n            height\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: |-\n            Height is a monotonically increasing data type\n            that can be compared against another Height for the purposes of updating and\n            freezing clients\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.client.v1.QueryConsensusStatesResponse:\n      title: |-\n        QueryConsensusStatesResponse is the response type for the\n        Query/ConsensusStates RPC method\n      type: object\n      properties:\n        consensus_states:\n          title: consensus states associated with the identifier\n          type: array\n          items:\n            type: object\n            properties:\n              height:\n                title: consensus state height\n                type: object\n                properties:\n                  revision_number:\n                    title: the revision that the client is currently on\n                    type: string\n                    format: uint64\n                  revision_height:\n                    title: the height within the given revision\n                    type: string\n                    format: uint64\n                description: |-\n                  Normally the RevisionHeight is incremented at each height while keeping\n                  RevisionNumber the same. However some consensus algorithms may choose to\n                  reset the height in certain conditions e.g. hard forks, state-machine\n                  breaking changes In these cases, the RevisionNumber is incremented so that\n                  height continues to be monitonically increasing even as the RevisionHeight\n                  gets reset\n              consensus_state:\n                title: consensus state\n                type: object\n                properties:\n                  type_url:\n                    type: string\n                    description: |-\n                      A URL/resource name that uniquely identifies the type of the serialized\n                      protocol buffer message. This string must contain at least\n                      one \"/\" character. The last segment of the URL's path must represent\n                      the fully qualified name of the type (as in\n                      `path/google.protobuf.Duration`). The name should be in a canonical form\n                      (e.g., leading \".\" is not accepted).\n\n                      In practice, teams usually precompile into the binary all types that they\n                      expect it to use in the context of Any. However, for URLs which use the\n                      scheme `http`, `https`, or no scheme, one can optionally set up a type\n                      server that maps type URLs to message definitions as follows:\n\n                      * If no scheme is provided, `https` is assumed.\n                      * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                        value in binary format, or produce an error.\n                      * Applications are allowed to cache lookup results based on the\n                        URL, or have them precompiled into a binary to avoid any\n                        lookup. Therefore, binary compatibility needs to be preserved\n                        on changes to types. (Use versioned type names to manage\n                        breaking changes.)\n\n                      Note: this functionality is not currently available in the official\n                      protobuf release, and it is not used for type URLs beginning with\n                      type.googleapis.com.\n\n                      Schemes other than `http`, `https` (or the empty scheme) might be\n                      used with implementation specific semantics.\n                  value:\n                    pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                    type: string\n                    description: Must be a valid serialized protocol buffer of the\n                      above specified type.\n                    format: byte\n                description: |-\n                  `Any` contains an arbitrary serialized protocol buffer message along with a\n                  URL that describes the type of the serialized message.\n\n                  Protobuf library provides support to pack/unpack Any values in the form\n                  of utility functions or additional generated methods of the Any type.\n\n                  Example 1: Pack and unpack a message in C++.\n\n                      Foo foo = ...;\n                      Any any;\n                      any.PackFrom(foo);\n                      ...\n                      if (any.UnpackTo(\u0026foo)) {\n                        ...\n                      }\n\n                  Example 2: Pack and unpack a message in Java.\n\n                      Foo foo = ...;\n                      Any any = Any.pack(foo);\n                      ...\n                      if (any.is(Foo.class)) {\n                        foo = any.unpack(Foo.class);\n                      }\n\n                   Example 3: Pack and unpack a message in Python.\n\n                      foo = Foo(...)\n                      any = Any()\n                      any.Pack(foo)\n                      ...\n                      if any.Is(Foo.DESCRIPTOR):\n                        any.Unpack(foo)\n                        ...\n\n                   Example 4: Pack and unpack a message in Go\n\n                       foo := \u0026pb.Foo{...}\n                       any, err := ptypes.MarshalAny(foo)\n                       ...\n                       foo := \u0026pb.Foo{}\n                       if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                         ...\n                       }\n\n                  The pack methods provided by protobuf library will by default use\n                  'type.googleapis.com/full.type.name' as the type URL and the unpack\n                  methods only use the fully qualified type name after the last '/'\n                  in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                  name \"y.z\".\n\n\n                  JSON\n                  ====\n                  The JSON representation of an `Any` value uses the regular\n                  representation of the deserialized, embedded message, with an\n                  additional field `@type` which contains the type URL. Example:\n\n                      package google.profile;\n                      message Person {\n                        string first_name = 1;\n                        string last_name = 2;\n                      }\n\n                      {\n                        \"@type\": \"type.googleapis.com/google.profile.Person\",\n                        \"firstName\": \u003cstring\u003e,\n                        \"lastName\": \u003cstring\u003e\n                      }\n\n                  If the embedded message type is well-known and has a custom JSON\n                  representation, that representation will be embedded adding a field\n                  `value` which holds the custom JSON in addition to the `@type`\n                  field. Example (for message [google.protobuf.Duration][]):\n\n                      {\n                        \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                        \"value\": \"1.212s\"\n                      }\n            description: |-\n              ConsensusStateWithHeight defines a consensus state with an additional height\n              field.\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n    ibc.core.client.v1.QueryUpgradedClientStateResponse:\n      type: object\n      properties:\n        upgraded_client_state:\n          title: client state associated with the request identifier\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n      description: |-\n        QueryUpgradedClientStateResponse is the response type for the\n        Query/UpgradedClientState RPC method.\n    ibc.core.client.v1.QueryUpgradedConsensusStateResponse:\n      type: object\n      properties:\n        upgraded_consensus_state:\n          title: Consensus state associated with the request identifier\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n      description: |-\n        QueryUpgradedConsensusStateResponse is the response type for the\n        Query/UpgradedConsensusState RPC method.\n    ibc.core.commitment.v1.MerklePrefix:\n      title: |-\n        MerklePrefix is merkle path prefixed to the key.\n        The constructed key from the Path and the key will be append(Path.KeyPath,\n        append(Path.KeyPrefix, key...))\n      type: object\n      properties:\n        key_prefix:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n    ibc.core.connection.v1.ConnectionEnd:\n      type: object\n      properties:\n        client_id:\n          type: string\n          description: client associated with this connection.\n        versions:\n          type: array\n          description: |-\n            IBC version which can be utilised to determine encodings or protocols for\n            channels or packets utilising this connection.\n          items:\n            type: object\n            properties:\n              identifier:\n                title: unique version identifier\n                type: string\n              features:\n                title: list of features compatible with the specified identifier\n                type: array\n                items:\n                  type: string\n            description: |-\n              Version defines the versioning scheme used to negotiate the IBC verison in\n              the connection handshake.\n        state:\n          type: string\n          description: current state of the connection end.\n          default: STATE_UNINITIALIZED_UNSPECIFIED\n          enum:\n          - STATE_UNINITIALIZED_UNSPECIFIED\n          - STATE_INIT\n          - STATE_TRYOPEN\n          - STATE_OPEN\n        counterparty:\n          type: object\n          properties:\n            client_id:\n              type: string\n              description: |-\n                identifies the client on the counterparty chain associated with a given\n                connection.\n            connection_id:\n              type: string\n              description: |-\n                identifies the connection end on the counterparty chain associated with a\n                given connection.\n            prefix:\n              title: |-\n                MerklePrefix is merkle path prefixed to the key.\n                The constructed key from the Path and the key will be append(Path.KeyPath,\n                append(Path.KeyPrefix, key...))\n              type: object\n              properties:\n                key_prefix:\n                  pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                  type: string\n                  format: byte\n              description: commitment merkle prefix of the counterparty chain.\n          description: counterparty chain associated with this connection.\n        delay_period:\n          type: string\n          description: |-\n            delay period that must pass before a consensus state can be used for\n            packet-verification NOTE: delay period logic is only implemented by some\n            clients.\n          format: uint64\n      description: |-\n        ConnectionEnd defines a stateful object on a chain connected to another\n        separate one.\n        NOTE: there must only be 2 defined ConnectionEnds to establish\n        a connection between two chains.\n    ibc.core.connection.v1.Counterparty:\n      type: object\n      properties:\n        client_id:\n          type: string\n          description: |-\n            identifies the client on the counterparty chain associated with a given\n            connection.\n        connection_id:\n          type: string\n          description: |-\n            identifies the connection end on the counterparty chain associated with a\n            given connection.\n        prefix:\n          title: |-\n            MerklePrefix is merkle path prefixed to the key.\n            The constructed key from the Path and the key will be append(Path.KeyPath,\n            append(Path.KeyPrefix, key...))\n          type: object\n          properties:\n            key_prefix:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              format: byte\n          description: commitment merkle prefix of the counterparty chain.\n      description: Counterparty defines the counterparty chain associated with a connection\n        end.\n    ibc.core.connection.v1.IdentifiedConnection:\n      type: object\n      properties:\n        id:\n          type: string\n          description: connection identifier.\n        client_id:\n          type: string\n          description: client associated with this connection.\n        versions:\n          title: |-\n            IBC version which can be utilised to determine encodings or protocols for\n            channels or packets utilising this connection\n          type: array\n          items:\n            type: object\n            properties:\n              identifier:\n                title: unique version identifier\n                type: string\n              features:\n                title: list of features compatible with the specified identifier\n                type: array\n                items:\n                  type: string\n            description: |-\n              Version defines the versioning scheme used to negotiate the IBC verison in\n              the connection handshake.\n        state:\n          type: string\n          description: current state of the connection end.\n          default: STATE_UNINITIALIZED_UNSPECIFIED\n          enum:\n          - STATE_UNINITIALIZED_UNSPECIFIED\n          - STATE_INIT\n          - STATE_TRYOPEN\n          - STATE_OPEN\n        counterparty:\n          type: object\n          properties:\n            client_id:\n              type: string\n              description: |-\n                identifies the client on the counterparty chain associated with a given\n                connection.\n            connection_id:\n              type: string\n              description: |-\n                identifies the connection end on the counterparty chain associated with a\n                given connection.\n            prefix:\n              title: |-\n                MerklePrefix is merkle path prefixed to the key.\n                The constructed key from the Path and the key will be append(Path.KeyPath,\n                append(Path.KeyPrefix, key...))\n              type: object\n              properties:\n                key_prefix:\n                  pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                  type: string\n                  format: byte\n              description: commitment merkle prefix of the counterparty chain.\n          description: counterparty chain associated with this connection.\n        delay_period:\n          type: string\n          description: delay period associated with this connection.\n          format: uint64\n      description: |-\n        IdentifiedConnection defines a connection with additional connection\n        identifier field.\n    ibc.core.connection.v1.QueryClientConnectionsResponse:\n      title: |-\n        QueryClientConnectionsResponse is the response type for the\n        Query/ClientConnections RPC method\n      type: object\n      properties:\n        connection_paths:\n          type: array\n          description: slice of all the connection paths associated with a client.\n          items:\n            type: string\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was generated\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.connection.v1.QueryConnectionClientStateResponse:\n      title: |-\n        QueryConnectionClientStateResponse is the response type for the\n        Query/ConnectionClientState RPC method\n      type: object\n      properties:\n        identified_client_state:\n          title: client state associated with the channel\n          type: object\n          properties:\n            client_id:\n              title: client identifier\n              type: string\n            client_state:\n              title: client state\n              type: object\n              properties:\n                type_url:\n                  type: string\n                  description: |-\n                    A URL/resource name that uniquely identifies the type of the serialized\n                    protocol buffer message. This string must contain at least\n                    one \"/\" character. The last segment of the URL's path must represent\n                    the fully qualified name of the type (as in\n                    `path/google.protobuf.Duration`). The name should be in a canonical form\n                    (e.g., leading \".\" is not accepted).\n\n                    In practice, teams usually precompile into the binary all types that they\n                    expect it to use in the context of Any. However, for URLs which use the\n                    scheme `http`, `https`, or no scheme, one can optionally set up a type\n                    server that maps type URLs to message definitions as follows:\n\n                    * If no scheme is provided, `https` is assumed.\n                    * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                      value in binary format, or produce an error.\n                    * Applications are allowed to cache lookup results based on the\n                      URL, or have them precompiled into a binary to avoid any\n                      lookup. Therefore, binary compatibility needs to be preserved\n                      on changes to types. (Use versioned type names to manage\n                      breaking changes.)\n\n                    Note: this functionality is not currently available in the official\n                    protobuf release, and it is not used for type URLs beginning with\n                    type.googleapis.com.\n\n                    Schemes other than `http`, `https` (or the empty scheme) might be\n                    used with implementation specific semantics.\n                value:\n                  pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                  type: string\n                  description: Must be a valid serialized protocol buffer of the above\n                    specified type.\n                  format: byte\n              description: |-\n                `Any` contains an arbitrary serialized protocol buffer message along with a\n                URL that describes the type of the serialized message.\n\n                Protobuf library provides support to pack/unpack Any values in the form\n                of utility functions or additional generated methods of the Any type.\n\n                Example 1: Pack and unpack a message in C++.\n\n                    Foo foo = ...;\n                    Any any;\n                    any.PackFrom(foo);\n                    ...\n                    if (any.UnpackTo(\u0026foo)) {\n                      ...\n                    }\n\n                Example 2: Pack and unpack a message in Java.\n\n                    Foo foo = ...;\n                    Any any = Any.pack(foo);\n                    ...\n                    if (any.is(Foo.class)) {\n                      foo = any.unpack(Foo.class);\n                    }\n\n                 Example 3: Pack and unpack a message in Python.\n\n                    foo = Foo(...)\n                    any = Any()\n                    any.Pack(foo)\n                    ...\n                    if any.Is(Foo.DESCRIPTOR):\n                      any.Unpack(foo)\n                      ...\n\n                 Example 4: Pack and unpack a message in Go\n\n                     foo := \u0026pb.Foo{...}\n                     any, err := ptypes.MarshalAny(foo)\n                     ...\n                     foo := \u0026pb.Foo{}\n                     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                       ...\n                     }\n\n                The pack methods provided by protobuf library will by default use\n                'type.googleapis.com/full.type.name' as the type URL and the unpack\n                methods only use the fully qualified type name after the last '/'\n                in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                name \"y.z\".\n\n\n                JSON\n                ====\n                The JSON representation of an `Any` value uses the regular\n                representation of the deserialized, embedded message, with an\n                additional field `@type` which contains the type URL. Example:\n\n                    package google.profile;\n                    message Person {\n                      string first_name = 1;\n                      string last_name = 2;\n                    }\n\n                    {\n                      \"@type\": \"type.googleapis.com/google.profile.Person\",\n                      \"firstName\": \u003cstring\u003e,\n                      \"lastName\": \u003cstring\u003e\n                    }\n\n                If the embedded message type is well-known and has a custom JSON\n                representation, that representation will be embedded adding a field\n                `value` which holds the custom JSON in addition to the `@type`\n                field. Example (for message [google.protobuf.Duration][]):\n\n                    {\n                      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                      \"value\": \"1.212s\"\n                    }\n          description: |-\n            IdentifiedClientState defines a client state with an additional client\n            identifier field.\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.connection.v1.QueryConnectionConsensusStateResponse:\n      title: |-\n        QueryConnectionConsensusStateResponse is the response type for the\n        Query/ConnectionConsensusState RPC method\n      type: object\n      properties:\n        consensus_state:\n          title: consensus state associated with the channel\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n        client_id:\n          title: client ID associated with the consensus state\n          type: string\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.connection.v1.QueryConnectionResponse:\n      type: object\n      properties:\n        connection:\n          title: connection associated with the request identifier\n          type: object\n          properties:\n            client_id:\n              type: string\n              description: client associated with this connection.\n            versions:\n              type: array\n              description: |-\n                IBC version which can be utilised to determine encodings or protocols for\n                channels or packets utilising this connection.\n              items:\n                type: object\n                properties:\n                  identifier:\n                    title: unique version identifier\n                    type: string\n                  features:\n                    title: list of features compatible with the specified identifier\n                    type: array\n                    items:\n                      type: string\n                description: |-\n                  Version defines the versioning scheme used to negotiate the IBC verison in\n                  the connection handshake.\n            state:\n              type: string\n              description: current state of the connection end.\n              default: STATE_UNINITIALIZED_UNSPECIFIED\n              enum:\n              - STATE_UNINITIALIZED_UNSPECIFIED\n              - STATE_INIT\n              - STATE_TRYOPEN\n              - STATE_OPEN\n            counterparty:\n              type: object\n              properties:\n                client_id:\n                  type: string\n                  description: |-\n                    identifies the client on the counterparty chain associated with a given\n                    connection.\n                connection_id:\n                  type: string\n                  description: |-\n                    identifies the connection end on the counterparty chain associated with a\n                    given connection.\n                prefix:\n                  title: |-\n                    MerklePrefix is merkle path prefixed to the key.\n                    The constructed key from the Path and the key will be append(Path.KeyPath,\n                    append(Path.KeyPrefix, key...))\n                  type: object\n                  properties:\n                    key_prefix:\n                      pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                      type: string\n                      format: byte\n                  description: commitment merkle prefix of the counterparty chain.\n              description: counterparty chain associated with this connection.\n            delay_period:\n              type: string\n              description: |-\n                delay period that must pass before a consensus state can be used for\n                packet-verification NOTE: delay period logic is only implemented by some\n                clients.\n              format: uint64\n          description: |-\n            ConnectionEnd defines a stateful object on a chain connected to another\n            separate one.\n            NOTE: there must only be 2 defined ConnectionEnds to establish\n            a connection between two chains.\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n      description: |-\n        QueryConnectionResponse is the response type for the Query/Connection RPC\n        method. Besides the connection end, it includes a proof and the height from\n        which the proof was retrieved.\n    ibc.core.connection.v1.QueryConnectionsResponse:\n      type: object\n      properties:\n        connections:\n          type: array\n          description: list of stored connections of the chain.\n          items:\n            type: object\n            properties:\n              id:\n                type: string\n                description: connection identifier.\n              client_id:\n                type: string\n                description: client associated with this connection.\n              versions:\n                title: |-\n                  IBC version which can be utilised to determine encodings or protocols for\n                  channels or packets utilising this connection\n                type: array\n                items:\n                  type: object\n                  properties:\n                    identifier:\n                      title: unique version identifier\n                      type: string\n                    features:\n                      title: list of features compatible with the specified identifier\n                      type: array\n                      items:\n                        type: string\n                  description: |-\n                    Version defines the versioning scheme used to negotiate the IBC verison in\n                    the connection handshake.\n              state:\n                type: string\n                description: current state of the connection end.\n                default: STATE_UNINITIALIZED_UNSPECIFIED\n                enum:\n                - STATE_UNINITIALIZED_UNSPECIFIED\n                - STATE_INIT\n                - STATE_TRYOPEN\n                - STATE_OPEN\n              counterparty:\n                type: object\n                properties:\n                  client_id:\n                    type: string\n                    description: |-\n                      identifies the client on the counterparty chain associated with a given\n                      connection.\n                  connection_id:\n                    type: string\n                    description: |-\n                      identifies the connection end on the counterparty chain associated with a\n                      given connection.\n                  prefix:\n                    title: |-\n                      MerklePrefix is merkle path prefixed to the key.\n                      The constructed key from the Path and the key will be append(Path.KeyPath,\n                      append(Path.KeyPrefix, key...))\n                    type: object\n                    properties:\n                      key_prefix:\n                        pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                        type: string\n                        format: byte\n                    description: commitment merkle prefix of the counterparty chain.\n                description: counterparty chain associated with this connection.\n              delay_period:\n                type: string\n                description: delay period associated with this connection.\n                format: uint64\n            description: |-\n              IdentifiedConnection defines a connection with additional connection\n              identifier field.\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n        height:\n          title: query block height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n      description: |-\n        QueryConnectionsResponse is the response type for the Query/Connections RPC\n        method.\n    ibc.core.connection.v1.State:\n      type: string\n      description: |-\n        State defines if a connection is in one of the following states:\n        INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n         - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n         - STATE_INIT: A connection end has just started the opening handshake.\n         - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty\n        chain.\n         - STATE_OPEN: A connection end has completed the handshake.\n      default: STATE_UNINITIALIZED_UNSPECIFIED\n      enum:\n      - STATE_UNINITIALIZED_UNSPECIFIED\n      - STATE_INIT\n      - STATE_TRYOPEN\n      - STATE_OPEN\n    ibc.core.connection.v1.Version:\n      type: object\n      properties:\n        identifier:\n          title: unique version identifier\n          type: string\n        features:\n          title: list of features compatible with the specified identifier\n          type: array\n          items:\n            type: string\n      description: |-\n        Version defines the versioning scheme used to negotiate the IBC verison in\n        the connection handshake.\n    ibc.core.channel.v1.Channel:\n      type: object\n      properties:\n        state:\n          title: current state of the channel end\n          type: string\n          description: |-\n            State defines if a channel is in one of the following states:\n            CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n             - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n             - STATE_INIT: A channel has just started the opening handshake.\n             - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n             - STATE_OPEN: A channel has completed the handshake. Open channels are\n            ready to send and receive packets.\n             - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n            packets.\n          default: STATE_UNINITIALIZED_UNSPECIFIED\n          enum:\n          - STATE_UNINITIALIZED_UNSPECIFIED\n          - STATE_INIT\n          - STATE_TRYOPEN\n          - STATE_OPEN\n          - STATE_CLOSED\n        ordering:\n          title: whether the channel is ordered or unordered\n          type: string\n          description: |-\n            - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n             - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n            which they were sent.\n             - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n          default: ORDER_NONE_UNSPECIFIED\n          enum:\n          - ORDER_NONE_UNSPECIFIED\n          - ORDER_UNORDERED\n          - ORDER_ORDERED\n        counterparty:\n          title: counterparty channel end\n          type: object\n          properties:\n            port_id:\n              type: string\n              description: port on the counterparty chain which owns the other end\n                of the channel.\n            channel_id:\n              title: channel end on the counterparty chain\n              type: string\n        connection_hops:\n          title: |-\n            list of connection identifiers, in order, along which packets sent on\n            this channel will travel\n          type: array\n          items:\n            type: string\n        version:\n          title: opaque channel version, which is agreed upon during the handshake\n          type: string\n      description: |-\n        Channel defines pipeline for exactly-once packet delivery between specific\n        modules on separate blockchains, which has at least one end capable of\n        sending packets and one end capable of receiving packets.\n    ibc.core.channel.v1.Counterparty:\n      title: Counterparty defines a channel end counterparty\n      type: object\n      properties:\n        port_id:\n          type: string\n          description: port on the counterparty chain which owns the other end of\n            the channel.\n        channel_id:\n          title: channel end on the counterparty chain\n          type: string\n    ibc.core.channel.v1.IdentifiedChannel:\n      type: object\n      properties:\n        state:\n          title: current state of the channel end\n          type: string\n          description: |-\n            State defines if a channel is in one of the following states:\n            CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n             - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n             - STATE_INIT: A channel has just started the opening handshake.\n             - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n             - STATE_OPEN: A channel has completed the handshake. Open channels are\n            ready to send and receive packets.\n             - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n            packets.\n          default: STATE_UNINITIALIZED_UNSPECIFIED\n          enum:\n          - STATE_UNINITIALIZED_UNSPECIFIED\n          - STATE_INIT\n          - STATE_TRYOPEN\n          - STATE_OPEN\n          - STATE_CLOSED\n        ordering:\n          title: whether the channel is ordered or unordered\n          type: string\n          description: |-\n            - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n             - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n            which they were sent.\n             - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n          default: ORDER_NONE_UNSPECIFIED\n          enum:\n          - ORDER_NONE_UNSPECIFIED\n          - ORDER_UNORDERED\n          - ORDER_ORDERED\n        counterparty:\n          title: counterparty channel end\n          type: object\n          properties:\n            port_id:\n              type: string\n              description: port on the counterparty chain which owns the other end\n                of the channel.\n            channel_id:\n              title: channel end on the counterparty chain\n              type: string\n        connection_hops:\n          title: |-\n            list of connection identifiers, in order, along which packets sent on\n            this channel will travel\n          type: array\n          items:\n            type: string\n        version:\n          title: opaque channel version, which is agreed upon during the handshake\n          type: string\n        port_id:\n          title: port identifier\n          type: string\n        channel_id:\n          title: channel identifier\n          type: string\n      description: |-\n        IdentifiedChannel defines a channel with additional port and channel\n        identifier fields.\n    ibc.core.channel.v1.Order:\n      title: Order defines if a channel is ORDERED or UNORDERED\n      type: string\n      description: |-\n        - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n         - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n        which they were sent.\n         - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n      default: ORDER_NONE_UNSPECIFIED\n      enum:\n      - ORDER_NONE_UNSPECIFIED\n      - ORDER_UNORDERED\n      - ORDER_ORDERED\n    ibc.core.channel.v1.PacketState:\n      type: object\n      properties:\n        port_id:\n          type: string\n          description: channel port identifier.\n        channel_id:\n          type: string\n          description: channel unique identifier.\n        sequence:\n          type: string\n          description: packet sequence.\n          format: uint64\n        data:\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          description: embedded data that represents packet state.\n          format: byte\n      description: |-\n        PacketState defines the generic type necessary to retrieve and store\n        packet commitments, acknowledgements, and receipts.\n        Caller is responsible for knowing the context necessary to interpret this\n        state as a commitment, acknowledgement, or a receipt.\n    ibc.core.channel.v1.QueryChannelClientStateResponse:\n      title: |-\n        QueryChannelClientStateResponse is the Response type for the\n        Query/QueryChannelClientState RPC method\n      type: object\n      properties:\n        identified_client_state:\n          title: client state associated with the channel\n          type: object\n          properties:\n            client_id:\n              title: client identifier\n              type: string\n            client_state:\n              title: client state\n              type: object\n              properties:\n                type_url:\n                  type: string\n                  description: |-\n                    A URL/resource name that uniquely identifies the type of the serialized\n                    protocol buffer message. This string must contain at least\n                    one \"/\" character. The last segment of the URL's path must represent\n                    the fully qualified name of the type (as in\n                    `path/google.protobuf.Duration`). The name should be in a canonical form\n                    (e.g., leading \".\" is not accepted).\n\n                    In practice, teams usually precompile into the binary all types that they\n                    expect it to use in the context of Any. However, for URLs which use the\n                    scheme `http`, `https`, or no scheme, one can optionally set up a type\n                    server that maps type URLs to message definitions as follows:\n\n                    * If no scheme is provided, `https` is assumed.\n                    * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                      value in binary format, or produce an error.\n                    * Applications are allowed to cache lookup results based on the\n                      URL, or have them precompiled into a binary to avoid any\n                      lookup. Therefore, binary compatibility needs to be preserved\n                      on changes to types. (Use versioned type names to manage\n                      breaking changes.)\n\n                    Note: this functionality is not currently available in the official\n                    protobuf release, and it is not used for type URLs beginning with\n                    type.googleapis.com.\n\n                    Schemes other than `http`, `https` (or the empty scheme) might be\n                    used with implementation specific semantics.\n                value:\n                  pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                  type: string\n                  description: Must be a valid serialized protocol buffer of the above\n                    specified type.\n                  format: byte\n              description: |-\n                `Any` contains an arbitrary serialized protocol buffer message along with a\n                URL that describes the type of the serialized message.\n\n                Protobuf library provides support to pack/unpack Any values in the form\n                of utility functions or additional generated methods of the Any type.\n\n                Example 1: Pack and unpack a message in C++.\n\n                    Foo foo = ...;\n                    Any any;\n                    any.PackFrom(foo);\n                    ...\n                    if (any.UnpackTo(\u0026foo)) {\n                      ...\n                    }\n\n                Example 2: Pack and unpack a message in Java.\n\n                    Foo foo = ...;\n                    Any any = Any.pack(foo);\n                    ...\n                    if (any.is(Foo.class)) {\n                      foo = any.unpack(Foo.class);\n                    }\n\n                 Example 3: Pack and unpack a message in Python.\n\n                    foo = Foo(...)\n                    any = Any()\n                    any.Pack(foo)\n                    ...\n                    if any.Is(Foo.DESCRIPTOR):\n                      any.Unpack(foo)\n                      ...\n\n                 Example 4: Pack and unpack a message in Go\n\n                     foo := \u0026pb.Foo{...}\n                     any, err := ptypes.MarshalAny(foo)\n                     ...\n                     foo := \u0026pb.Foo{}\n                     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                       ...\n                     }\n\n                The pack methods provided by protobuf library will by default use\n                'type.googleapis.com/full.type.name' as the type URL and the unpack\n                methods only use the fully qualified type name after the last '/'\n                in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n                name \"y.z\".\n\n\n                JSON\n                ====\n                The JSON representation of an `Any` value uses the regular\n                representation of the deserialized, embedded message, with an\n                additional field `@type` which contains the type URL. Example:\n\n                    package google.profile;\n                    message Person {\n                      string first_name = 1;\n                      string last_name = 2;\n                    }\n\n                    {\n                      \"@type\": \"type.googleapis.com/google.profile.Person\",\n                      \"firstName\": \u003cstring\u003e,\n                      \"lastName\": \u003cstring\u003e\n                    }\n\n                If the embedded message type is well-known and has a custom JSON\n                representation, that representation will be embedded adding a field\n                `value` which holds the custom JSON in addition to the `@type`\n                field. Example (for message [google.protobuf.Duration][]):\n\n                    {\n                      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                      \"value\": \"1.212s\"\n                    }\n          description: |-\n            IdentifiedClientState defines a client state with an additional client\n            identifier field.\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryChannelConsensusStateResponse:\n      title: |-\n        QueryChannelClientStateResponse is the Response type for the\n        Query/QueryChannelClientState RPC method\n      type: object\n      properties:\n        consensus_state:\n          title: consensus state associated with the channel\n          type: object\n          properties:\n            type_url:\n              type: string\n              description: |-\n                A URL/resource name that uniquely identifies the type of the serialized\n                protocol buffer message. This string must contain at least\n                one \"/\" character. The last segment of the URL's path must represent\n                the fully qualified name of the type (as in\n                `path/google.protobuf.Duration`). The name should be in a canonical form\n                (e.g., leading \".\" is not accepted).\n\n                In practice, teams usually precompile into the binary all types that they\n                expect it to use in the context of Any. However, for URLs which use the\n                scheme `http`, `https`, or no scheme, one can optionally set up a type\n                server that maps type URLs to message definitions as follows:\n\n                * If no scheme is provided, `https` is assumed.\n                * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n                  value in binary format, or produce an error.\n                * Applications are allowed to cache lookup results based on the\n                  URL, or have them precompiled into a binary to avoid any\n                  lookup. Therefore, binary compatibility needs to be preserved\n                  on changes to types. (Use versioned type names to manage\n                  breaking changes.)\n\n                Note: this functionality is not currently available in the official\n                protobuf release, and it is not used for type URLs beginning with\n                type.googleapis.com.\n\n                Schemes other than `http`, `https` (or the empty scheme) might be\n                used with implementation specific semantics.\n            value:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: Must be a valid serialized protocol buffer of the above\n                specified type.\n              format: byte\n          description: |-\n            `Any` contains an arbitrary serialized protocol buffer message along with a\n            URL that describes the type of the serialized message.\n\n            Protobuf library provides support to pack/unpack Any values in the form\n            of utility functions or additional generated methods of the Any type.\n\n            Example 1: Pack and unpack a message in C++.\n\n                Foo foo = ...;\n                Any any;\n                any.PackFrom(foo);\n                ...\n                if (any.UnpackTo(\u0026foo)) {\n                  ...\n                }\n\n            Example 2: Pack and unpack a message in Java.\n\n                Foo foo = ...;\n                Any any = Any.pack(foo);\n                ...\n                if (any.is(Foo.class)) {\n                  foo = any.unpack(Foo.class);\n                }\n\n             Example 3: Pack and unpack a message in Python.\n\n                foo = Foo(...)\n                any = Any()\n                any.Pack(foo)\n                ...\n                if any.Is(Foo.DESCRIPTOR):\n                  any.Unpack(foo)\n                  ...\n\n             Example 4: Pack and unpack a message in Go\n\n                 foo := \u0026pb.Foo{...}\n                 any, err := ptypes.MarshalAny(foo)\n                 ...\n                 foo := \u0026pb.Foo{}\n                 if err := ptypes.UnmarshalAny(any, foo); err != nil {\n                   ...\n                 }\n\n            The pack methods provided by protobuf library will by default use\n            'type.googleapis.com/full.type.name' as the type URL and the unpack\n            methods only use the fully qualified type name after the last '/'\n            in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n            name \"y.z\".\n\n\n            JSON\n            ====\n            The JSON representation of an `Any` value uses the regular\n            representation of the deserialized, embedded message, with an\n            additional field `@type` which contains the type URL. Example:\n\n                package google.profile;\n                message Person {\n                  string first_name = 1;\n                  string last_name = 2;\n                }\n\n                {\n                  \"@type\": \"type.googleapis.com/google.profile.Person\",\n                  \"firstName\": \u003cstring\u003e,\n                  \"lastName\": \u003cstring\u003e\n                }\n\n            If the embedded message type is well-known and has a custom JSON\n            representation, that representation will be embedded adding a field\n            `value` which holds the custom JSON in addition to the `@type`\n            field. Example (for message [google.protobuf.Duration][]):\n\n                {\n                  \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n                  \"value\": \"1.212s\"\n                }\n        client_id:\n          title: client ID associated with the consensus state\n          type: string\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryChannelResponse:\n      type: object\n      properties:\n        channel:\n          title: channel associated with the request identifiers\n          type: object\n          properties:\n            state:\n              title: current state of the channel end\n              type: string\n              description: |-\n                State defines if a channel is in one of the following states:\n                CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n                 - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n                 - STATE_INIT: A channel has just started the opening handshake.\n                 - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n                 - STATE_OPEN: A channel has completed the handshake. Open channels are\n                ready to send and receive packets.\n                 - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n                packets.\n              default: STATE_UNINITIALIZED_UNSPECIFIED\n              enum:\n              - STATE_UNINITIALIZED_UNSPECIFIED\n              - STATE_INIT\n              - STATE_TRYOPEN\n              - STATE_OPEN\n              - STATE_CLOSED\n            ordering:\n              title: whether the channel is ordered or unordered\n              type: string\n              description: |-\n                - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n                 - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n                which they were sent.\n                 - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n              default: ORDER_NONE_UNSPECIFIED\n              enum:\n              - ORDER_NONE_UNSPECIFIED\n              - ORDER_UNORDERED\n              - ORDER_ORDERED\n            counterparty:\n              title: counterparty channel end\n              type: object\n              properties:\n                port_id:\n                  type: string\n                  description: port on the counterparty chain which owns the other\n                    end of the channel.\n                channel_id:\n                  title: channel end on the counterparty chain\n                  type: string\n            connection_hops:\n              title: |-\n                list of connection identifiers, in order, along which packets sent on\n                this channel will travel\n              type: array\n              items:\n                type: string\n            version:\n              title: opaque channel version, which is agreed upon during the handshake\n              type: string\n          description: |-\n            Channel defines pipeline for exactly-once packet delivery between specific\n            modules on separate blockchains, which has at least one end capable of\n            sending packets and one end capable of receiving packets.\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n      description: |-\n        QueryChannelResponse is the response type for the Query/Channel RPC method.\n        Besides the Channel end, it includes a proof and the height from which the\n        proof was retrieved.\n    ibc.core.channel.v1.QueryChannelsResponse:\n      type: object\n      properties:\n        channels:\n          type: array\n          description: list of stored channels of the chain.\n          items:\n            type: object\n            properties:\n              state:\n                title: current state of the channel end\n                type: string\n                description: |-\n                  State defines if a channel is in one of the following states:\n                  CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n                   - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n                   - STATE_INIT: A channel has just started the opening handshake.\n                   - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n                   - STATE_OPEN: A channel has completed the handshake. Open channels are\n                  ready to send and receive packets.\n                   - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n                  packets.\n                default: STATE_UNINITIALIZED_UNSPECIFIED\n                enum:\n                - STATE_UNINITIALIZED_UNSPECIFIED\n                - STATE_INIT\n                - STATE_TRYOPEN\n                - STATE_OPEN\n                - STATE_CLOSED\n              ordering:\n                title: whether the channel is ordered or unordered\n                type: string\n                description: |-\n                  - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n                   - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n                  which they were sent.\n                   - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n                default: ORDER_NONE_UNSPECIFIED\n                enum:\n                - ORDER_NONE_UNSPECIFIED\n                - ORDER_UNORDERED\n                - ORDER_ORDERED\n              counterparty:\n                title: counterparty channel end\n                type: object\n                properties:\n                  port_id:\n                    type: string\n                    description: port on the counterparty chain which owns the other\n                      end of the channel.\n                  channel_id:\n                    title: channel end on the counterparty chain\n                    type: string\n              connection_hops:\n                title: |-\n                  list of connection identifiers, in order, along which packets sent on\n                  this channel will travel\n                type: array\n                items:\n                  type: string\n              version:\n                title: opaque channel version, which is agreed upon during the handshake\n                type: string\n              port_id:\n                title: port identifier\n                type: string\n              channel_id:\n                title: channel identifier\n                type: string\n            description: |-\n              IdentifiedChannel defines a channel with additional port and channel\n              identifier fields.\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n        height:\n          title: query block height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n      description: QueryChannelsResponse is the response type for the Query/Channels\n        RPC method.\n    ibc.core.channel.v1.QueryConnectionChannelsResponse:\n      title: |-\n        QueryConnectionChannelsResponse is the Response type for the\n        Query/QueryConnectionChannels RPC method\n      type: object\n      properties:\n        channels:\n          type: array\n          description: list of channels associated with a connection.\n          items:\n            type: object\n            properties:\n              state:\n                title: current state of the channel end\n                type: string\n                description: |-\n                  State defines if a channel is in one of the following states:\n                  CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n                   - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n                   - STATE_INIT: A channel has just started the opening handshake.\n                   - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n                   - STATE_OPEN: A channel has completed the handshake. Open channels are\n                  ready to send and receive packets.\n                   - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n                  packets.\n                default: STATE_UNINITIALIZED_UNSPECIFIED\n                enum:\n                - STATE_UNINITIALIZED_UNSPECIFIED\n                - STATE_INIT\n                - STATE_TRYOPEN\n                - STATE_OPEN\n                - STATE_CLOSED\n              ordering:\n                title: whether the channel is ordered or unordered\n                type: string\n                description: |-\n                  - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n                   - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\n                  which they were sent.\n                   - ORDER_ORDERED: packets are delivered exactly in the order which they were sent\n                default: ORDER_NONE_UNSPECIFIED\n                enum:\n                - ORDER_NONE_UNSPECIFIED\n                - ORDER_UNORDERED\n                - ORDER_ORDERED\n              counterparty:\n                title: counterparty channel end\n                type: object\n                properties:\n                  port_id:\n                    type: string\n                    description: port on the counterparty chain which owns the other\n                      end of the channel.\n                  channel_id:\n                    title: channel end on the counterparty chain\n                    type: string\n              connection_hops:\n                title: |-\n                  list of connection identifiers, in order, along which packets sent on\n                  this channel will travel\n                type: array\n                items:\n                  type: string\n              version:\n                title: opaque channel version, which is agreed upon during the handshake\n                type: string\n              port_id:\n                title: port identifier\n                type: string\n              channel_id:\n                title: channel identifier\n                type: string\n            description: |-\n              IdentifiedChannel defines a channel with additional port and channel\n              identifier fields.\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n        height:\n          title: query block height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryNextSequenceReceiveResponse:\n      title: |-\n        QuerySequenceResponse is the request type for the\n        Query/QueryNextSequenceReceiveResponse RPC method\n      type: object\n      properties:\n        next_sequence_receive:\n          title: next sequence receive number\n          type: string\n          format: uint64\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryPacketAcknowledgementResponse:\n      title: |-\n        QueryPacketAcknowledgementResponse defines the client query response for a\n        packet which also includes a proof and the height from which the\n        proof was retrieved\n      type: object\n      properties:\n        acknowledgement:\n          title: packet associated with the request fields\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryPacketAcknowledgementsResponse:\n      title: |-\n        QueryPacketAcknowledgemetsResponse is the request type for the\n        Query/QueryPacketAcknowledgements RPC method\n      type: object\n      properties:\n        acknowledgements:\n          type: array\n          items:\n            type: object\n            properties:\n              port_id:\n                type: string\n                description: channel port identifier.\n              channel_id:\n                type: string\n                description: channel unique identifier.\n              sequence:\n                type: string\n                description: packet sequence.\n                format: uint64\n              data:\n                pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                type: string\n                description: embedded data that represents packet state.\n                format: byte\n            description: |-\n              PacketState defines the generic type necessary to retrieve and store\n              packet commitments, acknowledgements, and receipts.\n              Caller is responsible for knowing the context necessary to interpret this\n              state as a commitment, acknowledgement, or a receipt.\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n        height:\n          title: query block height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryPacketCommitmentResponse:\n      title: |-\n        QueryPacketCommitmentResponse defines the client query response for a packet\n        which also includes a proof and the height from which the proof was\n        retrieved\n      type: object\n      properties:\n        commitment:\n          title: packet associated with the request fields\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryPacketCommitmentsResponse:\n      title: |-\n        QueryPacketCommitmentsResponse is the request type for the\n        Query/QueryPacketCommitments RPC method\n      type: object\n      properties:\n        commitments:\n          type: array\n          items:\n            type: object\n            properties:\n              port_id:\n                type: string\n                description: channel port identifier.\n              channel_id:\n                type: string\n                description: channel unique identifier.\n              sequence:\n                type: string\n                description: packet sequence.\n                format: uint64\n              data:\n                pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n                type: string\n                description: embedded data that represents packet state.\n                format: byte\n            description: |-\n              PacketState defines the generic type necessary to retrieve and store\n              packet commitments, acknowledgements, and receipts.\n              Caller is responsible for knowing the context necessary to interpret this\n              state as a commitment, acknowledgement, or a receipt.\n        pagination:\n          title: pagination response\n          type: object\n          properties:\n            next_key:\n              pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n              type: string\n              description: |-\n                next_key is the key to be passed to PageRequest.key to\n                query the next page most efficiently. It will be empty if\n                there are no more results.\n              format: byte\n            total:\n              title: |-\n                total is total number of results available if PageRequest.count_total\n                was set, its value is undefined otherwise\n              type: string\n              format: uint64\n          description: |-\n            PageResponse is to be embedded in gRPC response messages where the\n            corresponding request message has used PageRequest.\n\n             message SomeResponse {\n                     repeated Bar results = 1;\n                     PageResponse page = 2;\n             }\n        height:\n          title: query block height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryPacketReceiptResponse:\n      title: |-\n        QueryPacketReceiptResponse defines the client query response for a packet\n        receipt which also includes a proof, and the height from which the proof was\n        retrieved\n      type: object\n      properties:\n        received:\n          title: success flag for if receipt exists\n          type: boolean\n          format: boolean\n        proof:\n          title: merkle proof of existence\n          pattern: ^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\n          type: string\n          format: byte\n        proof_height:\n          title: height at which the proof was retrieved\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryUnreceivedAcksResponse:\n      title: |-\n        QueryUnreceivedAcksResponse is the response type for the\n        Query/UnreceivedAcks RPC method\n      type: object\n      properties:\n        sequences:\n          title: list of unreceived acknowledgement sequences\n          type: array\n          items:\n            type: string\n            format: uint64\n        height:\n          title: query block height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.QueryUnreceivedPacketsResponse:\n      title: |-\n        QueryUnreceivedPacketsResponse is the response type for the\n        Query/UnreceivedPacketCommitments RPC method\n      type: object\n      properties:\n        sequences:\n          title: list of unreceived packet sequences\n          type: array\n          items:\n            type: string\n            format: uint64\n        height:\n          title: query block height\n          type: object\n          properties:\n            revision_number:\n              title: the revision that the client is currently on\n              type: string\n              format: uint64\n            revision_height:\n              title: the height within the given revision\n              type: string\n              format: uint64\n          description: |-\n            Normally the RevisionHeight is incremented at each height while keeping\n            RevisionNumber the same. However some consensus algorithms may choose to\n            reset the height in certain conditions e.g. hard forks, state-machine\n            breaking changes In these cases, the RevisionNumber is incremented so that\n            height continues to be monitonically increasing even as the RevisionHeight\n            gets reset\n    ibc.core.channel.v1.State:\n      type: string\n      description: |-\n        State defines if a channel is in one of the following states:\n        CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n         - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n         - STATE_INIT: A channel has just started the opening handshake.\n         - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n         - STATE_OPEN: A channel has completed the handshake. Open channels are\n        ready to send and receive packets.\n         - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\n        packets.\n      default: STATE_UNINITIALIZED_UNSPECIFIED\n      enum:\n      - STATE_UNINITIALIZED_UNSPECIFIED\n      - STATE_INIT\n      - STATE_TRYOPEN\n      - STATE_OPEN\n      - STATE_CLOSED\nservers:\n  - url: https://lcd.osmosis.zone\n    description: Osmosis mainnet node\n  - url: https://lcd-test.osmosis.zone\n    description: Osmosis testnet node",
			"canonicalURL": "/github.com/osmosis-labs/docs@99e2ce4398a3db8b0b708ef62e1be4be16ca4a32/-/blob/static/api/IBCGO.yaml",
			"externalURLs": [
				{
					"url": "https://github.com/osmosis-labs/docs/blob/99e2ce4398a3db8b0b708ef62e1be4be16ca4a32/static/api/IBCGO.yaml",
					"serviceKind": "GITHUB"
				}
			]
		}
	},
	"Error": "unmarshal: yaml: unmarshal errors:\n  yaml: line 14299: mapping key \"servers\" already defined at line 6"
}