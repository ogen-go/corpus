{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/openshift-instruqt/instruqt"
		},
		"file": {
			"name": "track.yml",
			"size": 0,
			"path": "serverless/camel-k-serving/track.yml",
			"byteSize": 19942,
			"content": "slug: serverless-camel-k-serving\nid: uxa1a3iktb6p\ntype: track\ntitle: Serverless Camel K\ndescription: |\n  # Serverless Camel K\n\n  This scenario demonstrates how to create a simple API based [Camel K](https://camel.apache.org/camel-k/latest/index.html) integration with an OpenAPI definition.\n\n  The simple API application enable users to Create, Read, Update, and Delete to an generic online objects datastore.\n\n  Will also make this RESTFul application Serverless. By allowing this application to scale down to zero. And quickly comes back up and run after being called.\n\n\n  ## What is Camel K?\n\n  ![Logo](https://www.nicolaferraro.me/images/post-logo-apache-camel-d.png)\n\n  ### Your Integration Swiss-Army-Knife native on Kubernetes with Camel K\n\n  Apache Camel K is a lightweight integration framework built from Apache Camel that runs natively on Kubernetes and is specifically designed for serverless and microservice architectures.\n\n  Camel K supports multiple languages for writing integrations. Based the Operator Pattern, Camel K performs operations on Kubernetes resources. Bringing integration to the next level. utilizing the benefit of the Apache Camel project, such as the wide variety of components and Enterprise Integration Patterns (EIP).\n\n  Camel K integrate seamlessly with Knative making it the best serverless technology for integration. This scenario will get you started and hands on Camel K.\n\n  ## Why Serverless?\n  Deploying applications as Serverless services is becoming a popular architectural style.\n\n  You will need a  platform that can run serverless workloads, while also enabling you to have complete control of the configuration, building, and deployment. Ideally, the platform also supports deploying the applications as linux containers.\n\n  ##  OpenShift Serverless\n\n  OpenShift Serverless helps developers to deploy and run applications that will scale up or scale to zero on-demand. Applications are packaged as OCI compliant Linux containers that can be run anywhere. This is known as Serving.\nicon: https://logodix.com/logo/1910931.png\nlevel: beginner\ntags:\n- openshift\nowner: openshift\ndevelopers:\n- nvinto@redhat.com\n- rjarvine@redhat.com\n- dahmed@redhat.com\nprivate: false\npublished: true\nchallenges:\n- slug: step1\n  id: o3zvlhfkm7w9\n  type: challenge\n  title: Step 1\n  notes:\n  - type: text\n    contents: |\n      # Serverless Camel K\n\n      This scenario demonstrates how to create a simple API based [Camel K](https://camel.apache.org/camel-k/latest/index.html) integration with an OpenAPI definition.\n\n      The simple API application enable users to Create, Read, Update, and Delete to an generic online objects datastore.\n\n      Will also make this RESTFul application Serverless. By allowing this application to scale down to zero. And quickly comes back up and run after being called.\n\n\n      ## What is Camel K?\n\n      ![Logo](https://www.nicolaferraro.me/images/post-logo-apache-camel-d.png)\n\n      ### Your Integration Swiss-Army-Knife native on Kubernetes with Camel K\n\n      Apache Camel K is a lightweight integration framework built from Apache Camel that runs natively on Kubernetes and is specifically designed for serverless and microservice architectures.\n\n      Camel K supports multiple languages for writing integrations. Based the Operator Pattern, Camel K performs operations on Kubernetes resources. Bringing integration to the next level. utilizing the benefit of the Apache Camel project, such as the wide variety of components and Enterprise Integration Patterns (EIP).\n\n      Camel K integrate seamlessly with Knative making it the best serverless technology for integration. This scenario will get you started and hands on Camel K.\n\n      ## Why Serverless?\n      Deploying applications as Serverless services is becoming a popular architectural style.\n\n      You will need a  platform that can run serverless workloads, while also enabling you to have complete control of the configuration, building, and deployment. Ideally, the platform also supports deploying the applications as linux containers.\n\n      ##  OpenShift Serverless\n\n      OpenShift Serverless helps developers to deploy and run applications that will scale up or scale to zero on-demand. Applications are packaged as OCI compliant Linux containers that can be run anywhere. This is known as Serving.\n  assignment: |\n    In order to run Camel K, you will need access to an Kubernetes/OpenShift environment. Let's setup the fundamentals.\n\n    ## Logging in to the Cluster via Dashboard\n\n    Click the [Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com) tab to open the dashboard.\n\n    You will then able able to login with admin permissions with:\n\n    * **Username:** ``admin``\n    * **Password:** ``admin``\n\n\n    ## Logging in to the Cluster via CLI\n\n    Before creating any applications, login as admin. This will be required if you want to log in to the web console and\n    use it.\n\n    To login to the OpenShift cluster from the _Terminal_ run:\n\n    ```\n    oc login -u admin -p admin\n    ```\n\n    This will log you in using the credentials:\n\n    * **Username:** ``admin``\n    * **Password:** ``admin``\n\n    Use the same credentials to log into the web console.\n\n\n    ## Creating your own Project\n\n    To create a new project called ``camel-api`` run the command:\n\n    ```\n    oc new-project camel-api\n    ```\n\n    ## Install Camel K Operator\n\n    The Catalog Operator is responsible for building, deploying Camel Applications and also creating surrounding resources. It is also responsible for watching any code or configuration updates and automatically updates it. To install simply run the command.\n\n\n    ```\n    kamel install\n    ```\n\n     you will see this prompt:\n\n    ```\n    Camel K installed in namespace camel-api\n    ```\n\n    To check if Camel K operator has successfully installed,\n    ```\n    oc get pod -w\n    ```\n\n    once camel-k-operator starts the Running status, it means it is successfully installed.\n    ```\n    NAME                                READY   STATUS    RESTARTS   AGE\n    camel-k-operator-554df8d75c-d2dx5   1/1     Running   0          84s\n    ```\n\n\n    ## Setup the generic object datastore\n\n    Lets start Minio, it provide a S3 compatible protocol for storing the objects.\n    To create the minio backend, just apply the provided file:\n\n    ```\n    oc apply -f minio/minio.yaml\n    ```\n\n    Now you have a working generic object datastore.\n  tabs:\n  - title: Terminal 1\n    type: terminal\n    hostname: crc\n  - title: Visual Editor\n    type: code\n    hostname: crc\n    path: /root\n  difficulty: basic\n  timelimit: 450\n- slug: step2\n  id: xtw0lkkpcqzz\n  type: challenge\n  title: Step 2\n  assignment: |\n    ## Running the API integration\n\n    You have access to an OpenAPI standard document under `helper` called `openapi.yaml`, that contains operations for:\n     - Listing the name of the contained objects\n     - Creating a new object\n     - Getting the content of an object\n     - Deleting an object\n\n    #### (OPTIONAL)\n    The document is written in YAML, this is what it looks like.\n    You can take this and view it in https://www.apicur.io, as a web based UI to design and view your OpenAPI based APIs.\n    ![apicurio](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-camelk/camel-k-serving/Serving-Step2-01-API.png)\n\n\n    ```\n    openapi: 3.0.2\n    info:\n        title: Camel K Object API\n        version: 1.0.0\n        description: A CRUD API for an object store\n    paths:\n        /:\n            get:\n                responses:\n                    '200':\n                        content:\n                            application/json:\n                                schema:\n                                    type: array\n                                    items:\n                                        type: string\n                        description: Object list\n                operationId: list\n                summary: List the objects\n        '/{name}':\n            get:\n                responses:\n                    '200':\n                        content:\n                            application/octet-stream: {}\n                        description: The object content\n                operationId: get\n                summary: Get the content of an object\n            put:\n                requestBody:\n                    description: The object content\n                    content:\n                        application/octet-stream: {}\n                    required: true\n                responses:\n                    '200':\n                        description: The object has been created\n                operationId: create\n                summary: Save an object\n            delete:\n                responses:\n                    '204':\n                        description: Object has been deleted\n                operationId: delete\n                summary: Delete an object\n            parameters:\n                -\n                    name: name\n                    description: Name of the object\n                    schema:\n                        type: string\n                    in: path\n                    required: true\n        /list:\n            get:\n                responses:\n                    '200':\n                        content:\n                            application/json:\n                                schema:\n                                    type: array\n                                    items:\n                                        type: string\n                operationId: list\n                summary: List the objects\n\n    ```\n\n\n\n    #### IMPLEMENT API WIH CAMEL K\n    Let's create the camel route that implements the operations that was defined in the API.\n    Go to the text editor on the right, under the folder /root/camel-api. Right click on the directory and choose New -\u003e File and name it `API.java`.\n\n    Paste the following code into the application.\n\n    \u003cpre class=\"file\" data-filename=\"API.java\" data-target=\"replace\"\u003e\n    // camel-k: language=java dependency=camel-quarkus-openapi-java\n\n    import org.apache.camel.builder.AggregationStrategies;\n    import org.apache.camel.builder.RouteBuilder;\n\n    public class API extends RouteBuilder {\n      @Override\n      public void configure() throws Exception {\n\n        // All endpoints starting from \"direct:...\" reference an operationId defined\n        // in the \"openapi.yaml\" file.\n\n        // List the object names available in the S3 bucket\n        from(\"direct:list\")\n          .to(\"aws2-s3://{{api.bucket}}?operation=listObjects\")\n          .split(simple(\"${body}\"), AggregationStrategies.groupedBody())\n            .transform().simple(\"${body.key}\")\n          .end()\n          .marshal().json();\n\n\n        // Get an object from the S3 bucket\n        from(\"direct:get\")\n          .setHeader(\"CamelAwsS3Key\", simple(\"${header.name}\"))\n          .to(\"aws2-s3://{{api.bucket}}?operation=getObject\")\n          .convertBodyTo(String.class);\n\n        // Upload a new object into the S3 bucket\n        from(\"direct:create\")\n          .setHeader(\"CamelAwsS3Key\", simple(\"${header.name}\"))\n          .to(\"aws2-s3://{{api.bucket}}\");\n\n\n        // Delete an object from the S3 bucket\n        from(\"direct:delete\")\n          .setHeader(\"CamelAwsS3Key\", simple(\"${header.name}\"))\n          .to(\"aws2-s3://{{api.bucket}}?operation=deleteObject\")\n          .setBody().constant(\"\");\n\n      }\n    }\n\n    \u003c/pre\u003e\n\n    Let's add the for configuring and connecting to Minio.\n    Go to the text editor on the right, under the folder /root/camel-api. Right click on the directory and choose New -\u003e File and name it `minio.properties`.\n\n\n    \u003cpre class=\"file\" data-filename=\"minio.properties\" data-target=\"replace\"\u003e\n    # Bucket (referenced in the routes)\n    api.bucket=camel-k\n\n    # Minio information injected into the MinioCustomizer\n    minio.endpoint=http://minio:9000\n    minio.access-key=minio\n    minio.secret-key=minio123\n\n    # Camel AWS2 S3\n    camel.component.aws2-s3.region=EU_WEST_1\n    camel.component.aws2-s3.access-key={{minio.access-key}}\n    camel.component.aws2-s3.secret-key={{minio.secret-key}}\n    camel.component.aws2-s3.uri-endpoint-override = {{minio.endpoint}}\n    camel.component.aws2-s3.override-endpoint = true\n\n    # General configuration\n    camel.context.rest-configuration.api-context-path=/api-doc\n    \u003c/pre\u003e\n\n\n    We are now ready to start up the application, simply point to the OpenAPI standard document and along with the implemented Camel K application. Notice we are also pointing to the configuration file too.\n\n    ```\n    kamel run --name api camel-api/API.java --property-file camel-api/minio.properties --open-api helper/openapi.yaml\n    ```\n\n    Wait for the integration to be running (you should see the logs streaming in the terminal window).\n\n    ```\n    log\n    ```\n\n    After running the integration API, you should be able to call the API endpoints to check its behavior.\n    Make sure the integration is running, by checking its status:\n\n    ```\n    oc get integrations\n    ```\n\n    An integration named api should be present in the list and it should be in status Running.\n\n    ``\n    NAME    PHASE   KIT\n    api     Running kit-bte009bi9eodqqhokkkg\n    ``\n\n    There's also a kamel get command which is an alternative way to list all running integrations.\n    ```\n    kamel get\n    ```\n\n    NOTE: it may take some time, the first time you run the integration, for it to reach the Running state.\n\n    After the integration has reached the running state, you can get the route corresponding to it via the following command:\n\n    ```\n    URL=http://$(oc get route api -o jsonpath='{.spec.host}')\n    ```\n\n    Get the list of objects:\n    ```\n    curl $URL/\n    ```\n\n    Since there are nothing in the storage, you won't see anything for now.\n\n    Upload an object:\n    ```\n    curl -i -X PUT --header \"Content-Type: application/octet-stream\" --data-binary \"/root/camel-api/API.java\" $URL/example\n    ```\n\n    Get the new list of objects:\n    ```\n    curl -i $URL/\n    ```\n\n    You will see the *['example']* that we have just uploaded from previous step\n\n    Get the content of a file:\n    ```\n    curl -i $URL/example\n    ```\n\n    You will see what was in your *API.java* file\n\n    Delete the file:\n    ```\n    curl -i -X DELETE $URL/example\n    ```\n\n    Get the list of objects for the last time:\n    ```\n    curl -i $URL/\n    ```\n\n    The storage is emtpy again, so nothing will return.\n\n    Congratulations, you now have a running Restful web Application base on the OpenAPI Document.\n\n    Now, let's go ahead and uninstall the API instance.\n\n    ```\n    kamel delete api\n    ```\n  tabs:\n  - title: Terminal 1\n    type: terminal\n    hostname: crc\n  - title: Visual Editor\n    type: code\n    hostname: crc\n    path: /root\n  difficulty: basic\n  timelimit: 450\n- slug: step3\n  id: gq8vatvuoram\n  type: challenge\n  title: Step 3\n  assignment: |\n    ## Setup Serverless\n\n    The API integration can also run as Knative service and be able to scale to zero and scale out automatically, based on the received load.\n\n    To expose the integration as Knative service, you need to have OpenShift Serverless installed in the cluster. Let's subscribe to the OpenShift Serverless.\n\n    ```\n    oc apply -f serverless/subscription.yaml\n    ```\n\n    subscription.operators.coreos.com/servicemeshoperator created\n    subscription.operators.coreos.com/serverless-operator created\n\n    Next up, you must create a KnativeServing object to install Knative Serving using the OpenShift Serverless Operator.\n\n    ```\n    oc apply -f serverless/serving.yaml\n    ```\n\n    The KnativeServing instance will take a minute to install. As you might have noticed, the resources for KnativeServing can be found in the knative-serving project.\n\n\n\n    We can further validate an install being successful by seeing the following pods in knative-serving project:\n\n    ```\n    oc get pod -n knative-serving -w\n    ```\n\n    When completed, you should see all pods with the status of Running.\n\n    ```\n    NAME                                READY   STATUS    RESTARTS   AGE\n    activator-d6478496f-x689c           1/1     Running   0          2m10s\n    autoscaler-6ff6d5659c-5nq44         1/1     Running   0          2m9s\n    autoscaler-hpa-868c8b56b4-s6jln     1/1     Running   0          2m10s\n    controller-55b4748bc5-h5wxc         1/1     Running   0          2m6s\n    networking-istio-679dfcd5d7-mbt8v   1/1     Running   0          2m4s\n    webhook-55b96d44f6-k7qmk            1/1     Running   0          2m6s\n    ```\n\n    Ctrl-C to exit.\n\n    Congratulations, you now have a serverless platform installed, lets move on and make our API application serverless.\n  tabs:\n  - title: Terminal 1\n    type: terminal\n    hostname: crc\n  - title: Visual Editor\n    type: code\n    hostname: crc\n    path: /root\n  difficulty: basic\n  timelimit: 450\n- slug: step4\n  id: p6vtprcraset\n  type: challenge\n  title: Step 4\n  assignment: |\n    ## Making Camel K Serverless\n\n\n    With the same set of code written in Camel K, you can run it as a Serverless integration:\n\n    ```\n    kamel run camel-api/API.java --open-api helper/openapi.yaml --property-file camel-api/minio.properties --dependency camel-quarkus-openapi-java --profile Knative\n    ```\n\n    Notice, when you allow, Camel K will automatically deploy the camel routes as Serverless services so the routes can be auto scalable and scale down to zero when not needed.\n\n    Check the integrations to see when they are ready:\n\n    ```\n    oc get integrations\n    ```\n\n    An integration named api should be present in the list and it should be in status Running.\n\n    ``\n    NAME    PHASE   KIT\n    api     Running kit-bte009bi9eodqqhokkkg\n    ``\n    We can see the Serverless Service that we just created by executing:\n\n    ```\n    oc get services.serving.knative.dev api -n camel-api\n    ```\n\n\n    We can see the route by executing:\n\n    ```\n    oc get routes.serving.knative.dev api -n camel-api\n    ```\n\n\n    The Camel K API service will automatically scale down to zero if it does not get request for approximately 90 seconds. Try watching the service scaling down from [OpenShift Dev Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/camel-api/graph).\n\n    ![scalezero](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-camelk/camel-k-serving/Serving-Step4-01-scalezero.png)\n\n    Invoking the service to see the service scaling up.\n    ```\n    URL=$(oc get routes.serving.knative.dev api -o jsonpath='{.status.url}')\n    ```\n\n    Get the list of objects:\n\n    ```\n    curl -i $URL/\n    ```\n\n    It should be empty.\n\n    Watch the service scaling up from [OpenShift Dev Console](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/camel-api/graph) login with *admin/admin*. If you wait at another 90 seconds without invoking the API, you'll find that the pod will disappear. Calling the API again will make the pod appear to serve the request.\n\n    ![scaleup](https://raw.githubusercontent.com/openshift-instruqt/instruqt/master/assets/middleware/middleware-camelk/camel-k-serving/Serving-Step4-02-scaleup.png)\n\n\n    ## Congratulations\n\n    In this scenario you got to play with Camel K. Exposing RESTFul service using and OpenAPI Standard document. And also making it SERVERLESS. There are much more to Camel K. Be sure to visit [Camel K](https://camel.apache.org/camel-k/latest/index.html) to learn even more about the architecture and capabilities of this exciting new framework.\n  tabs:\n  - title: Terminal 1\n    type: terminal\n    hostname: crc\n  - title: Visual Editor\n    type: code\n    hostname: crc\n    path: /root\n  difficulty: basic\n  timelimit: 450\nchecksum: \"3370305759808672883\"\n",
			"canonicalURL": "/github.com/openshift-instruqt/instruqt@0b43a67b35a997e8f4476956bb246a07a1e2718d/-/blob/serverless/camel-k-serving/track.yml",
			"externalURLs": [
				{
					"url": "https://github.com/openshift-instruqt/instruqt/blob/0b43a67b35a997e8f4476956bb246a07a1e2718d/serverless/camel-k-serving/track.yml",
					"serviceKind": "GITHUB"
				}
			]
		}
	},
	"Error": "unmarshal: yaml: unmarshal errors:\n  yaml: line 1: cannot unmarshal !!str `openshift` into ogen.Tag"
}