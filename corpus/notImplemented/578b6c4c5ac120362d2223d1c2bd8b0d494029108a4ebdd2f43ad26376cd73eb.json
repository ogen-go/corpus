{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/CommerceExperts/open-commerce-search"
		},
		"file": {
			"name": "openapi.yaml",
			"size": 0,
			"path": "open-commerce-search-api/src/main/resources/openapi.yaml",
			"byteSize": 35505,
			"content": "openapi: 3.0.1\ninfo:\n  contact:\n    email: info@commerce-experts.com\n  description: A common product search API that separates its usage from required\n    search expertise\n  license:\n    name: Apache 2.0\n    url: http://www.apache.org/licenses/LICENSE-2.0.html\n  title: Open Commerce Search API\n  version: \"0.2\"\npaths:\n  /indexer-api/v1/full/add:\n    post:\n      description: Add one or more documents to a running import session.\n      operationId: add\n      requestBody:\n        content:\n          '*/*':\n            schema:\n              $ref: '#/components/schemas/BulkImportData'\n        description: Data that contains the import session reference and one or more\n          documents that should be added to that session.\n        required: true\n      responses:\n        \"200\":\n          content:\n            '*/*':\n              schema:\n                type: string\n                description: Amount of documents successfuly added\n          description: documents successfully added\n        \"400\":\n          description: import session is invalid\n      security:\n      - basic-auth: []\n      servers:\n      - description: \"Service to run a full import into a new index. To do so, start\\\n          \\ a indexation session with a request to 'start' and use the returned ImportSession\\\n          \\ object to 'add' products bulkwise. If all documents where added, use the\\\n          \\ 'done' request to deploy that index. In case there were failures (or more\\\n          \\ failures then tollerated), the 'cancel' request can be used to stop the\\\n          \\ process and cleanup the incomplete index. Depending on the document size,\\\n          \\ an amount of 500-2000 documents per bulk is sufficient. If product and\\\n          \\ content data should be indexed, its recommended to use different indexes.\\\n          \\ Otherwise make sure to use the same fields for the same content type,\\\n          \\ e.g. both kind of documents can have a textual 'title' field, but both\\\n          \\ kind of documents shouldn't have for example an 'author' field, which\\\n          \\ could be used for product facets (e.g. book authors) but not for faceting\\\n          \\ the content documents (e.g. blog post authors).\"\n        url: http://indexer-service\n        variables: {}\n      tags:\n      - indexer\n  /indexer-api/v1/full/cancel:\n    post:\n      description: \"Cancels the import and in case there was an index created, it\\\n        \\ will be deleted.\"\n      operationId: cancel\n      requestBody:\n        content:\n          '*/*':\n            schema:\n              $ref: '#/components/schemas/ImportSession'\n        required: true\n      responses:\n        \"400\":\n          description: indexation was already confirmed or import session is invalid\n      security:\n      - basic-auth: []\n      servers:\n      - description: \"Service to run a full import into a new index. To do so, start\\\n          \\ a indexation session with a request to 'start' and use the returned ImportSession\\\n          \\ object to 'add' products bulkwise. If all documents where added, use the\\\n          \\ 'done' request to deploy that index. In case there were failures (or more\\\n          \\ failures then tollerated), the 'cancel' request can be used to stop the\\\n          \\ process and cleanup the incomplete index. Depending on the document size,\\\n          \\ an amount of 500-2000 documents per bulk is sufficient. If product and\\\n          \\ content data should be indexed, its recommended to use different indexes.\\\n          \\ Otherwise make sure to use the same fields for the same content type,\\\n          \\ e.g. both kind of documents can have a textual 'title' field, but both\\\n          \\ kind of documents shouldn't have for example an 'author' field, which\\\n          \\ could be used for product facets (e.g. book authors) but not for faceting\\\n          \\ the content documents (e.g. blog post authors).\"\n        url: http://indexer-service\n        variables: {}\n      tags:\n      - indexer\n  /indexer-api/v1/full/done:\n    post:\n      description: \"Finishes the import, flushing the new index and (in case there\\\n        \\ is already an index with the initialized name) replacing the old one.\"\n      operationId: done\n      requestBody:\n        content:\n          '*/*':\n            schema:\n              $ref: '#/components/schemas/ImportSession'\n        required: true\n      responses:\n        \"200\":\n          description: successfully done\n        \"400\":\n          description: indexation was already confirmed or import session is invalid\n      security:\n      - basic-auth: []\n      servers:\n      - description: \"Service to run a full import into a new index. To do so, start\\\n          \\ a indexation session with a request to 'start' and use the returned ImportSession\\\n          \\ object to 'add' products bulkwise. If all documents where added, use the\\\n          \\ 'done' request to deploy that index. In case there were failures (or more\\\n          \\ failures then tollerated), the 'cancel' request can be used to stop the\\\n          \\ process and cleanup the incomplete index. Depending on the document size,\\\n          \\ an amount of 500-2000 documents per bulk is sufficient. If product and\\\n          \\ content data should be indexed, its recommended to use different indexes.\\\n          \\ Otherwise make sure to use the same fields for the same content type,\\\n          \\ e.g. both kind of documents can have a textual 'title' field, but both\\\n          \\ kind of documents shouldn't have for example an 'author' field, which\\\n          \\ could be used for product facets (e.g. book authors) but not for faceting\\\n          \\ the content documents (e.g. blog post authors).\"\n        url: http://indexer-service\n        variables: {}\n      tags:\n      - indexer\n  /indexer-api/v1/full/start/{indexName}:\n    get:\n      description: \"Starts a new full import. Returns a handle containing meta data,\\\n        \\ that has to be passed to all following calls.\"\n      operationId: startImport\n      parameters:\n      - description: \"index name, that should match the regular expression '[a-z0-9_-]+'\"\n        in: path\n        name: indexName\n        required: true\n        schema:\n          type: string\n      - description: used for language dependent settings\n        in: query\n        name: locale\n        required: true\n        schema:\n          type: string\n      responses:\n        \"200\":\n          content:\n            '*/*':\n              schema:\n                $ref: '#/components/schemas/ImportSession'\n          description: import session started\n        \"409\":\n          description: there is already an import running for that index\n      security:\n      - basic-auth: []\n      servers:\n      - description: \"Service to run a full import into a new index. To do so, start\\\n          \\ a indexation session with a request to 'start' and use the returned ImportSession\\\n          \\ object to 'add' products bulkwise. If all documents where added, use the\\\n          \\ 'done' request to deploy that index. In case there were failures (or more\\\n          \\ failures then tollerated), the 'cancel' request can be used to stop the\\\n          \\ process and cleanup the incomplete index. Depending on the document size,\\\n          \\ an amount of 500-2000 documents per bulk is sufficient. If product and\\\n          \\ content data should be indexed, its recommended to use different indexes.\\\n          \\ Otherwise make sure to use the same fields for the same content type,\\\n          \\ e.g. both kind of documents can have a textual 'title' field, but both\\\n          \\ kind of documents shouldn't have for example an 'author' field, which\\\n          \\ could be used for product facets (e.g. book authors) but not for faceting\\\n          \\ the content documents (e.g. blog post authors).\"\n        url: http://indexer-service\n        variables: {}\n      tags:\n      - indexer\n  /indexer-api/v1/update/{indexName}:\n    delete:\n      description: \"Delete existing document. If document does not exist, it returns\\\n        \\ code 304.\"\n      operationId: deleteDocuments\n      parameters:\n      - in: path\n        name: indexName\n        required: true\n        schema:\n          type: string\n      - in: query\n        name: \"id[]\"\n        schema:\n          type: array\n          items:\n            type: string\n      responses:\n        \"200\":\n          description: OK. The response contains a map of ids and according result.\n        \"404\":\n          description: index does not exist\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://indexer-service\n        variables: {}\n      tags:\n      - update\n    patch:\n      description: \"Partial update of existing documents. If a document does not exist,\\\n        \\ no update will be performed and it gets the result status 'NOT_FOUND'. In\\\n        \\ case a document is a master product with variants, the provided master product\\\n        \\ may only contain the changed values. However if some of the variants should\\\n        \\ be updated, all data from all variant products are required, unless you\\\n        \\ have an ID data-field inside variant - then you can update single variants.\\\n        \\ Without variant ID field, the missing variants won't be there after the\\\n        \\ update! This is how single variants can be deleted.\"\n      operationId: patchDocuments\n      parameters:\n      - in: path\n        name: indexName\n        required: true\n        schema:\n          type: string\n      responses:\n        \"200\":\n          description: OK. The response contains a map of ids and according result.\n        \"404\":\n          description: index does not exist\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://indexer-service\n        variables: {}\n      tags:\n      - update\n    put:\n      description: \"Puts a document to the index. If document does not exist, it will\\\n        \\ be added. An existing product will be overwritten unless the parameter 'replaceExisting\\\"\\\n        \\ is set to \\\"false\\\". Provided document should be a complete object, partial\\\n        \\ updates should be  done using the updateDocument method.\"\n      operationId: putDocuments\n      parameters:\n      - in: path\n        name: indexName\n        required: true\n        schema:\n          type: string\n      - description: set to false to avoid overriding a document with that ID. Defaults\n          to 'true'\n        in: query\n        name: replaceExisting\n        schema:\n          type: boolean\n      responses:\n        \"200\":\n          description: OK. The response contains a map of ids and according result.\n        \"404\":\n          description: index does not exist\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://indexer-service\n        variables: {}\n      tags:\n      - update\n  /search-api/v1/doc/{tenant}/{id}:\n    get:\n      operationId: getDocument\n      parameters:\n      - description: tenant name\n        in: path\n        name: tenant\n        required: true\n        schema:\n          type: string\n      - description: document id\n        in: path\n        name: id\n        required: true\n        schema:\n          type: string\n      responses:\n        default:\n          content:\n            '*/*':\n              schema:\n                $ref: '#/components/schemas/Document'\n          description: default response\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://search-service\n        variables: {}\n      tags:\n      - search\n  /search-api/v1/search/arranged/{tenant}:\n    post:\n      operationId: arrangedSearch\n      parameters:\n      - description: tenant name\n        in: path\n        name: tenant\n        required: true\n        schema:\n          type: string\n      requestBody:\n        content:\n          '*/*':\n            schema:\n              $ref: '#/components/schemas/ArrangedSearchQuery'\n        description: A list of all search requests that should be part of a single\n          response\n        required: true\n      responses:\n        default:\n          content:\n            '*/*':\n              schema:\n                $ref: '#/components/schemas/SearchResult'\n          description: default response\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://search-service\n        variables: {}\n      tags:\n      - search\n  /search-api/v1/search/{tenant}:\n    get:\n      description: Runs a search request for a certain tenant. The tenant should exist\n        at the service and linked to a certain index in the backend. Different tenants\n        may use the same index.\n      operationId: search\n      parameters:\n      - description: tenant name\n        in: path\n        name: tenant\n        required: true\n        schema:\n          type: string\n      - description: the query that describes the wished result\n        in: query\n        name: searchQuery\n        required: true\n        schema:\n          $ref: '#/components/schemas/SearchQuery'\n        style: form\n      - description: \"Any other parameters are used as filters. They are validated\\\n          \\ according to the actual data and configuration. Each filter can have multiple\\\n          \\ values, separated by comma. Commas inside the values have to be double-URL\\\n          \\ encoded. Depending on the configured backend type these values are used\\\n          \\ differently.\"\n        examples:\n          hierarchical_filter:\n            description: \"if category would be configured as path, these values are\\\n              \\ used for hierarchical filtering\"\n            summary: hierarchical filter\n            value: \"category=men,shoes,sneaker\"\n          joined_exclusive_filter:\n            description: The way filters are interpreted depends on the backend configuration.\n              If that field is configured to be used for \"exclusive filtering\" only\n              products would be shown that are available in red AND black\n            summary: joined exclusive filter\n            value: \"color=red,black\"\n          joined_filter:\n            description: products from adidas OR nike are shown\n            summary: joined filter\n            value: \"brand=adidas,nike\"\n          numeric_range_filter:\n            description: \"if price is configured as numeric field, these values are\\\n              \\ used as range filters\"\n            summary: numeric range filter\n            value: \"price=10,99.90\"\n          simple_filter:\n            description: Filters are simple parameters with the field-names as parameter\n              and the filter values as comma separated parameter values.\n            summary: simple filter\n            value: brand=adidas\n        in: query\n        name: filters\n        schema:\n          type: object\n          additionalProperties:\n            type: string\n        style: form\n      responses:\n        \"200\":\n          content:\n            '*/*':\n              schema:\n                $ref: '#/components/schemas/SearchResult'\n          description: successful found results\n        \"204\":\n          content:\n            '*/*':\n              schema:\n                $ref: '#/components/schemas/SearchResult'\n          description: Optional response code that represents 'no result'\n        \"403\":\n          content:\n            text/plain: {}\n          description: tenant can't be accessed or does not exist\n        \"404\":\n          content:\n            text/plain: {}\n          description: response code if tenant is unknown or index does not exist\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://search-service\n        variables: {}\n      summary: Search for documents\n      tags:\n      - search\n  /search-api/v1/tenants:\n    get:\n      operationId: getTenants\n      responses:\n        \"200\":\n          description: a list of available tenants\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://search-service\n        variables: {}\n      tags:\n      - search\n  /suggest-api/v1/{indexname}/suggest:\n    get:\n      description: Runs a suggestion request on the data of a certain index.\n      operationId: suggest\n      parameters:\n      - description: index name that should be searched for autocompletions\n        in: path\n        name: indexname\n        required: true\n        schema:\n          type: string\n      - description: the simple raw query typed by the user\n        in: query\n        name: userQuery\n        required: true\n        schema:\n          type: string\n      - description: A optional limit for the suggestions\n        in: query\n        name: limit\n        schema:\n          type: integer\n          format: int32\n      - description: Optional comma-separated list of filter values.\n        in: query\n        name: filter\n        schema:\n          type: string\n      responses:\n        \"200\":\n          content:\n            '*/*':\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Suggestion'\n          description: successful found results\n        \"404\":\n          content:\n            text/plain: {}\n          description: tenant is unknown or index does not exist\n      security:\n      - basic-auth: []\n      servers:\n      - url: http://suggest-service\n        variables: {}\n      summary: Autocomplete the user input\n      tags:\n      - Suggest\ncomponents:\n  schemas:\n    ArrangedSearchQuery:\n      type: object\n      properties:\n        arrangedProductSets:\n          type: array\n          items:\n            $ref: '#/components/schemas/ProductSet'\n        filters:\n          type: object\n          additionalProperties:\n            type: string\n        limit:\n          type: integer\n          format: int32\n          minimum: 1\n        offset:\n          type: integer\n          format: int32\n          minimum: 0\n        q:\n          type: string\n        sort:\n          type: string\n        userQuery:\n          $ref: '#/components/schemas/SearchQuery'\n        withFacets:\n          type: boolean\n    Attribute:\n      type: object\n      description: \"Rich model that can be used to represent a document's or product's\\\n        \\ attribute. The attribute 'name' should be a URL friendly identifier for\\\n        \\ that attribute (rather maxSpeed than 'Max Speed'). It will be used as filter\\\n        \\ parameter laster. If the attribute 'code' is provieded, it can be used for\\\n        \\ consistent filtering, even if the value name should change. The values are\\\n        \\ used to produce nice facets or if used for search, they will be added to\\\n        \\ the searchable content.\"\n      example:\n        name: color\n        value: red\n        code: ff0000\n      properties:\n        code:\n          type: string\n          description: \"Optional: code is considered as ID of the attribute value,\\\n            \\ e.g. \\\"FF0000\\\" for color\"\n          pattern: \"[A-Za-z0-9\\\\-_.]\"\n        name:\n          type: string\n          description: \"The name SHOULD be URL friendly identifier for the attribute,\\\n            \\ since it could be used to build according filter parameters.\"\n          pattern: \"[A-Za-z0-9\\\\-_.]\"\n        value:\n          type: string\n          description: \"Human readable representation of that attribute, e.g. 'Red'\\\n            \\ for the attribute 'Color'\"\n      required:\n      - name\n      - value\n    BulkImportData:\n      type: object\n      description: composite object that is used to add documents to the index.\n      properties:\n        documents:\n          type: array\n          items:\n            $ref: '#/components/schemas/Document'\n        session:\n          $ref: '#/components/schemas/ImportSession'\n      required:\n      - documents\n      - session\n    Category:\n      type: object\n      description: \"categories are treated in a parent-child relationship, so a product\\\n        \\ can be placed into a path within a category tree. Multiple category paths\\\n        \\ can be defined per document.\"\n      properties:\n        id:\n          type: string\n          description: Optional ID for a consistent filtering\n        name:\n          type: string\n      required:\n      - name\n    Document:\n      type: object\n      description: A data record that contains any data relevant for search. The single\n        field types and conversions are part of the according service configuration.\n      properties:\n        attributes:\n          type: array\n          description: multiple attributes can be delivered separately from standard\n            data fields\n          items:\n            $ref: '#/components/schemas/Attribute'\n        categories:\n          type: array\n          items:\n            type: array\n            description: \"categories are treated in a parent-child relationship, so\\\n              \\ a product can be placed into a path within a category tree. Multiple\\\n              \\ category paths can be defined per document.\"\n            items:\n              $ref: '#/components/schemas/Category'\n        data:\n          type: object\n          additionalProperties:\n            type: object\n            description: \"The data property should be used for standard fields, such\\\n              \\ as title, description, price. Only values of the following types are\\\n              \\ accepted (others will be dropped silently): Standard primitive types\\\n              \\ (Boolean, String, Integer, Double) and arrays of these types. Attributes\\\n              \\ (key-value objects with ID) should be passed to the attributes property.\"\n          description: \"The data property should be used for standard fields, such\\\n            \\ as title, description, price. Only values of the following types are\\\n            \\ accepted (others will be dropped silently): Standard primitive types\\\n            \\ (Boolean, String, Integer, Double) and arrays of these types. Attributes\\\n            \\ (key-value objects with ID) should be passed to the attributes property.\"\n        id:\n          type: string\n      required:\n      - data\n      - id\n    DynamicProductSet:\n      type: object\n      allOf:\n      - $ref: '#/components/schemas/ProductSet'\n      - type: object\n        properties:\n          filters:\n            type: object\n            additionalProperties:\n              type: string\n          limit:\n            type: integer\n            format: int32\n            minimum: 1\n          name:\n            type: string\n          query:\n            type: string\n          size:\n            type: integer\n            format: int32\n          sort:\n            type: string\n          type:\n            type: string\n    Facet:\n      type: object\n      description: \"If facets are part of this slice, they are placed here. By default\\\n        \\ only one slice SHOULD contain facets.\"\n      properties:\n        absoluteFacetCoverage:\n          type: integer\n          format: int64\n          description: This is the amount of matched documents that are covered by\n            that facet.\n        entries:\n          type: array\n          description: The entries of that facet.\n          items:\n            $ref: '#/components/schemas/FacetEntry'\n        fieldName:\n          type: string\n          description: This is the name coming from the data. Separate label information\n            should be available in the meta data.\n        filtered:\n          type: boolean\n        isFiltered:\n          type: boolean\n          description: Is set to true if there an active filter from that facet.\n        meta:\n          type: object\n          additionalProperties:\n            type: object\n            description: \"Optional meta data for that facet, e.g. display hints like\\\n              \\ a label or a facet-type.\"\n          description: \"Optional meta data for that facet, e.g. display hints like\\\n            \\ a label or a facet-type.\"\n        type:\n          type: string\n          description: \"The type of the facet, so the kind of FacetEntries it contains.\\\n            \\ See the according FacetEntry variants for more details.\"\n          enum:\n          - term\n          - hierarchical\n          - interval\n          - range\n    FacetEntry:\n      type: object\n      description: The entries of that facet.\n      discriminator:\n        mapping:\n          hierarchical: '#/components/schemas/HierarchialFacetEntry'\n          interval: '#/components/schemas/IntervalFacetEntry'\n          range: '#/components/schemas/RangeFacetEntry'\n          term: '#/components/schemas/FacetEntry'\n        propertyName: type\n      properties:\n        docCount:\n          type: integer\n          format: int64\n          description: \"Estimated amount of documents that will be returned, if this\\\n            \\ facet entry is picked as filter.\"\n        id:\n          type: string\n        key:\n          type: string\n        link:\n          type: string\n          format: URI\n        selected:\n          type: boolean\n          description: \"Should be set to true in the response, if that filter is actually\\\n            \\ selected.\"\n        type:\n          type: string\n    HierarchialFacetEntry:\n      type: object\n      allOf:\n      - $ref: '#/components/schemas/FacetEntry'\n      - type: object\n        properties:\n          children:\n            type: array\n            description: Child facet entries to that particular facet. The child facets\n              again could be HierarchialFacetEntries.\n            items:\n              $ref: '#/components/schemas/FacetEntry'\n          docCount:\n            type: integer\n            format: int64\n            description: \"Estimated amount of documents that will be returned, if\\\n              \\ this facet entry is picked as filter.\"\n          id:\n            type: string\n          key:\n            type: string\n          link:\n            type: string\n            format: URI\n          path:\n            type: string\n          selected:\n            type: boolean\n            description: \"Should be set to true in the response, if that filter is\\\n              \\ actually selected.\"\n          type:\n            type: string\n    ImportSession:\n      type: object\n      properties:\n        finalIndexName:\n          type: string\n        temporaryIndexName:\n          type: string\n      readOnly: true\n      required:\n      - finalIndexName\n      - temporaryIndexName\n    IntervalFacetEntry:\n      type: object\n      allOf:\n      - $ref: '#/components/schemas/FacetEntry'\n      - type: object\n        properties:\n          docCount:\n            type: integer\n            format: int64\n            description: \"Estimated amount of documents that will be returned, if\\\n              \\ this facet entry is picked as filter.\"\n          id:\n            type: string\n          key:\n            type: string\n          link:\n            type: string\n            format: URI\n          lowerBound:\n            type: number\n          selected:\n            type: boolean\n            description: \"Should be set to true in the response, if that filter is\\\n              \\ actually selected.\"\n          type:\n            type: string\n          upperBound:\n            type: number\n      description: \"Facet entry that describes a numerical interval. If only the lower\\\n        \\ value or only the upper value is set, this means it's an open ended interval,\\\n        \\ e.g. '\u003c 100' for upper bound only.\"\n    Product:\n      type: object\n      allOf:\n      - $ref: '#/components/schemas/Document'\n      - type: object\n        properties:\n          variants:\n            type: array\n            description: \"for products without variants, it can be null or rather\\\n              \\ us a document directly.\"\n            items:\n              $ref: '#/components/schemas/Document'\n      description: Main product containing the data that is common for all variants.\n        A product may represent a master-variant relation ship. A variant should be\n        associated to a single Product and cannot have variants again - those will\n        be ignored. It should only contain data special to that variant. Data that\n        is common to all variants should be set at master level.\n    ProductSet:\n      type: object\n      discriminator:\n        mapping:\n          dynamic: '#/components/schemas/DynamicProductSet'\n          static: '#/components/schemas/StaticProductSet'\n        propertyName: type\n      properties:\n        name:\n          type: string\n        size:\n          type: integer\n          format: int32\n        type:\n          type: string\n    RangeFacetEntry:\n      type: object\n      allOf:\n      - $ref: '#/components/schemas/FacetEntry'\n      - type: object\n        properties:\n          docCount:\n            type: integer\n            format: int64\n            description: \"Estimated amount of documents that will be returned, if\\\n              \\ this facet entry is picked as filter.\"\n          id:\n            type: string\n          key:\n            type: string\n          link:\n            type: string\n            format: URI\n          lowerBound:\n            type: number\n          selected:\n            type: boolean\n            description: \"Should be set to true in the response, if that filter is\\\n              \\ actually selected.\"\n          selectedMax:\n            type: number\n          selectedMin:\n            type: number\n          type:\n            type: string\n          upperBound:\n            type: number\n      description: \"Facet entry that describes the complete range of the facet. If\\\n        \\ a filter is picked, the selectedMin and selectedMax value are set, otherwise\\\n        \\ null.\"\n    ResultHit:\n      type: object\n      description: the list of actual hits for that result view.\n      properties:\n        document:\n          $ref: '#/components/schemas/Document'\n        index:\n          type: string\n        matchedQueries:\n          type: array\n          items:\n            type: string\n    SearchQuery:\n      type: object\n      properties:\n        limit:\n          type: integer\n          format: int32\n          minimum: 1\n        offset:\n          type: integer\n          format: int32\n          minimum: 0\n        q:\n          type: string\n        sort:\n          type: string\n        userQuery:\n          $ref: '#/components/schemas/SearchQuery'\n        withFacets:\n          type: boolean\n    SearchResult:\n      type: object\n      properties:\n        inputURI:\n          type: string\n          format: URI\n          description: The URI that was used to get that result view. May be used\n            to generate breadcrumbs.\n        meta:\n          type: object\n          additionalProperties:\n            type: object\n        slices:\n          type: array\n          description: \"The result may consist of several slices, for example if a\\\n            \\ search request couldn't be answered matching all words (e.g. \\\"striped\\\n            \\ nike shirt\\\") then one slice could be the result for one part of the\\\n            \\ query (e.g. \\\"striped shirt\\\") and the other could be for another part\\\n            \\ of the query (e.g. \\\"nike shirt\\\"). This can also be used to deliver\\\n            \\ some special advertised products or to split the result in different\\\n            \\ ranked slices (e.g. the first 3 results are ranked by popularity, the\\\n            \\ next 3 are sorted by price and the rest is ranked by 'default' relevance).\\\n            \\ Each slice contains the {@link SearchQuery} that represent that exact\\\n            \\ slice. At least 1 slice should be expected. If there is no slice, no\\\n            \\ results were found.\"\n          items:\n            $ref: '#/components/schemas/SearchResultSlice'\n        sortOptions:\n          type: array\n          items:\n            $ref: '#/components/schemas/Sorting'\n        tookInMillis:\n          type: integer\n          format: int64\n          description: amount of time the internal search needed to compute that result\n    SearchResultSlice:\n      type: object\n      description: \"The result may consist of several slices, for example if a search\\\n        \\ request couldn't be answered matching all words (e.g. \\\"striped nike shirt\\\"\\\n        ) then one slice could be the result for one part of the query (e.g. \\\"striped\\\n        \\ shirt\\\") and the other could be for another part of the query (e.g. \\\"nike\\\n        \\ shirt\\\"). This can also be used to deliver some special advertised products\\\n        \\ or to split the result in different ranked slices (e.g. the first 3 results\\\n        \\ are ranked by popularity, the next 3 are sorted by price and the rest is\\\n        \\ ranked by 'default' relevance). Each slice contains the {@link SearchQuery}\\\n        \\ that represent that exact slice. At least 1 slice should be expected. If\\\n        \\ there is no slice, no results were found.\"\n      properties:\n        facets:\n          type: array\n          description: \"If facets are part of this slice, they are placed here. By\\\n            \\ default only one slice SHOULD contain facets.\"\n          items:\n            $ref: '#/components/schemas/Facet'\n        hits:\n          type: array\n          description: the list of actual hits for that result view.\n          items:\n            $ref: '#/components/schemas/ResultHit'\n        label:\n          type: string\n          description: An identifier for that result slice. Can be used to differentiate\n            different slices. Values depend on the implementation.\n        matchCount:\n          type: integer\n          format: int64\n          description: the absolute number of matches in this result.\n        nextLink:\n          type: string\n          format: URI\n          description: \"URL conform query parameters, that has to be used to get the\\\n            \\ next bunch of results. Is null if there are no more results.\"\n        nextOffset:\n          type: integer\n          format: int64\n          description: the offset value to use to get the next result batch\n        resultLink:\n          type: string\n          format: URI\n          description: \"The query that represents exact that passed slice. If send\\\n            \\ to the engine again, that slice should be returned as main result.\"\n    Sorting:\n      type: object\n      properties:\n        active:\n          type: boolean\n        field:\n          type: string\n        isActive:\n          type: boolean\n        label:\n          type: string\n        link:\n          type: string\n          format: URI\n        sortOrder:\n          type: string\n          enum:\n          - asc\n          - desc\n    StaticProductSet:\n      type: object\n      allOf:\n      - $ref: '#/components/schemas/ProductSet'\n      - type: object\n        properties:\n          ids:\n            type: array\n            items:\n              type: string\n          name:\n            type: string\n          size:\n            type: integer\n            format: int32\n          type:\n            type: string\n    Suggestion:\n      type: object\n      properties:\n        payload:\n          type: object\n          additionalProperties:\n            type: string\n            description: \"arbitrary payload attached to that suggestion. Default:\\\n              \\ null\"\n          description: \"arbitrary payload attached to that suggestion. Default: null\"\n        phrase:\n          type: string\n          description: The phrase that is suggested and/or used as suggestion label.\n        type:\n          type: string\n          description: \"Optional type of that suggestion. Should be different for\\\n            \\ the different kind of suggested data. Default: 'keyword'\"\n          example: \"keyword, brand, category, product\"\n  securitySchemes:\n    basic-auth:\n      scheme: basic\n      type: http\n",
			"canonicalURL": "/github.com/CommerceExperts/open-commerce-search@a5ece0850d4fce4316f4a0940dac50391e5be79d/-/blob/open-commerce-search-api/src/main/resources/openapi.yaml",
			"externalURLs": [
				{
					"url": "https://github.com/CommerceExperts/open-commerce-search/blob/a5ece0850d4fce4316f4a0940dac50391e5be79d/open-commerce-search-api/src/main/resources/openapi.yaml",
					"serviceKind": "GITHUB"
				}
			]
		}
	},
	"Error": "notImplemented: path \"/indexer-api/v1/full/cancel\": post: requestBody: contents: unsupported content types: [*/*]",
	"NotImplemented": [
		"object with additionalProperties",
		"unsupported content types"
	]
}