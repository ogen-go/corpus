{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/openaustralia/yinyo"
		},
		"file": {
			"name": "definition.yaml",
			"size": 0,
			"path": "openapi/definition.yaml",
			"byteSize": 15588,
			"content": "openapi: 3.0.1\ninfo:\n  title: Yinyo\n  description: |\n    A wonderfully simple API driven service to reliably execute many long running scrapers in a super scaleable way\n  version: \"1.0\"\nservers:\n  - url: http://localhost:8080\n    description: Local development server\ntags:\n  - name: Core\n    description: The minimum you'll need to use\n  - name: Optional\n    description: Get access to more information about runs\npaths:\n  /runs:\n    summary: Create run\n    post:\n      tags: [\"Core\"]\n      summary: Create run\n      description: |\n        Returns with the \"run ID\" which uniquely identifies this run. You will need this value to subsequently start, track and access this run.\n      responses:\n        200:\n          description: Created successfully\n          content:\n            \"application/json\":\n              schema:\n                type: object\n                properties:\n                  name:\n                    type: string\n                    description: |\n                      Uniquely identifies this run. Needed for any subsequent API calls for this run.\n              example:\n                id: a9ff3b06-92c1-4150-8946-9920ea742d24\n  /runs/{id}/app:\n    put:\n      tags: [\"Core\"]\n      summary: Upload the code to be run and any local data\n      description: |\n        Take your directory with code, configuration and data to run. Tar and gzip compress it. Then use this to upload it to Yinyo.\n\n        If you're familiar with [Heroku](https://www.heroku.com/), you'll be familiar with the way different languages are recognised and compiled because Yinyo also uses the same underlying open source technology, [Buildpacks](https://devcenter.heroku.com/articles/buildpacks).\n\n        For different languages you'll need to include different files that tell Yinyo what language you're using as well as which version of the language you want and which libraries you want installed.\n\n        ### Python\n        For Python include `requirements.txt` in the root of your code directory. `pip` automatically uses this file to install your required libraries.\n\n        For more information visit the [Heroku Python documentation](https://devcenter.heroku.com/articles/python-support)\n\n        ### Node.js / Javascript\n        For Node.js include `package.json` in the root of your code directory. `npm` then automatically installs required libraries from this file.\n\n        For more information visit the [Heroku Node.js documentation](https://devcenter.heroku.com/articles/nodejs-support)\n\n        ### Ruby\n        For Ruby include `Gemfile` and `Gemfile.lock` in the root of your code directory. `bundler` installs your dependencies.\n\n        For more information visit the [Heroku Ruby documentation](https://devcenter.heroku.com/articles/ruby-support)\n\n        ### PHP\n        For PHP include `composer.json` and `composer.lock` in the root of your code directory. `Composer` installs your libraries.\n\n        For more information visit the [Heroku PHP documentation](https://devcenter.heroku.com/articles/php-support)\n\n        ### Perl\n        For Perl include `cpanfile`.\n\n        As this is a non-Heroku third-party buildpack no Heroku developer documentation is available. Instead take a look at the [GitHub repo](https://github.com/miyagawa/heroku-buildpack-perl) for the buildpack.\n\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n      requestBody:\n        content:\n          application/gzip:\n            schema:\n              type: string\n              description: |\n                Directory with code, configuration and data to run. Everything needs to be tarred and gzip compressed.\n              format: binary\n        required: true\n      responses:\n        200:\n          description: Success\n        404:\n          $ref: \"#/components/responses/not_found\"\n  /runs/{id}/cache:\n    summary: Manage build cache\n    put:\n      tags: [\"Optional\"]\n      summary: Upload a build cache\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n      requestBody:\n        content:\n          application/gzip:\n            schema:\n              description: Build cache exactly as it was downloaded before\n              type: string\n              format: binary\n        required: true\n      responses:\n        200:\n          description: Success\n        400:\n          $ref: \"#/components/responses/bad_request\"\n        404:\n          $ref: \"#/components/responses/not_found\"\n    get:\n      tags: [\"Optional\"]\n      summary: Download a build cache\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n      responses:\n        200:\n          content:\n            application/gzip:\n              schema:\n                description: Build cache\n                type: string\n                format: binary\n          description: Success\n        404:\n          $ref: \"#/components/responses/not_found\"\n\n  /runs/{id}/start:\n    post:\n      tags: [\"Core\"]\n      summary: Start the run\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                output:\n                  type: string\n                  description: |\n                    Optional relative path (from the directory of the code for the run) to file you want access to later. This will usually be the output of the run.\n                env:\n                  type: array\n                  description: |\n                    Optionally set environment variables for the run.\n                  items:\n                    $ref: \"#/components/schemas/Env\"\n                callback:\n                  type: string\n                  format: uri\n                  description: |\n                    Optionally provide a callback URL. For every event a POST to the URL will be made. To be able to authenticate the callback you'll need to specify a secret in the URL. Something like http://my-url-endpoint.com?key=special-secret-stuff would do the trick\n                max_run_time:\n                  type: integer\n                  description: |\n                    Optionally set the maximum number of seconds the run is allowed to go for. If it exceeds this it will be automatically stopped.\n                memory:\n                  type: integer\n                  description: |\n                    Set amount of memory (in bytes) allocated to run. If your run uses more memory than you allocated it will get killed.\n            example:\n              output: my_output.txt\n              env:\n                - name: MY_ENVIRONMENT_VARIABLE\n                  value: foo\n              callback: http://my-url-endpoint.com?key=special-secret-stuff\n              max_run_time: 3600\n\n      responses:\n        200:\n          description: Success\n        400:\n          $ref: \"#/components/responses/bad_request\"\n        404:\n          $ref: \"#/components/responses/not_found\"\n  /runs/{id}/events:\n    get:\n      tags: [\"Optional\"]\n      summary: Attach to run events stream\n      description: |\n        Watch what is happening to a run in real-time as it gets built and runs. By default this will stream all events that have occurred from the very beginning until now and then as new events occur stream those in real-time.\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n        - name: last_id\n          description: Restart stream immediately after the event with the given ID\n          in: query\n          schema:\n            type: string\n\n      responses:\n        200:\n          description: Succesfully attached to stream\n          content:\n            \"application/ld+json\":\n              schema:\n                oneOf:\n                  - $ref: \"#/components/schemas/LogEvent\"\n                  - $ref: \"#/components/schemas/StartEvent\"\n                  - $ref: \"#/components/schemas/FinishEvent\"\n                  - $ref: \"#/components/schemas/LastEvent\"\n                discriminator:\n                  propertyName: type\n              example:\n                id: \"123\"\n                time: \"2019-12-17T03:45:00Z\"\n                type: log\n                data:\n                  stage: \"build\"\n                  stream: \"stdout\"\n                  text: \"Hello!\"\n        404:\n          $ref: \"#/components/responses/not_found\"\n  /runs/{id}/exit-data:\n    get:\n      tags: [\"Optional\"]\n      summary: Find out whether the run has finished and if so also return exit codes and usage metrics\n      description: |\n        Returns a rag-bag of useful information about the progress and completion of a run. Find out whether the run has finished and if so find out  whether the scraper ran succesfully or not. Also returns information about how much resources the run took.\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n      responses:\n        200:\n          description: Success\n          content:\n            \"application/json\":\n              schema:\n                $ref: \"#/components/schemas/ExitData\"\n        404:\n          $ref: \"#/components/responses/not_found\"\n\n  /runs/{id}/output:\n    get:\n      tags: [\"Optional\"]\n      summary: Get output file\n      description: |\n        Usually at the end of the run you want to grab the contents of a file which is probably the result of scraping. This allows you to do that. The path to the file needs to be given when the run is started.\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n      responses:\n        200:\n          description: Success\n          content:\n            \"application/octet-stream\":\n              schema:\n                type: string\n                format: binary\n        404:\n          $ref: \"#/components/responses/not_found\"\n  /runs/{id}:\n    delete:\n      tags: [\"Core\"]\n      summary: Finalise scraper run\n      description: |\n        This does final clean up of everything associated with a run. Make sure you always do this as the last API call for a run. After doing this it's not possible to get any more information about this run.\n      parameters:\n        - $ref: \"#/components/parameters/id\"\n      responses:\n        200:\n          description: Success\n        404:\n          $ref: \"#/components/responses/not_found\"\ncomponents:\n  parameters:\n    id:\n      name: id\n      in: path\n      description: The run ID (as returned by creating a run)\n      required: true\n      schema:\n        type: string\n  responses:\n    bad_request:\n      description: There was a problem with your request\n      content:\n        application/json:\n          schema:\n            $ref: \"#/components/schemas/Error\"\n    not_found:\n      description: Not found\n      content:\n        application/json:\n          schema:\n            $ref: \"#/components/schemas/Error\"\n\n    Event:\n      description: Event - can be one of LogEvent, StartEvent, FinishEvent or LastEvent\n      content:\n        application/json:\n          schema:\n            oneOf:\n              - $ref: \"#/components/schemas/LogEvent\"\n              - $ref: \"#/components/schemas/StartEvent\"\n              - $ref: \"#/components/schemas/FinishEvent\"\n              - $ref: \"#/components/schemas/LastEvent\"\n            discriminator:\n              propertyName: type\n          example:\n            id: \"123\"\n            time: \"2019-12-17T03:45:00Z\"\n            type: log\n            data:\n              stage: \"build\"\n              stream: \"stdout\"\n              text: \"Hello!\"\n\n  schemas:\n    Error:\n      type: object\n      properties:\n        error:\n          type: string\n    Env:\n      type: object\n      properties:\n        name:\n          type: string\n          description: |\n            Name of the environment variable\n        value:\n          type: string\n          description: |\n            Value of the environment variable\n\n    Stage:\n      type: string\n      description: The stage of the life-cycle of the run\n      enum:\n        - build\n        - execute\n    ExitData:\n      type: object\n      properties:\n        build:\n          $ref: \"#/components/schemas/ExitDataStage\"\n        execute:\n          $ref: \"#/components/schemas/ExitDataStage\"\n        api:\n          $ref: \"#/components/schemas/ApiUsage\"\n        finished:\n          type: boolean\n          description: True if the run has finished either by running succesfully or by failing in the build or execute stage. This occurs when the \"last\" event is sent.\n    ExitDataStage:\n      type: object\n      properties:\n        exit_code:\n          type: number\n          description: Process exit code for build or execute. If there was no error this should be 0.\n        usage:\n          $ref: \"#/components/schemas/Usage\"\n    Usage:\n      type: object\n      properties:\n        max_rss:\n          type: integer\n          description: |\n            This is the maximum resident set size used (in bytes)\n        network_in:\n          type: integer\n          description: Total received network traffic (in bytes)\n        network_out:\n          type: integer\n          description: Total transmitted network traffic (in bytes)\n      description: |\n        Resources used by a process. This information is recorded as part of the metrics for a run.\n    ApiUsage:\n      type: object\n      properties:\n        network_in:\n          type: integer\n          description: Total received network traffic (in bytes)\n        network_out:\n          type: integer\n          description: Total transmitted network traffic (in bytes)\n      description: |\n        Network used in communicating with the API.\n    Event:\n      required:\n        - id\n        - run_id\n        - time\n        - type\n        - data\n      type: object\n      properties:\n        id:\n          type: string\n        run_id:\n          type: string\n        type:\n          type: string\n        time:\n          type: string\n          description: Date and time of event\n          # TODO: Fix time format\n          format: date-time\n      discriminator:\n        propertyName: type\n    StartEvent:\n      description: Signals the start of a stage\n      allOf:\n        - $ref: \"#/components/schemas/Event\"\n        - type: object\n          properties:\n            data:\n              type: object\n              properties:\n                stage:\n                  $ref: \"#/components/schemas/Stage\"\n    FinishEvent:\n      description: Signals the end of a stage\n      allOf:\n        - $ref: \"#/components/schemas/Event\"\n        - type: object\n          properties:\n            data:\n              type: object\n              properties:\n                stage:\n                  $ref: \"#/components/schemas/Stage\"\n                exit_data:\n                  $ref: \"#/components/schemas/ExitDataStage\"\n    LastEvent:\n      description: Signals the completion of the whole run\n      allOf:\n        - $ref: \"#/components/schemas/Event\"\n    LogEvent:\n      description: Console output event (from run)\n      allOf:\n        - $ref: \"#/components/schemas/Event\"\n        - type: object\n          properties:\n            data:\n              type: object\n              properties:\n                stage:\n                  $ref: \"#/components/schemas/Stage\"\n                stream:\n                  type: string\n                  description: |\n                    Source of the message - standard output and standard error come from your code. In exceptional circumstances you might see a message from \"internal error\".\n                  enum:\n                    - stdout\n                    - stderr\n                    - interr\n                text:\n                  type: string\n                  description: Console message\n",
			"canonicalURL": "/github.com/openaustralia/yinyo@b258b02bd74cbe204f1ef8dd3289049ca1c2c2b3/-/blob/openapi/definition.yaml",
			"externalURLs": [
				{
					"url": "https://github.com/openaustralia/yinyo/blob/b258b02bd74cbe204f1ef8dd3289049ca1c2c2b3/openapi/definition.yaml",
					"serviceKind": "GITHUB"
				}
			]
		}
	},
	"Error": "notImplemented: path \"/runs/{id}/events\": get: responses: 200: contents: unsupported content types: [application/ld+json]",
	"NotImplemented": [
		"unsupported content types"
	]
}