{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/coinbase/rosetta-specifications"
		},
		"file": {
			"name": "api.yaml",
			"size": 0,
			"path": "api.yaml",
			"byteSize": 61616,
			"content": "# Copyright 2020 Coinbase, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nopenapi: 3.0.2\ninfo:\n  version: 1.4.12\n  title: Rosetta\n  description: |\n    Build Once. Integrate Your Blockchain Everywhere.\n  license:\n    name: Apache 2.0\n    url: \"http://www.apache.org/licenses/LICENSE-2.0.html\"\npaths:\n  /network/list:\n    post:\n      summary: Get List of Available Networks\n      description: |\n        This endpoint returns a list of NetworkIdentifiers that the Rosetta\n        server supports.\n      operationId: networkList \n      tags:\n        - Network\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/MetadataRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/NetworkListResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /network/status:\n    post:\n      summary: Get Network Status\n      description: |\n        This endpoint returns the current status of the network requested. Any\n        NetworkIdentifier returned by /network/list should be accessible here.\n      operationId: networkStatus \n      tags:\n        - Network\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/NetworkRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/NetworkStatusResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /network/options:\n    post:\n      summary: Get Network Options\n      description: |\n        This endpoint returns the version information and allowed\n        network-specific types for a NetworkIdentifier. Any\n        NetworkIdentifier returned by /network/list should be accessible here.\n\n        Because options are retrievable in the context of a NetworkIdentifier,\n        it is possible to define unique options for each network.\n      operationId: networkOptions\n      tags:\n        - Network\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/NetworkRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/NetworkOptionsResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /block:\n    post:\n      summary: Get a Block\n      description: |\n        Get a block by its Block Identifier. If transactions are returned in\n        the same call to the node as fetching the block, the response should\n        include these transactions in the Block object. If not, an array of\n        Transaction Identifiers should be returned so /block/transaction\n        fetches can be done to get all transaction information.\n\n        When requesting a block by the hash component of the BlockIdentifier,\n        this request MUST be idempotent: repeated invocations for the same\n        hash-identified block must return the exact same block contents.\n\n        No such restriction is imposed when requesting a block by height,\n        given that a chain reorg event might cause the specific block at\n        height `n` to be set to a different one.\n      operationId: block\n      tags:\n        - Block\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/BlockRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/BlockResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /block/transaction:\n    post:\n      summary: Get a Block Transaction\n      description: |\n        Get a transaction in a block by its Transaction Identifier. This endpoint\n        should only be used when querying a node for a block does not return all\n        transactions contained within it.\n\n        All transactions returned by this endpoint must be appended to any\n        transactions returned by the /block method by consumers of this data.\n        Fetching a transaction by hash is considered an Explorer Method\n        (which is classified under the Future Work section).\n\n        This method can be used to let consumers to paginate results when the \n        block trasactions count is too big to be returned in a single BlockResponse.\n\n        Calling this endpoint requires reference to a BlockIdentifier because\n        transaction parsing can change depending on which block contains the\n        transaction. For example, in Bitcoin it is necessary to know which block\n        contains a transaction to determine the destination of fee payments.\n        Without specifying a block identifier, the node\n        would have to infer which block to use (which could change during a re-org).\n\n        Implementations that require fetching previous transactions to populate\n        the response (ex: Previous UTXOs in Bitcoin) may find it useful to run a\n        cache within the Rosetta server in the /data directory\n        (on a path that does not conflict with the node).\n      operationId: blockTransaction\n      tags:\n        - Block\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/BlockTransactionRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/BlockTransactionResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /mempool:\n    post:\n      summary: Get All Mempool Transactions\n      description: Get all Transaction Identifiers in the mempool\n      operationId: mempool\n      tags:\n        - Mempool\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/NetworkRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/MempoolResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /mempool/transaction:\n    post:\n      summary: Get a Mempool Transaction\n      description: |\n        Get a transaction in the mempool by its Transaction Identifier. This is\n        a separate request than fetching a block transaction (/block/transaction)\n        because some blockchain nodes need to know that a transaction query is\n        for something in the mempool instead of a transaction in a block.\n\n        Transactions may not be fully parsable until they are in a block (ex: may\n        not be possible to determine the fee to pay before a transaction is\n        executed). On this endpoint, it is ok that returned transactions are\n        only estimates of what may actually be included in a block.\n      operationId: mempoolTransaction\n      tags:\n        - Mempool\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/MempoolTransactionRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/MempoolTransactionResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /account/balance:\n    post:\n      summary: Get an Account's Balance\n      description: |\n        Get an array of all AccountBalances for an AccountIdentifier and the\n        BlockIdentifier at which the balance lookup was performed. The BlockIdentifier\n        must always be returned because some consumers of account balance data need\n        to know specifically at which block the balance was calculated to\n        compare balances they compute from operations with the balance returned\n        by the node.\n\n        It is important to note that making a balance request for an account\n        without populating the SubAccountIdentifier should not result in the\n        balance of all possible SubAccountIdentifiers being returned. Rather,\n        it should result in the balance pertaining to no SubAccountIdentifiers\n        being returned (sometimes called the liquid balance). To get all\n        balances associated with an account, it may be necessary to\n        perform multiple balance requests with unique AccountIdentifiers.\n\n        It is also possible to perform a historical balance lookup (if the server\n        supports it) by passing in an optional BlockIdentifier.\n      operationId: accountBalance\n      tags:\n        - Account\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/AccountBalanceRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/AccountBalanceResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /account/coins:\n    post:\n      summary: Get an Account's Unspent Coins\n      description: |\n        Get an array of all unspent coins for an AccountIdentifier and the\n        BlockIdentifier at which the lookup was performed. If your implementation\n        does not support coins (i.e. it is for an account-based blockchain),\n        you do not need to implement this endpoint. If you implementation does\n        support coins (i.e. it is fro a UTXO-based blockchain), you MUST\n        also complete the `/account/balance` endpoint.\n\n        It is important to note that making a coins request for an account\n        without populating the SubAccountIdentifier should not result in the\n        coins of all possible SubAccountIdentifiers being returned. Rather,\n        it should result in the coins pertaining to no SubAccountIdentifiers\n        being returned. To get all coins associated with an account, it may be\n        necessary to perform multiple coin requests with unique AccountIdentifiers.\n\n        Optionally, an implementation may choose to support updating an AccountIdentifier's\n        unspent coins based on the contents of the mempool. Note, using this functionality\n        breaks any guarantee of idempotency.\n      operationId: accountCoins\n      tags:\n        - Account\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/AccountCoinsRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/AccountCoinsResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/derive:\n    post:\n      summary: Derive an AccountIdentifier from a PublicKey\n      description: |\n        Derive returns the AccountIdentifier associated with a public key.\n\n        Blockchains that require an on-chain action to create an\n        account should not implement this method.\n      operationId: constructionDerive\n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionDeriveRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ConstructionDeriveResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/preprocess:\n    post:\n      summary: Create a Request to Fetch Metadata\n      description: |\n        Preprocess is called prior to `/construction/payloads` to construct a\n        request for any metadata that is needed for transaction construction\n        given (i.e. account nonce).\n\n        The `options` object returned from this endpoint will be sent to the `/construction/metadata`\n        endpoint UNMODIFIED by the caller (in an offline execution environment). If\n        your Construction API implementation has configuration options, they MUST\n        be specified in the `/construction/preprocess` request (in the `metadata`\n        field).\n      operationId: constructionPreprocess\n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionPreprocessRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ConstructionPreprocessResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/metadata:\n    post:\n      summary: Get Metadata for Transaction Construction\n      description: |\n        Get any information required to construct a transaction for a specific\n        network. Metadata returned here could be a recent hash to use, an\n        account sequence number, or even arbitrary chain state. The request\n        used when calling this endpoint is created by calling `/construction/preprocess`\n        in an offline environment.\n\n        You should NEVER assume that the request sent to this endpoint will be\n        created by the caller or populated with any custom parameters. This must\n        occur in `/construction/preprocess`.\n\n        It is important to clarify that this endpoint should not pre-construct\n        any transactions for the client (this should happen in `/construction/payloads`).\n        This endpoint is left purposely unstructured because of the wide scope\n        of metadata that could be required.\n      operationId: constructionMetadata \n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionMetadataRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ConstructionMetadataResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/payloads:\n    post:\n      summary: Generate an Unsigned Transaction and Signing Payloads\n      description: |\n        Payloads is called with an array of operations\n        and the response from `/construction/metadata`. It returns an\n        unsigned transaction blob and a collection of payloads that must\n        be signed by particular AccountIdentifiers using a certain SignatureType.\n\n        The array of operations provided in transaction construction often times\n        can not specify all \"effects\" of a transaction (consider invoked transactions\n        in Ethereum). However, they can deterministically specify the \"intent\"\n        of the transaction, which is sufficient for construction. For this reason,\n        parsing the corresponding transaction in the Data API (when it lands on chain)\n        will contain a superset of whatever operations were provided during construction.\n      operationId: constructionPayloads\n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionPayloadsRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ConstructionPayloadsResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/combine:\n    post:\n      summary: Create Network Transaction from Signatures\n      description: |\n        Combine creates a network-specific transaction from an unsigned\n        transaction and an array of provided signatures.\n\n        The signed transaction returned from this method will be sent to the\n        `/construction/submit` endpoint by the caller.\n      operationId: constructionCombine\n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionCombineRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ConstructionCombineResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/parse:\n    post:\n      summary: Parse a Transaction\n      description: |\n        Parse is called on both unsigned and signed transactions to\n        understand the intent of the formulated transaction.\n\n        This is run as a sanity check before signing (after `/construction/payloads`)\n        and before broadcast (after `/construction/combine`). \n      operationId: constructionParse\n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionParseRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ConstructionParseResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/hash:\n    post:\n      summary: Get the Hash of a Signed Transaction\n      description: |\n        TransactionHash returns the network-specific transaction hash for\n        a signed transaction.\n      operationId: constructionHash\n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionHashRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/TransactionIdentifierResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /construction/submit:\n    post:\n      summary: Submit a Signed Transaction\n      description: |\n        Submit a pre-signed transaction to the node. This call should not block\n        on the transaction being included in a block. Rather, it should return\n        immediately with an indication of whether or not the transaction was\n        included in the mempool.\n\n        The transaction submission response should only return a 200 status\n        if the submitted transaction could be included in the mempool.\n        Otherwise, it should return an error.\n      operationId: constructionSubmit \n      tags:\n        - Construction\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/ConstructionSubmitRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/TransactionIdentifierResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /call:\n    post:\n      summary: Make a Network-Specific Procedure Call \n      description: |\n        Call invokes an arbitrary, network-specific procedure call with network-specific\n        parameters. The guidance for what this endpoint should or could do is\n        purposely left vague. In Ethereum, this could be used to invoke `eth_call`\n        to implement an entire Rosetta API interface for some smart contract that\n        is not parsed by the implementation creator (like a DEX). This endpoint\n        could also be used to provide access to data that does not map\n        to any Rosetta models instead of requiring an integrator to use some\n        network-specific SDK and call some network-specific endpoint (like surfacing\n        staking parameters).\n\n        Call is NOT a replacement for implementing Rosetta API endpoints or mapping\n        network-specific data to Rosetta models. Rather, it enables developers to build\n        additional Rosetta API interfaces for things they care about without introducing\n        complexity into a base-level Rosetta implementation. Simply put, imagine\n        that the average integrator will use layered Rosetta API implementations\n        that each surfaces unique data.\n      operationId: call \n      tags:\n        - Call \n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CallRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/CallResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /events/blocks:\n    post:\n      summary: |\n        [INDEXER] Get a range of BlockEvents\n      description: |\n        `/events/blocks` allows the caller to query a sequence\n        of BlockEvents indicating which blocks were added and\n        removed from storage to reach the current state.\n        Following BlockEvents allows lightweight clients to update\n        their state without needing to implement their own syncing\n        logic (like finding the common parent in a reorg).\n\n        `/events/blocks` is considered an \"indexer\" endpoint\n        and Rosetta implementations are not required to complete it\n        to adhere to the Rosetta spec. However, any Rosetta \"indexer\"\n        MUST support this endpoint.\n      operationId: eventsBlocks\n      tags:\n        - Events\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/EventsBlocksRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/EventsBlocksResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n  /search/transactions:\n    post:\n      summary: |\n        [INDEXER] Search for Transactions\n      description: |\n        `/search/transactions` allows the caller to search for\n        transactions that meet certain conditions. Some conditions\n        include matching a transaction hash, containing an\n        operation with a certain status, or containing an operation\n        that affects a certain account.\n\n        `/search/transactions` is considered an \"indexer\" endpoint\n        and Rosetta implementations are not required to complete it\n        to adhere to the Rosetta spec. However, any Rosetta \"indexer\"\n        MUST support this endpoint.\n      operationId: searchTransactions\n      tags:\n        - Search\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/SearchTransactionsRequest'\n      responses:\n        '200':\n          description: Expected response to a valid request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/SearchTransactionsResponse'\n        '500':\n          description: unexpected error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\ncomponents:\n  schemas:\n    # Identifiers\n    NetworkIdentifier:\n      $ref: 'models/NetworkIdentifier.yaml'\n    SubNetworkIdentifier:\n      $ref: 'models/SubNetworkIdentifier.yaml'\n    BlockIdentifier:\n      $ref: 'models/BlockIdentifier.yaml'\n    PartialBlockIdentifier:\n      $ref: 'models/PartialBlockIdentifier.yaml'\n    TransactionIdentifier:\n      $ref: 'models/TransactionIdentifier.yaml'\n    OperationIdentifier:\n      $ref: 'models/OperationIdentifier.yaml'\n    AccountIdentifier:\n      $ref: 'models/AccountIdentifier.yaml'\n    SubAccountIdentifier:\n      $ref: 'models/SubAccountIdentifier.yaml'\n\n    # Models\n    Block:\n      $ref: 'models/Block.yaml'\n    Transaction:\n      $ref: 'models/Transaction.yaml'\n    Operation:\n      $ref: 'models/Operation.yaml'\n    Amount:\n      $ref: 'models/Amount.yaml'\n    Currency:\n      $ref: 'models/Currency.yaml'\n    SyncStatus:\n      $ref: 'models/SyncStatus.yaml'\n    Peer:\n      $ref: 'models/Peer.yaml'\n    Version:\n      $ref: 'models/Version.yaml'\n    Allow:\n      $ref: 'models/Allow.yaml'\n    OperationStatus:\n      $ref: 'models/OperationStatus.yaml'\n    Timestamp:\n      $ref: 'models/Timestamp.yaml'\n    PublicKey:\n      $ref: 'models/PublicKey.yaml'\n    CurveType:\n      $ref: 'models/CurveType.yaml'\n    SigningPayload:\n      $ref: 'models/SigningPayload.yaml'\n    Signature:\n      $ref: 'models/Signature.yaml'\n    SignatureType:\n      $ref: 'models/SignatureType.yaml'\n    CoinAction:\n      $ref: 'models/CoinAction.yaml'\n    CoinIdentifier:\n      $ref: 'models/CoinIdentifier.yaml'\n    CoinChange:\n      $ref: 'models/CoinChange.yaml'\n    Coin:\n      $ref: 'models/Coin.yaml'\n    BalanceExemption:\n      $ref: 'models/BalanceExemption.yaml'\n    ExemptionType:\n      $ref: 'models/ExemptionType.yaml'\n    BlockEvent:\n      $ref: 'models/BlockEvent.yaml'\n    BlockEventType:\n      $ref: 'models/BlockEventType.yaml'\n    Operator:\n      $ref: 'models/Operator.yaml'\n    BlockTransaction:\n      $ref: 'models/BlockTransaction.yaml'\n    RelatedTransaction:\n      $ref: 'models/RelatedTransaction.yaml'\n    Direction:\n      $ref: 'models/Direction.yaml'\n    Case:\n      $ref: 'models/Case.yaml'\n\n    # Request/Responses\n    AccountBalanceRequest:\n      description: |\n        An AccountBalanceRequest is utilized to make a balance request\n        on the /account/balance endpoint. If the block_identifier is populated,\n        a historical balance query should be performed.\n      type: object\n      required:\n        - network_identifier\n        - account_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        account_identifier:\n          $ref: '#/components/schemas/AccountIdentifier'\n        block_identifier:\n          $ref: '#/components/schemas/PartialBlockIdentifier'\n        currencies:\n          type: array\n          description: |\n            In some cases, the caller may not want to retrieve all available\n            balances for an AccountIdentifier. If the currencies field\n            is populated, only balances for the specified currencies\n            will be returned. If not populated, all available balances\n            will be returned.\n          items:\n            $ref: '#/components/schemas/Currency'\n    AccountBalanceResponse:\n      description: |\n        An AccountBalanceResponse is returned on the /account/balance endpoint.\n        If an account has a balance for each AccountIdentifier describing it\n        (ex: an ERC-20 token balance on a few smart contracts), an account\n        balance request must be made with each AccountIdentifier.\n\n        The `coins` field was removed and replaced by by `/account/coins` in `v1.4.7`.\n      type: object\n      required:\n        - block_identifier\n        - balances\n      properties:\n        block_identifier:\n          $ref: '#/components/schemas/BlockIdentifier'\n        balances:\n          type: array\n          description: |\n            A single account may have a balance in multiple currencies.\n          items:\n            $ref: '#/components/schemas/Amount'\n        metadata:\n          description: |\n            Account-based blockchains that utilize a nonce or sequence number\n            should include that number in the metadata. This number could be\n            unique to the identifier or global across the account address.\n          type: object\n          example:\n            sequence_number: 23\n    AccountCoinsRequest:\n      description: |\n        AccountCoinsRequest is utilized to make a request on the /account/coins\n        endpoint.\n      type: object\n      required:\n        - network_identifier\n        - account_identifier\n        - include_mempool\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        account_identifier:\n          $ref: '#/components/schemas/AccountIdentifier'\n        include_mempool:\n          type: boolean\n          description: |\n            Include state from the mempool when looking up an account's\n            unspent coins. Note, using this functionality\n            breaks any guarantee of idempotency.\n        currencies:\n          type: array\n          description: |\n            In some cases, the caller may not want to retrieve coins for all\n            currencies for an AccountIdentifier. If the currencies field\n            is populated, only coins for the specified currencies\n            will be returned. If not populated, all unspent coins\n            will be returned.\n          items:\n            $ref: '#/components/schemas/Currency'\n    AccountCoinsResponse:\n      description: |\n        AccountCoinsResponse is returned on the /account/coins endpoint and includes\n        all unspent Coins owned by an AccountIdentifier.\n      type: object\n      required:\n        - block_identifier\n        - coins\n      properties:\n        block_identifier:\n          $ref: '#/components/schemas/BlockIdentifier'\n        coins:\n          type: array\n          description: |\n            If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier\n            should be returned alongside the balance. It is highly recommended to\n            populate this field so that users of the Rosetta API implementation\n            don't need to maintain their own indexer to track their UTXOs.\n          items:\n            $ref: '#/components/schemas/Coin'\n        metadata:\n          description: |\n            Account-based blockchains that utilize a nonce or sequence number\n            should include that number in the metadata. This number could be\n            unique to the identifier or global across the account address.\n          type: object\n          example:\n            sequence_number: 23\n    BlockRequest:\n      description: |\n        A BlockRequest is utilized to make a block request on the\n        /block endpoint.\n      type: object\n      required:\n        - network_identifier\n        - block_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        block_identifier:\n          $ref: '#/components/schemas/PartialBlockIdentifier'\n    BlockResponse:\n      description: |\n        A BlockResponse includes a fully-populated block or a partially-populated\n        block with a list of other transactions to fetch (other_transactions).\n\n        As a result of the consensus algorithm of some blockchains, blocks\n        can be omitted (i.e. certain block indices can be skipped). If a query\n        for one of these omitted indices is made, the response should not include\n        a `Block` object.\n\n        It is VERY important to note that blocks MUST still form a canonical,\n        connected chain of blocks where each block has a unique index. In other words,\n        the `PartialBlockIdentifier` of a block after an omitted block should\n        reference the last non-omitted block.\n      type: object\n      properties:\n        block:\n          $ref: '#/components/schemas/Block'\n        other_transactions:\n          description: |\n            Some blockchains may require additional transactions to be fetched\n            that weren't returned in the block response\n            (ex: block only returns transaction hashes). For blockchains with a\n            lot of transactions in each block, this\n            can be very useful as consumers can concurrently fetch all\n            transactions returned.\n          type: array\n          items:\n            $ref: '#/components/schemas/TransactionIdentifier'\n    BlockTransactionRequest:\n      description: |\n        A BlockTransactionRequest is used to fetch a Transaction included in a\n        block that is not returned in a BlockResponse.\n      type: object\n      required:\n        - network_identifier\n        - block_identifier\n        - transaction_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        block_identifier:\n          $ref: '#/components/schemas/BlockIdentifier'\n        transaction_identifier:\n          $ref: '#/components/schemas/TransactionIdentifier'\n    BlockTransactionResponse:\n      description: |\n        A BlockTransactionResponse contains information about a block transaction.\n      type: object\n      required:\n        - transaction\n      properties:\n        transaction:\n          $ref: '#/components/schemas/Transaction'\n    MempoolResponse:\n      description: |\n        A MempoolResponse contains all transaction identifiers in the mempool\n        for a particular network_identifier.\n      type: object\n      required:\n        - transaction_identifiers\n      properties:\n        transaction_identifiers:\n          type: array\n          items:\n            $ref: '#/components/schemas/TransactionIdentifier'\n    MempoolTransactionRequest:\n      description: |\n        A MempoolTransactionRequest is utilized to retrieve a transaction\n        from the mempool.\n      type: object\n      required:\n        - network_identifier\n        - transaction_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        transaction_identifier:\n          $ref: '#/components/schemas/TransactionIdentifier'\n    MempoolTransactionResponse:\n      description: |\n        A MempoolTransactionResponse contains an estimate of a mempool\n        transaction. It may not be possible to know the full impact of\n        a transaction in the mempool (ex: fee paid).\n      type: object\n      required:\n        - transaction\n      properties:\n        transaction:\n          $ref: '#/components/schemas/Transaction'\n        metadata:\n          type: object\n          example:\n            descendant_fees: 123923\n            ancestor_count: 2\n    MetadataRequest:\n      description: |\n        A MetadataRequest is utilized in any request where\n        the only argument is optional metadata.\n      type: object\n      properties:\n        metadata:\n          type: object\n    NetworkListResponse:\n      description: |\n        A NetworkListResponse contains all NetworkIdentifiers\n        that the node can serve information for.\n      type: object\n      required:\n        - network_identifiers\n      properties:\n        network_identifiers:\n          type: array\n          items:\n            $ref: '#/components/schemas/NetworkIdentifier'\n    NetworkRequest:\n      description: |\n        A NetworkRequest is utilized to retrieve some data specific exclusively\n        to a NetworkIdentifier.\n      type: object\n      required:\n        - network_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        metadata:\n          type: object\n    NetworkStatusResponse:\n      description: |\n        NetworkStatusResponse contains basic information about the node's\n        view of a blockchain network. It is assumed that any BlockIdentifier.Index\n        less than or equal to CurrentBlockIdentifier.Index can be queried.\n\n        If a Rosetta implementation prunes historical state, it should\n        populate the optional `oldest_block_identifier` field with the\n        oldest block available to query. If this is not populated,\n        it is assumed that the `genesis_block_identifier` is the oldest\n        queryable block.\n\n        If a Rosetta implementation performs some pre-sync before it is\n        possible to query blocks, sync_status should be populated so that\n        clients can still monitor healthiness. Without this field, it may\n        appear that the implementation is stuck syncing and needs to be\n        terminated.\n      type: object\n      required:\n        - current_block_identifier\n        - current_block_timestamp\n        - genesis_block_identifier\n      properties:\n        current_block_identifier:\n          $ref: '#/components/schemas/BlockIdentifier'\n        current_block_timestamp:\n          $ref: '#/components/schemas/Timestamp'\n        genesis_block_identifier:\n          $ref: '#/components/schemas/BlockIdentifier'\n        oldest_block_identifier:\n          $ref: '#/components/schemas/BlockIdentifier'\n        sync_status:\n          $ref: '#/components/schemas/SyncStatus'\n        peers:\n          type: array\n          items:\n            $ref: '#/components/schemas/Peer'\n    NetworkOptionsResponse:\n      description: |\n        NetworkOptionsResponse contains information about the versioning of the\n        node and the allowed operation statuses, operation types, and errors.\n      type: object\n      required:\n        - version\n        - allow\n      properties:\n        version:\n          $ref: '#/components/schemas/Version'\n        allow:\n          $ref: '#/components/schemas/Allow'\n    ConstructionMetadataRequest:\n      description: |\n        A ConstructionMetadataRequest is utilized to get information required\n        to construct a transaction.\n\n        The Options object used to specify which metadata to return is left\n        purposely unstructured to allow flexibility for implementers. Options\n        is not required in the case that there is network-wide metadata of\n        interest.\n\n        Optionally, the request can also include an array\n        of PublicKeys associated with the AccountIdentifiers\n        returned in ConstructionPreprocessResponse.\n      type: object\n      required:\n        - network_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        options:\n          description: |\n            Some blockchains require different metadata for different types of\n            transaction construction (ex: delegation versus a transfer). Instead\n            of requiring a blockchain node to return all possible types of\n            metadata for construction (which may require multiple node fetches),\n            the client can populate an options object to limit the metadata\n            returned to only the subset required.\n          type: object\n        public_keys:\n          type: array\n          items:\n            $ref: '#/components/schemas/PublicKey'\n    ConstructionMetadataResponse:\n      description: |\n        The ConstructionMetadataResponse returns network-specific metadata\n        used for transaction construction.\n\n        Optionally, the implementer can return the suggested fee associated\n        with the transaction being constructed. The caller may use this info\n        to adjust the intent of the transaction or to create a transaction with\n        a different account that can pay the suggested fee. Suggested fee is an array\n        in case fee payment must occur in multiple currencies.\n      type: object\n      required:\n        - metadata\n      properties:\n        metadata:\n          type: object\n          example:\n            account_sequence: 23\n            recent_block_hash: \"0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5\"\n        suggested_fee:\n          type: array\n          items:\n            $ref: '#/components/schemas/Amount'\n    ConstructionDeriveRequest:\n      description: |\n        ConstructionDeriveRequest is passed to the `/construction/derive`\n        endpoint. Network is provided in the request because some blockchains\n        have different address formats for different networks.\n        Metadata is provided in the request because some blockchains\n        allow for multiple address types (i.e. different address\n        for validators vs normal accounts).\n      type: object\n      required:\n        - network_identifier\n        - public_key\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        public_key:\n          $ref: '#/components/schemas/PublicKey'\n        metadata:\n          type: object\n    ConstructionDeriveResponse:\n      description: |\n        ConstructionDeriveResponse is returned by the `/construction/derive`\n        endpoint.\n      type: object\n      properties:\n        address:\n          type: string\n          description: |\n            [DEPRECATED by `account_identifier` in `v1.4.4`] Address in network-specific format.\n        account_identifier:\n          $ref: '#/components/schemas/AccountIdentifier'\n        metadata:\n          type: object\n    ConstructionPreprocessRequest:\n      description: |\n        ConstructionPreprocessRequest is passed to the `/construction/preprocess`\n        endpoint so that a Rosetta implementation can determine which\n        metadata it needs to request for construction.\n\n        Metadata provided in this object should NEVER be a product\n        of live data (i.e. the caller must follow some network-specific\n        data fetching strategy outside of the Construction API to populate\n        required Metadata). If live data is required for construction, it MUST\n        be fetched in the call to `/construction/metadata`.\n\n        The caller can provide a max fee they are willing\n        to pay for a transaction. This is an array in the case fees\n        must be paid in multiple currencies.\n\n        The caller can also provide a suggested fee multiplier\n        to indicate that the suggested fee should be scaled.\n        This may be used to set higher fees for urgent transactions\n        or to pay lower fees when there is less urgency. It is assumed\n        that providing a very low multiplier (like 0.0001) will\n        never lead to a transaction being created with a fee\n        less than the minimum network fee (if applicable).\n\n        In the case that the caller provides both a max fee\n        and a suggested fee multiplier, the max fee will set an\n        upper bound on the suggested fee (regardless of the\n        multiplier provided).\n      type: object\n      required:\n        - network_identifier\n        - operations\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        operations:\n          type: array\n          items:\n            $ref: '#/components/schemas/Operation'\n        metadata:\n          type: object\n        max_fee:\n          type: array\n          items:\n            $ref: '#/components/schemas/Amount'\n        suggested_fee_multiplier:\n          type: number\n          format: double\n          minimum: 0.0\n    ConstructionPreprocessResponse:\n      description: |\n        ConstructionPreprocessResponse contains `options` that will\n        be sent unmodified to `/construction/metadata`. If it is\n        not necessary to make a request to `/construction/metadata`,\n        `options` should be omitted. \n\n        Some blockchains require the PublicKey of particular AccountIdentifiers\n        to construct a valid transaction. To fetch these PublicKeys, populate\n        `required_public_keys` with the AccountIdentifiers associated with the desired\n        PublicKeys. If it is not necessary to retrieve any PublicKeys\n        for construction, `required_public_keys` should be omitted.\n      type: object\n      properties:\n        options:\n          type: object\n          description: |\n            The options that will be sent directly to `/construction/metadata` by\n            the caller.\n        required_public_keys:\n          type: array\n          items:\n            $ref: '#/components/schemas/AccountIdentifier'\n    ConstructionPayloadsRequest:\n      description: |\n        ConstructionPayloadsRequest is the request to\n        `/construction/payloads`. It contains the network,\n        a slice of operations, and arbitrary metadata\n        that was returned by the call to `/construction/metadata`.\n\n        Optionally, the request can also include an array\n        of PublicKeys associated with the AccountIdentifiers\n        returned in ConstructionPreprocessResponse.\n      type: object\n      required:\n        - network_identifier\n        - operations\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        operations:\n          type: array\n          items:\n            $ref: '#/components/schemas/Operation'\n        metadata:\n          type: object\n        public_keys:\n          type: array\n          items:\n            $ref: '#/components/schemas/PublicKey'\n    ConstructionPayloadsResponse:\n      description: |\n        ConstructionTransactionResponse is returned by `/construction/payloads`. It\n        contains an unsigned transaction blob (that is usually needed to construct\n        the a network transaction from a collection of signatures) and an\n        array of payloads that must be signed by the caller.\n      type: object\n      required:\n        - unsigned_transaction\n        - payloads\n      properties:\n        unsigned_transaction:\n          type: string\n        payloads:\n          type: array\n          items:\n            $ref: '#/components/schemas/SigningPayload'\n    ConstructionCombineRequest:\n      description: |\n        ConstructionCombineRequest is the input to the `/construction/combine`\n        endpoint. It contains the unsigned transaction blob returned by\n        `/construction/payloads` and all required signatures to create\n        a network transaction.\n      type: object\n      required:\n        - network_identifier\n        - unsigned_transaction\n        - signatures\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        unsigned_transaction:\n          type: string\n        signatures:\n          type: array\n          items:\n            $ref: '#/components/schemas/Signature'\n    ConstructionCombineResponse:\n      description: |\n        ConstructionCombineResponse is returned by `/construction/combine`.\n        The network payload will be sent directly to the\n        `construction/submit` endpoint.\n      type: object\n      required:\n        - signed_transaction \n      properties:\n        signed_transaction:\n          type: string\n    ConstructionParseRequest:\n      description: |\n        ConstructionParseRequest is the input to the `/construction/parse`\n        endpoint. It allows the caller to parse either an unsigned or\n        signed transaction.\n      type: object\n      required:\n        - network_identifier\n        - signed\n        - transaction\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        signed:\n          type: boolean\n          description: |\n            Signed is a boolean indicating whether the transaction is signed.\n        transaction:\n          type: string\n          description: |\n            This must be either the unsigned transaction blob returned by\n            `/construction/payloads` or the signed transaction blob\n            returned by `/construction/combine`.\n    ConstructionParseResponse:\n      description: |\n        ConstructionParseResponse contains an array of operations that occur in\n        a transaction blob. This should match the array of operations provided\n        to `/construction/preprocess` and `/construction/payloads`.\n      type: object\n      required:\n        - operations\n      properties:\n        operations:\n          type: array\n          items:\n            $ref: '#/components/schemas/Operation'\n        signers:\n          description: |\n            [DEPRECATED by `account_identifier_signers` in `v1.4.4`] All signers (addresses) of a particular transaction. If the transaction\n            is unsigned, it should be empty.\n          type: array\n          items:\n            type: string\n        account_identifier_signers:\n          type: array\n          items:\n            $ref: '#/components/schemas/AccountIdentifier'\n        metadata:\n          type: object\n    ConstructionHashRequest:\n      description: |\n        ConstructionHashRequest is the input to the `/construction/hash` endpoint.\n      type: object\n      required:\n        - network_identifier\n        - signed_transaction\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        signed_transaction:\n          type: string\n    ConstructionSubmitRequest:\n      description: |\n        The transaction submission request includes a signed transaction.\n      type: object\n      required:\n        - network_identifier\n        - signed_transaction\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        signed_transaction:\n          type: string\n    TransactionIdentifierResponse:\n      description: |\n        TransactionIdentifierResponse contains the transaction_identifier of a\n        transaction that was submitted to either `/construction/hash` or\n        `/construction/submit`.\n      type: object\n      required:\n        - transaction_identifier\n      properties:\n        transaction_identifier:\n          $ref: '#/components/schemas/TransactionIdentifier'\n        metadata:\n          type: object\n    CallRequest:\n      description: |\n        CallRequest is the input to the `/call` endpoint.\n      type: object\n      required:\n        - network_identifier\n        - method\n        - parameters\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        method:\n          type: string\n          description: |\n            Method is some network-specific procedure call. This method could\n            map to a network-specific RPC endpoint, a method in an SDK generated\n            from a smart contract, or some hybrid of the two.\n\n            The implementation must define all available methods in the\n            Allow object. However, it is up to the caller to determine\n            which parameters to provide when invoking `/call`.\n          example: \"eth_call\"\n        parameters:\n          type: object\n          description: |\n            Parameters is some network-specific argument for a method. It is\n            up to the caller to determine which parameters to provide when invoking\n            `/call`.\n          example:\n            block_number: 23\n            address: \"0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5\"\n    CallResponse:\n      description: |\n        CallResponse contains the result of a `/call` invocation.\n      type: object\n      required:\n        - result\n        - idempotent\n      properties:\n        result:\n          type: object\n          description: |\n            Result contains the result of the `/call` invocation. This result\n            will not be inspected or interpreted by Rosetta tooling and is\n            left to the caller to decode.\n          example:\n            count: 1000\n        idempotent:\n          type: boolean\n          description: |\n            Idempotent indicates that if `/call` is invoked with the same\n            CallRequest again, at any point in time, it will return the same\n            CallResponse.\n\n            Integrators may cache the CallResponse if this is set to true\n            to avoid making unnecessary calls to the Rosetta implementation. For\n            this reason, implementers should be very conservative about returning\n            true here or they could cause issues for the caller.\n    EventsBlocksRequest:\n      description: |\n        EventsBlocksRequest is utilized to fetch a sequence of BlockEvents\n        indicating which blocks were added and removed from storage to\n        reach the current state.\n      type: object\n      required:\n        - network_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        offset:\n          description: |\n            offset is the offset into the event stream to sync events from. If this\n            field is not populated, we return the limit events backwards from tip.\n            If this is set to 0, we start from the beginning.\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n        limit:\n          description: |\n            limit is the maximum number of events to fetch in one call. The implementation\n            may return \u003c= limit events.\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n    EventsBlocksResponse:\n      description: |\n        EventsBlocksResponse contains an ordered collection of BlockEvents\n        and the max retrievable sequence.\n      type: object\n      required:\n        - max_sequence\n        - events\n      properties:\n        max_sequence:\n          description: |\n            max_sequence is the maximum available sequence number to fetch.\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n        events:\n          type: array\n          description: |\n            events is an array of BlockEvents indicating the order to add\n            and remove blocks to maintain a canonical view of blockchain\n            state. Lightweight clients can use this event stream to update\n            state without implementing their own block syncing logic.\n          items:\n            $ref: '#/components/schemas/BlockEvent'\n    SearchTransactionsRequest:\n      description: |\n        SearchTransactionsRequest is used to search for transactions\n        matching a set of provided conditions in canonical blocks.\n      type: object\n      required:\n        - network_identifier\n      properties:\n        network_identifier:\n          $ref: '#/components/schemas/NetworkIdentifier'\n        operator:\n          $ref: '#/components/schemas/Operator'\n        max_block:\n          description: |\n            max_block is the largest block index to consider when searching\n            for transactions. If this field is not populated, the current\n            block is considered the max_block.\n\n            If you do not specify a max_block, it is possible a newly synced\n            block will interfere with paginated transaction queries (as the offset\n            could become invalid with newly added rows).\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n        offset:\n          description: |\n            offset is the offset into the query result to start returning transactions.\n\n            If any search conditions are changed, the query offset will change and you\n            must restart your search iteration.\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n        limit:\n          description: |\n            limit is the maximum number of transactions to return in one call. The implementation\n            may return \u003c= limit transactions.\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n        transaction_identifier:\n          $ref: '#/components/schemas/TransactionIdentifier'\n        account_identifier:\n          $ref: '#/components/schemas/AccountIdentifier'\n        coin_identifier:\n          $ref: '#/components/schemas/CoinIdentifier'\n        currency:\n          $ref: '#/components/schemas/Currency'\n        status:\n          type: string\n          description: |\n            status is the network-specific operation type.\n          example: \"reverted\"\n        type:\n          type: string\n          description: |\n            type is the network-specific operation type.\n          example: \"transfer\"\n        address:\n          type: string\n          description: |\n            address is AccountIdentifier.Address. This is used to get all\n            transactions related to an AccountIdentifier.Address, regardless\n            of SubAccountIdentifier.\n          example: \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\"\n        success:\n          type: boolean\n          description: |\n            success is a synthetic condition populated by parsing network-specific\n            operation statuses (using the mapping provided in `/network/options`).\n    SearchTransactionsResponse:\n      description: |\n        SearchTransactionsResponse contains an ordered collection of BlockTransactions\n        that match the query in SearchTransactionsRequest. These BlockTransactions\n        are sorted from most recent block to oldest block.\n      type: object\n      required:\n        - transactions\n        - total_count\n      properties:\n        transactions:\n          type: array\n          description: |\n            transactions is an array of BlockTransactions sorted by most recent\n            BlockIdentifier (meaning that transactions in recent blocks appear\n            first).\n\n            If there are many transactions for a particular search, transactions\n            may not contain all matching transactions. It is up to the caller to\n            paginate these transactions using the max_block field.\n          items:\n            $ref: '#/components/schemas/BlockTransaction'\n        total_count:\n          description: |\n            total_count is the number of results for a given search. Callers\n            typically use this value to concurrently fetch results by offset\n            or to display a virtual page number associated with results.\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n        next_offset:\n          description: |\n            next_offset is the next offset to use when paginating through\n            transaction results. If this field is not populated, there are\n            no more transactions to query.\n          type: integer\n          format: int64\n          minimum: 0\n          example: 5\n\n    # Miscellaneous\n    Error:\n      $ref: 'models/Error.yaml'\n",
			"canonicalURL": "/github.com/coinbase/rosetta-specifications@a660477f3c00e6c7d4535fb5dc3da32ffcd5d7d7/-/blob/api.yaml",
			"externalURLs": [
				{
					"url": "https://github.com/coinbase/rosetta-specifications/blob/a660477f3c00e6c7d4535fb5dc3da32ffcd5d7d7/api.yaml",
					"serviceKind": "GITHUB"
				}
			]
		}
	},
	"Error": "parse: parse spec: parse components: schemas: \"BlockResponse\": parse schema: property \"block\": parse schema: resolve \"#/components/schemas/Block\": parse schema: resolve \"models/Block.yaml\": external \"models/Block.yaml\": file: local file reference is not allowed"
}