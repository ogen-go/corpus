{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/CardanoSolutions/kupo"
		},
		"file": {
			"name": "openapi.yaml",
			"size": 0,
			"path": "docs/openapi.yaml",
			"byteSize": 20183,
			"content": "openapi: 3.0.0\n\nservers:\n  - url: http://localhost:1442/\n\ninfo:\n  title: Kupo\n  version: v1\n  license:\n    name: MPL-2.0\n    url: https://raw.githubusercontent.com/cardanosolutions/kupo/master/LICENSE\n  x-logo:\n    url: ./kupo.png\n    altText: Kupo!\n\n  description: |\n    # Overview\n\n    **Kupo** is a lightweight, configurable, **chain-index** for the Cardano blockchain. It synchronizes data from the blockchain according to **patterns** matching addresses present in transaction outputs, to build a **lookup table** from matches to their associated **output references, values and datum hashes.**\n\n    # Installation\n\n    ### From pre-compiled executables\n\n    Pre-compiled static binaries can be downloaded as build artifacts from [latest releases](https://github.com/CardanoSolutions/kupo/releases) or the continuous [`Nix` Github workflow](https://github.com/CardanoSolutions/kupo/actions).\n\n    ### From Docker\n\n    Kupo is available as a standalone Docker image on [DockerHub](https://hub.docker.com/repository/docker/cardanosolutions/kupo).\n\n    ```console\n    $ docker pull cardanosolutions/kupo\n    ```\n\n    ### From source\n\n    ```console\n    $ nix build -f default.nix kupo.components.exes.kupo\n    ```\n\n    This produces a statically-linked executable that provides a command-line interface for passing options and commands.\n\n    # Getting Started\n\n    Kupo connects to a _local [cardano-node](https://github.com/input-output-hk/cardano-node/)_ in order to receive information from the blockchain. It goes without saying that an up-and-running cardano-node is required to run kupo!\n\n    A single kupo server is meant to build an index for a specific set of addresses. Addresses are matched according to flexible patterns. Once matched, results can be queried as JSON via HTTP GET requests.\n    For instance, it is possible to synchronize all addresses associated with a given stake key (e.g. `stake_vkh14hkp0sncfkt76spuqydtww4r900hfmsseezztzlh9sjkkjx6d7q`).\n\n    Provided that the configuration and IPC socket for a cardano-node are available in `some-folder/cardano-node`, one can start a kupo server as follows:\n\n    ```console\n    $ kupo \\\n      --node-socket some-folder/cardano-node/node.socket \\\n      --node-config some-folder/cardano-node/config.json \\\n      --since origin \\\n      --match \"*/stake_vkh14hkp0sncfkt76spuqydtww4r900hfmsseezztzlh9sjkkjx6d7q\" \\\n      --in-memory\n    ```\n\n    #### --in-memory / --workdir\n\n    This will build an index from the beginning of the blockchain (i.e. `origin`) of all transaction outputs where that stake key has been involved in. The `--in-memory` option tells kupo to not persist the index on-disk but to build it fully\n    in-memory. When building such a large index (from origin!), this is not recommended as it may cause the program memory usage to grow unbounded.\n\n    Let's fix that:\n\n    ```console\n    $ kupo \\\n      --node-socket some-folder/cardano-node/node.socket \\\n      --node-config some-folder/cardano-node/config.json \\\n      --since origin \\\n      --match \"*/stake_vkh14hkp0sncfkt76spuqydtww4r900hfmsseezztzlh9sjkkjx6d7q\" \\\n      --workdir ./db\n    ```\n\n    Perfect, now kupo will store all the information in a database on-disk at the location pointed by `--workdir`. Incidentally, this also allows kupo to resume its work from where it lefts it in case the server is interrupted. Neat!\n\n    #### --since\n\n    What if we only need to synchronize from a given point in time? For example, we may want to skip the entire Byron and Shelley eras because we know that this stake key may only have been used starting from the Allegra era onwards.\n    Fortunately, we can use the `--since` to provide a different starting point!\n\n    ```console\n    $ kupo \\\n      --node-socket some-folder/cardano-node/node.socket \\\n      --node-config some-folder/cardano-node/config.json \\\n      --since 16588737.4e9bbbb67e3ae262133d94c3da5bffce7b1127fc436e7433b87668dba34c354a \\\n      --match \"*/stake_vkh14hkp0sncfkt76spuqydtww4r900hfmsseezztzlh9sjkkjx6d7q\" \\\n      --workdir ./db\n    ```\n\n    Points are given as `{slot_no}.{header_hash}` and defines an exclusive boundary. Said differently, kupo will start synchronizing from the next block following the given point. In case you need them, here are a few points of interest on the Cardano **mainnet**:\n\n    | Era Bound          | SlotNo   | Hash                                                             |\n    | ---                | ---      | ---                                                              |\n    | Last Byron Block   | 4492799  | f8084c61b6a238acec985b59310b6ecec49c0ab8352249afd7268da5cff2a457 |\n    | Last Shelley Block | 16588737 | 4e9bbbb67e3ae262133d94c3da5bffce7b1127fc436e7433b87668dba34c354a |\n    | Last Allegra Block | 23068793 | 69c44ac1dda2ec74646e4223bc804d9126f719b1c245dadc2ad65e8de1b276d7 |\n    | Last Mary Block    | 39916796 | e72579ff89dc9ed325b723a33624b596c08141c7bd573ecfff56a1f7229e4d09 |\n    | Last Alonzo Block  | N/A      | N/A                                                              |\n\n    #### --match\n\n    Kupo can accept one or more matching patterns using the `--match` option. In case multiple patterns are provided, they'll ALL be used when looking for addresses. This allows for example to build an index for a list of payment keys known of a wallet. The syntax for patterns\n    is explained in greater details in the [Pattern](#section/Pattern) section below.\n\n    #### --help\n\n    In case you're lost, don't forget that a summary of this manual is available by running:\n\n    ```console\n    $ kupo --help\n    ```\n\n    # Pattern\n\n    Kupo can construct patterns from pretty much every constituant of an address, in any kind of format (bech32, base16, base58, you name it!). It also accepts wildcards using the asterisk symbol `*`.\n    Conceptually, patterns match the logical structure of (Shelley) addresses which are divided into two parts: a payment part and a delegation part. To learn more about Cardano addresses, feel free\n    to look [CIP-0019](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019#readme) for a deep dive!\n\n    Here below is summarized the general syntax for valid patterns. Note that different patterns may match the same addresses. Note also that while `*` will match _any_ Cardano address (Byron included),\n    `*/*` will match only Shelley addresses (since Byron addresses do not have any delegation part!).\n\n    ```\n                ┏━━━━━━━━━┓\n    PATTERN  ╾┬─┫ ADDRESS ┣─────────────────────────┬╼\n              │ ┗━━━━━━━━━┛                         │\n              │ ┏━━━━━━━━━━━━━━━┓                   │\n              ├─┫ STAKE-ADDRESS ┣───────────────────┤\n              │ ┗━━━━━━━━━━━━━━━┛                   │\n              │ ┏━━━━━━━━━━━━┓ ╭───╮ ┏━━━━━━━━━━━━┓ │\n              ├─┫ CREDENTIAL ┣─┤ / ├─┫ CREDENTIAL ┣─┤\n              │ ┗━━━━━━━━━━━━┛ ╰───╯ ┗━━━━━━━━━━━━┛ │\n              │ ╭───╮                               │\n              └─┤ * ├───────────────────────────────┘\n                ╰───╯\n\n    ```\n\n    ```\n                  ┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n    CREDENTIAL ╾┬─┫ BASE16(bytes .size 32) ┣─────────────────────────────┬╼\n                │ ┗━━━━━━━━━━━━━━━━━━━━━━━━┛                             │\n                │ ┏━━━━━━━━━━━━━━━━━━━━━━━━┓                             │\n                ├─┫ BASE16(bytes .size 28) ┣─────────────────────────────┤\n                │ ┗━━━━━━━━━━━━━━━━━━━━━━━━┛                             │\n                │ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓           │\n                ├─┫ BECH32(bytes) .hrp (vk|addr_vk|stake_vk) ┣───────────┤\n                │ ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛           │\n                │ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │\n                ├─┫ BECH32(bytes) .hrp (vkh|addr_vkh|stake_vkh|script) ┣─┤\n                │ ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛ │\n                │ ╭───╮                                                  │\n                └─┤ * ├──────────────────────────────────────────────────┘\n                  ╰───╯\n    ```\n\n    ### Examples:\n\n    - `addr1vyc29pvl2uyzqt8nwxrcxnf558ffm27u3d9calxn8tdudjgz4xq9p`\n    - `addr_vk1x7da0l25j04my8sej5ntrgdn38wmshxhplxdfjskn07ufavsgtkqn5hljl/*`\n    - `*/script1cda3khwqv60360rp5m7akt50m6ttapacs8rqhn5w342z7r35m37`\n    - `dca1e44765b9f80c8b18105e17de90d4a07e4d5a83de533e53fee32e0502d17e/*`\n    - `*/4fc6bb0c93780ad706425d9f7dc1d3c5e3ddbf29ba8486dce904a5fc`\n    - `*`\n    - `*/*`\n\n    # Accessing Results\n\n    Matches can be queried from the server via HTTP GET requests. For example:\n\n    ```console\n    $ curl http://localhost:1442/v1/matches\n    ```\n\n    will return all matches currently present in the database (be careful when combined with very permissive patterns and wildcards!). The `v1/matches` endpoint actually accept patterns,\n    which may be different from the one provided in the command-line. So it for instance possible to build an index for all addresses but then, lookup only a single address as:\n\n    ```console\n    $ curl http://localhost:1442/v1/matches/addr1vyc29pvl2uyzqt8nwxrcxnf558ffm27u3d9calxn8tdudjgz4xq9p\n    ```\n\n    The complete API reference is available below.\n\n    \u003cbr/\u003e\u003cbr/\u003e\n\n    \u003cp align=\"center\"\u003e\n    （✿ ͡◕ ᴗ◕ )つ━━✫ ✧･ﾟ* enjoy *:･ﾟ✧*:･ﾟ💖\n    \u003c/p\u003e\n\ndefinitions:\n  Address_Shelley: \u0026Address_Shelley\n    title: Shelley+\n    type: string\n    contentEncoding: bech32\n    example: addr1vy3qpx09uscywhpp0ekg9zwmq2yj5vp08husfq6qyh2mpps865j6t\n\n  Address_Stake: \u0026Address_Stake\n    title: Stake\n    type: string\n    contentEncoding: bech32\n    example: stake1vyc29pvl2uyzqt8nwxrcxnf558ffm27u3d9calxn8tdudjgydsx9n\n\n  Address_Bootstrap: \u0026Address_Bootstrap\n    title: Bootstrap\n    type: String\n    contentEncoding: base58\n    example: DdzFFzCqrhsnWCKDVxHipmLW7acroB11zWxe1BGP1gCh7EqmgjVPe2qes6HrsQs\n\n  Address_Base16: \u0026Address_Base16\n    title: Base16\n    type: string\n    contentEncoding: base16\n    example: 7a5e61936081db3b2117cbf59bd2123748f58ac96786567067f3314661\n\n  Address:\n    description: A Cardano address.\n    oneOf:\n      - \u003c\u003c: *Address_Shelley\n      - \u003c\u003c: *Address_Bootstrap\n\n  AddressParameter:\n    title: Address\n    description: A Cardano address or stake address.\n    oneOf:\n      - \u003c\u003c: *Address_Shelley\n      - \u003c\u003c: *Address_Stake\n      - \u003c\u003c: *Address_Bootstrap\n      - \u003c\u003c: *Address_Base16\n\n  BadRequest:\n    type: object\n    additionalProperties: false\n    properties:\n      hint:\n        type: string\n        description: Some hint about what went wrong.\n\n  Checkpoint:\n    type: object\n    additionalProperties: false\n    required:\n      - slot_no\n      - header_hash\n    properties:\n      slot_no: { \"$ref\": \"#/definitions/SlotNo\" }\n      header_hash: { \"$ref\": \"#/definitions/HeaderHash\" }\n\n  Credential:\n    oneOf:\n      - title: Bech32\n        type: string\n        description: |\n          A blake2b-224 hash digest of some credential or pre-image of those credentials.\n          Supported bech32 prefixes are:\n          - vk\n          - vkh\n          - addr_vk\n          - addr_vkh\n          - stake_vk\n          - stake_vkh\n          - script\n\n      - title: Base16 (digest)\n        type: string\n        description: A blake2b-224 hash digest of some credential (verification key hash or script hash).\n        contentEncoding: base16\n        minLength: 56\n        maxLength: 56\n\n      - title: Base16 (pre-image)\n        type: string\n        description: A blake2b-224 hash pre-image of some credential (verification key or script)\n        contentEncoding: base16\n        minLength: 56\n        maxLength: 56\n\n  DatumHash:\n    oneOf:\n      - title: Digest\n        type: string\n        description: A blake2b-256 hash digest of a Plutus' datum.\n        contentEncoding: base16\n        example: 309706b92ad8340cd6a5d31bf9d2e682fdab9fc8865ee3de14e09dedf9b1b635\n        minLength: 64\n        maxLength: 64\n\n      - title: Nothing\n        type: \"null\"\n\n  HeaderHash:\n    type: string\n    description: A blake2b-256 hash digest of a block header.\n    contentEncoding: base16\n    example: 9d09706b92adedf9b1b632e682fdab9fc8865ee3de14e0935d8340cd6a5d31bf\n    minLength: 64\n    maxLength: 64\n\n  Match:\n    type: object\n    additionalProperties: false\n    required:\n      - transaction_id\n      - output_index\n      - address\n      - value\n      - datum_hash\n      - slot_no\n    properties:\n      transaction_id: { \"$ref\": \"#/definitions/TransactionId\" }\n      output_index: { \"$ref\": \"#/definitions/OutputIndex\" }\n      address: { \"$ref\": \"#/definitions/Address\" }\n      value: { \"$ref\": \"#/definitions/Value\" }\n      datum_hash: { \"$ref\": \"#/definitions/DatumHash\" }\n      slot_no: { \"$ref\": \"#/definitions/SlotNo\" }\n\n  OutputIndex:\n    type: integer\n    description: An index of an output within a transaction.\n    minimum: 0\n    example: 2\n\n  SlotNo: \u0026slotNo\n    type: integer\n    description: An absolut slot number.\n    minimum: 0\n    example: 51540727\n\n  TransactionId:\n    type: string\n    description: A blake2b-256 hash digest of a transaction body.\n    contentEncoding: base16\n    example: 35d8340cd6a5d31bf9d09706b92adedf9b1b632e682fdab9fc8865ee3de14e09\n    minLength: 64\n    maxLength: 64\n\n  Value:\n    type: object\n    description: A (multi-asset) value of a transaction's output.\n    additionalProperties: false\n    required:\n      - coins\n    properties:\n      coins:\n        type: integer\n        description: A quantity of Lovelace.\n        minimum: 1\n        example: 42\n      assets:\n        type: object\n        description:\n        propertyNames:\n          type: string\n          pattern: ^[a-f0-9]{64}(.[a-f0-9]{64})?$\n        additionalProperties:\n          x-additionalPropertiesName: \"{policy_id}.{asset_name}\"\n          type: integer\n          description: A quantity of some asset.\n          minimum: 1\n        example:\n          5d5b08661220099e5e430475c219518179efc7e6c8289db028904834025d5b086: 231\n          efc7e6c8289db028904834025d5b085d5b08661220099e5e430475c2195181796.08661220099e: 1\n\n  Wildcard:\n    type: string\n    title: wildcard\n    enum: [\"*\"]\n\n  Health:\n    type: object\n    description: An overview of the server \u0026 connection status. Note that, when `most_recent_checkpoint` and `most_recent_node_tip` are equal, the index is fully synchronized.\n    additionalProperties: false\n    required:\n      - connection_status\n      - most_recent_checkpoint\n      - most_recent_node_tip\n    properties:\n      connection_status:\n        type: string\n        description: Condition of the connection with the underlying node.\n        enum:\n          - connected\n          - disconnected\n      most_recent_checkpoint:\n        \u003c\u003c: *slotNo\n        description: Absolute slot number of the most recent database checkpoint.\n      most_recent_node_tip:\n        \u003c\u003c: *slotNo\n        description: Absolute slot number of the current tip of the node.\n\npaths:\n  /v1/matches:\n    get:\n      operationId: getAllMatches\n      tags: [\"Matches\"]\n      summary: Get All Matches\n      description: |\n        Retrieve all matches from the database, in descending `slot_no` order. Results are streamed to the client for more efficiency.\n        Note that this is generally a bad idea for indexes built off permissive patterns (e.g. `*`) for the server will yield a large response.\n      responses:\n        200:\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items: { \"$ref\": \"#/definitions/Match\" }\n\n  /v1/matches/{pattern-fragment}:\n    get:\n      operationId: getMatchesUnary\n      tags: [\"Matches\"]\n      summary: Get Matches (x)\n      description: |\n        Retrieve matches from the database matching the given pattern, in descending `slot_no` order. Results are streamed to the client for more efficiency.\n        See [Pattern](#section/Pattern) for more information about constructing patterns.\n      parameters:\n        - in: path\n          name: pattern-fragment\n          required: true\n          schema:\n            oneOf:\n              - { \"$ref\": \"#/definitions/Wildcard\" }\n              - { \"$ref\": \"#/definitions/AddressParameter\" }\n              - { \"$ref\": \"#/definitions/Credential\" }\n      responses:\n        200:\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items: { \"$ref\": \"#/definitions/Match\" }\n        400:\n          description: Bad Request\n          content:\n            application/json:\n              schema: { \"$ref\": \"#/definitions/BadRequest\" }\n\n  /v1/matches/{pattern-fragment}/{pattern-fragment}:\n    get:\n      operationId: getMatches2Ary\n      tags: [\"Matches\"]\n      summary: Get Matches (x / y)\n      description: |\n        Retrieve matches from the database matching the given patterns, in descending `slot_no` order. Results are streamed to the client for more efficiency.\n        See [Pattern](#section/Pattern) for more information about constructing patterns.\n      parameters:\n        - in: path\n          name: pattern-fragment\n          required: true\n          schema:\n            oneOf:\n              - { \"$ref\": \"#/definitions/Wildcard\" }\n              - { \"$ref\": \"#/definitions/AddressParameter\" }\n              - { \"$ref\": \"#/definitions/Credential\" }\n      responses:\n        200:\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items: { \"$ref\": \"#/definitions/Match\" }\n        400:\n          description: Bad Request\n          content:\n            application/json:\n              schema: { \"$ref\": \"#/definitions/BadRequest\" }\n\n  /v1/checkpoints:\n    get:\n      operationId: getCheckpoints\n      tags: [\"Checkpoints\"]\n      summary: Get Checkpoints\n      description: |\n        Retrieve all checkpoints currently in the database, in descending `slot_no` order. This is useful to know where\n        the synchronization is at. On restart, the synchronization will continue from the most recent checkpoints that\n        is also known of the network.\n      responses:\n        200:\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items: { \"$ref\": \"#/definitions/Checkpoint\" }\n\n  /v1/health:\n    get:\n      operationId: getHealth\n      tags: [\"Health\"]\n      summary: Get Health\n      description: |\n        Retrieve Kupo's application health status. Note that this call is cheap and does not halt the various concurrent tasks performed by the Kupo.\n      responses:\n        200:\n          description: OK\n          content:\n            application/json:\n              schema: { \"$ref\": \"#/definitions/Health\" }\n"
		}
	},
	"Error": "parse: parse spec: paths: /v1/checkpoints: get: operation \"getCheckpoints\": responses: 200: content: \"application/json\": schema: parse schema: item: parse schema: reference \"#/definitions/Checkpoint\": resolve reference \"#/definitions/Checkpoint\": invalid schema reference \"#/definitions/Checkpoint\""
}