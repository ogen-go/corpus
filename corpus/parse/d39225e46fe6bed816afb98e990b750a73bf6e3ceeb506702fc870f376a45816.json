{
	"File": {
		"__typename": "FileMatch",
		"repository": {
			"name": "github.com/mdwheele/laravel-openapi"
		},
		"file": {
			"name": "openapi.yaml",
			"size": 0,
			"path": "tests/openapis/core-features/openapi.yaml",
			"byteSize": 6173,
			"content": "openapi: \"3.0.0\"\n\ninfo:\n  version: 1.0.0\n  title: Laravel OpenAPI Core Feature-set API Specification\n\n# The package will automatically create a route for each\n# HTTP verb under this path.\npaths:\n  /parameters/{email}:\n    post:\n      summary: Parameter Sniff (Parameter Validation)\n      description: |\n        You can specify constraints on various parameters that are sent along\n        with a request. These parameters can be part of the path, in the\n        query-string, in headers or in cookies. These parameters can be required\n        or optional and you can specify schemas to validate them.\n\n        This endpoint is a made-up example of just about every way you can deal\n        with a parameter. The schemas are fairly basic (where used), but just\n        realize, you have the full power of JSON Schema to take advantage of.\n\n      operationId: Mdwheele\\OpenApi\\Tests\\Controllers\\CoreFeaturesController@parameters\n      parameters:\n        - name: email\n          description: |\n            In Laravel, this gets passed as an argument to controller method. In\n            our example, we specify that this must be an email address, for some reason.\n          in: path\n          required: true\n          schema:\n            type: string\n            format: email\n        - name: filter\n          description: |\n            You can specify query-string parameters and place constraints on them. In this\n            example, the `filter` query parameter MUST be a string that's either `apples`,\n            `oranges`, or `zucchini`. Anything else fails request validation.\n          in: query\n          schema:\n            type: string\n            enum: ['apples', 'oranges', 'zucchini']\n        - name: X-Super-Hero\n          description: |\n            X-Super-Hero isn't required. But, if specified, it must be either `wonder-woman` or\n            `batman`. No other super heroes exist... don't @-me.\n          in: header\n          schema:\n            type: string\n            enum: ['wonder-woman', 'batman']\n        - name: X-Super-Cookie\n          description: |\n            Oh look at us, getting all fancy with our `allOf`. Basically, this means that\n            the value of our `X-Super-Cookie` must be a string that both begins with \"cookie\"\n            and ends with \"monster\". Fancy.\n\n            Could we have used a single pattern? Sure. But then we wouldn't be as fancy.\n          in: cookie\n          schema:\n            allOf:\n              - type: string\n                pattern: \"^cookie.*\"\n              - type: string\n                pattern: \".*monster$\"\n      responses:\n        200:\n          description: A dump of all parameter data sent to the API.\n          content:\n            application/json:\n              schema:\n                type: object\n                required: ['message', 'path', 'query', 'header', 'cookie']\n                properties:\n                  message:\n                    type: string\n                  path:\n                    type: object\n                  query:\n                    type: object\n                  header:\n                    type: object\n                  cookie:\n                    type: object\n\n  /requests:\n    post:\n      summary: Request Sniff (Request Validation)\n      description: |\n        You can specify constraints on the content of a request as well! Similar to\n        parameter specification, you can use JSON Schema to specify constraints on\n        the form of content you accept. You can apply different constraints based on\n        media type! Check it out.\n\n      operationId: Mdwheele\\OpenApi\\Tests\\Controllers\\CoreFeaturesController@requests\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                message:\n                  type: string\n                email:\n                  type: string\n                  format: email\n          text/plain:\n            schema:\n              type: string\n              format: email\n      responses:\n        200:\n          description: Default\n          content:\n            application/json:\n              schema:\n                type: object\n\n  /health:\n    get:\n      summary: Service Health (Response Validation)\n      description: |\n        This is an example of what an API micro-service status endpoint might\n        look like. For this example, we have an overall indicator of `status`\n        that is either `ok`, `warning` or `critical`. This is a required property\n        of the endpoint.\n\n        Optionally, we also have a log of updates that can be sent by service\n        providers when we're in a `warning` or `critical` status.\n\n        In this example operation, if you return any status other than what's\n        enumerated, you'll fail response validation. If you return any HTTP\n        status code other than 200, you'll fail response validation. If you\n        add any additional proprties to your updates other than `message` and\n        `timestamp`, then you'll fail response validation. This is all handled\n        automatically by the package!\n\n        Check out `CoreFeaturesTest` for happy-path tests and failure scenarios.\n\n      # We use operationId to specify the handler for this request.\n      operationId: Mdwheele\\OpenApi\\Tests\\Controllers\\CoreFeaturesController@healthCheck\n      responses:\n        200:\n          description: Health-check for the service.\n          content:\n            application/json:\n              schema:\n                type: object\n                required: ['status']\n                properties:\n                  status:\n                    type: string\n                    enum: ['ok', 'warning', 'critical']\n                  updates:\n                    type: array\n                    items:\n                      type: object\n                      required: ['message', 'timestamp']\n                      additionalProperties: false\n                      properties:\n                        message:\n                          type: string\n                        timestamp:\n                          type: string\n                          format: 'date-time'\n\n"
		}
	},
	"Error": "parse: parse spec: parse operations: paths: /parameters/{email}: post: operation \"Mdwheele\\\\OpenApi\\\\Tests\\\\Controllers\\\\CoreFeaturesController@parameters\": parameters: parse parameter \"X-Super-Cookie\": invalid schema:style:explode combination"
}